<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>sp和wp</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <link rel="Stylesheet" type="text/css" href="../css_style/style_zenki.css">

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>

<!-- wrap the vimwiki html -->

<h1 id="toc_1">sp和wp</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">sp和wp</a>
<ul>
<li><a href="#toc_1.1">RefBase</a>
<li><a href="#toc_1.2">struct ref_entry</a>
<li><a href="#toc_1.3">sp和wp</a>
<ul>
<li><a href="#toc_1.3.1">sp和wp继承图</a>
</ul>
<li><a href="#toc_1.4">RefBase.h</a>
<ul>
<li><a href="#toc_1.4.1">RefBase</a>
<li><a href="#toc_1.4.2">sp::sp</a>
<li><a href="#toc_1.4.3">sp::~sp</a>
<li><a href="#toc_1.4.4">wp::wp</a>
<li><a href="#toc_1.4.5">wp::~wp</a>
<li><a href="#toc_1.4.6">wp::promote</a>
</ul>
<li><a href="#toc_1.5">RefBase.cpp</a>
<ul>
<li><a href="#toc_1.5.1">RefBase::RefBase</a>
<li><a href="#toc_1.5.2">RefBase::~RefBase</a>
<li><a href="#toc_1.5.3">RefBase::incStrong</a>
<li><a href="#toc_1.5.4">RefBase::decStrong</a>
<li><a href="#toc_1.5.5">RefBase::createWeak</a>
<li><a href="#toc_1.5.6">RefBase::weakref_impl</a>
<li><a href="#toc_1.5.7">RefBase::weakref_type::incWeak</a>
<li><a href="#toc_1.5.8">RefBase::weakref_type::decWeak</a>
<li><a href="#toc_1.5.9">sp</a>
<li><a href="#toc_1.5.10">wp</a>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">RefBase</h2>
<pre class="brush:text">
    从上一节的Binder类图，我们看出Binder相关类的基类是RefBase类。它的作用是为子类保持一个引用计数，只要是继承该类的子类，
当对象赋值，销毁等操作时，会自动保持当前的引用计数。RefBase在构造时会创建一个weakref_type类型对象，该类的实现子类为weakref_impl，
实际上RefBase是通过weakref_impl来实现引用计数的增减操作。
    从RefBase的构造方法和析构方法来看，只有当弱引用的计数为0，才会销毁weakref_impl对象。
</pre>

<h2 id="toc_1.2">struct ref_entry</h2>
<pre class="brush:text">
    RefBase是通过weakref_impl来操作引用计数，那么weakref_impl又是如何实现呢？该类有个内部结构struct ref_entry，引用计数
是通过这个结构对象连接起来的链表。同时，在weakref_impl类中，包含两个ref_entry结构的成员，一个代表强引用，一个代表弱引用。
RefBase::incStrong会同时增加强引用计数和弱引用计数，而weakref_impl::incWeak只会增加弱引用计数，相对应的RefBase::decStrong
和weakref_impl::decWeak减少操作也是如此。由此得出当所有强引用对象计数为0时，其实弱引用计数还在，因此弱引用对象不会销毁。
</pre>

<h2 id="toc_1.3">sp和wp</h2>
<ul>
<li>
理解上面两个概念后，我们引入sp和wp这两个类。它们是<code>模板类</code>，用来管理上面提到的强引用和弱引用。

<li>
sp代表“强引用指针”。它提供了重载的<code>*</code>和<code>-&gt;</code>操作符来返回实际的目标对象，所以看起来像个指针。sp调用的是<code>RefBase::incString()</code>和<code>RefBase::decStrong()</code>，所以不仅对强引用做增减操作，还对弱引用做增减操作。

<li>
wp代表“弱引用指针”。wp调用的是<code>weakref_impl::incWeak()</code>和<code>weakref_impl::decWeak()</code>，所以只会对弱引用做增减操作。当一个对象同时赋值给一个sp和wp时，如果销毁sp对象，wp对象仍然存在，因为弱引用的计数没有减少。但是从wp的类方法可以发现，wp没有重载<code>*</code>和<code>-&gt;</code>操作符号，因此无法引用目标对象，必须通过<code>promote()</code>方法升级为sp对象。

<li>
无论是sp或wp，它要求构造参数的目标对象类型必须继承自<code>RefBase</code>类(可参考以下UML图)。<code>sp和wp是对目标对象的一层封装，虽然目标对象是继承于RefBase类，但他们不会直接管理引用计数，而这个任务就交给了sp和wp</code>。

</ul>

<h3 id="toc_1.3.1">sp和wp继承图</h3>
<p>
<img src="http:pic/spwp.png" />
</p>

<h2 id="toc_1.4">RefBase.h</h2>
<h3 id="toc_1.4.1">RefBase</h3>
<pre class="brush:c++">
class RefBase
{
public:
    // 增加强引用计数
    void            incStrong(const void* id) const;
    // 减少强引用计数
    void            decStrong(const void* id) const;
    ......
    
    // 内部类，表示弱引用
    class weakref_type
    {
    public:
        RefBase*            refBase() const;
        
        // 增加弱引用计数
        void                incWeak(const void* id);
        // 减少弱引用计数
        void                decWeak(const void* id);
        
        bool                attemptIncStrong(const void* id);
        bool                attemptIncWeak(const void* id);

        ......
    };
    
    weakref_type*   createWeak(const void* id) const;
            
    weakref_type*   getWeakRefs() const;
    ......

protected:
                            RefBase();
    virtual                 ~RefBase();
    
    //! Flags for extendObjectLifetime()
    enum {
        OBJECT_LIFETIME_WEAK    = 0x0001,
        OBJECT_LIFETIME_FOREVER = 0x0003
    };
    
    //! Flags for onIncStrongAttempted()
    enum {
        FIRST_INC_STRONG = 0x0001
    };
    
    virtual void            onFirstRef();
    virtual void            onLastStrongRef(const void* id);
    virtual bool            onIncStrongAttempted(uint32_t flags, const void* id);
    virtual void            onLastWeakRef(const void* id);

private:
    friend class weakref_type;
    class weakref_impl;
    
                    RefBase(const RefBase&amp; o);
    RefBase&amp;        operator=(const RefBase&amp; o);
            
    weakref_impl* const mRefs;
};
</pre>

<h3 id="toc_1.4.2">sp::sp</h3>
<pre class="brush:c++">
template&lt;typename T&gt;
sp&lt;T&gt;::sp(T* other)
    : m_ptr(other)
{
    if (other) other-&gt;incStrong(this);
}
</pre>

<h3 id="toc_1.4.3">sp::~sp</h3>
<pre class="brush:c++">
template&lt;typename T&gt;
sp&lt;T&gt;::~sp()
{
    // 强引用对象计数减少
    if (m_ptr) m_ptr-&gt;decStrong(this);
}
</pre>

<h3 id="toc_1.4.4">wp::wp</h3>
<pre class="brush:c++">
template&lt;typename T&gt;
wp&lt;T&gt;::wp(T* other)
    : m_ptr(other)
{
    if (other) m_refs = other-&gt;createWeak(this);
}
</pre>

<h3 id="toc_1.4.5">wp::~wp</h3>
<pre class="brush:c++">
template&lt;typename T&gt;
wp&lt;T&gt;::~wp()
{
    if (m_ptr) m_refs-&gt;decWeak(this);
}
</pre>

<h3 id="toc_1.4.6">wp::promote</h3>
<pre class="brush:c++">
template&lt;typename T&gt;
sp&lt;T&gt; wp&lt;T&gt;::promote() const
{
    return sp&lt;T&gt;(m_ptr, m_refs);
}
</pre>

<h2 id="toc_1.5">RefBase.cpp</h2>
<h3 id="toc_1.5.1">RefBase::RefBase</h3>
<pre class="brush:c++">
RefBase::RefBase()
    : mRefs(new weakref_impl(this))
{
}
</pre>

<h3 id="toc_1.5.2">RefBase::~RefBase</h3>
<pre class="brush:c++">
RefBase::~RefBase()
{
    if (mRefs-&gt;mWeak == 0) {
        delete mRefs;
    }
}
</pre>

<h3 id="toc_1.5.3">RefBase::incStrong</h3>
<pre class="brush:c++">
void RefBase::incStrong(const void* id) const
{
    weakref_impl* const refs = mRefs;
    // 先添加弱引用对象
    refs-&gt;addWeakRef(id);
    // 添加弱引用计数
    refs-&gt;incWeak(id);
    
    // 再添加强引用对象
    refs-&gt;addStrongRef(id);
    const int32_t c = android_atomic_inc(&amp;refs-&gt;mStrong);
    
    if (c != INITIAL_STRONG_VALUE)  {
        return;
    }

    android_atomic_add(-INITIAL_STRONG_VALUE, &amp;refs-&gt;mStrong);
    const_cast&lt;RefBase*&gt;(this)-&gt;onFirstRef();
}
</pre>

<h3 id="toc_1.5.4">RefBase::decStrong</h3>
<pre class="brush:c++">
void RefBase::decStrong(const void* id) const
{
    weakref_impl* const refs = mRefs;
    refs-&gt;removeStrongRef(id);
    const int32_t c = android_atomic_dec(&amp;refs-&gt;mStrong);
    
    if (c == 1) {
        const_cast&lt;RefBase*&gt;(this)-&gt;onLastStrongRef(id);
        if ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_WEAK) != OBJECT_LIFETIME_WEAK) {
            delete this;
        }
    }
    refs-&gt;removeWeakRef(id);
    refs-&gt;decWeak(id);
}
</pre>

<h3 id="toc_1.5.5">RefBase::createWeak</h3>
<pre class="brush:c++">
RefBase::weakref_type* RefBase::createWeak(const void* id) const
{
    mRefs-&gt;incWeak(id);
    return mRefs;
}
</pre>


<h3 id="toc_1.5.6">RefBase::weakref_impl</h3>
<pre class="brush:c++">
class RefBase::weakref_impl : public RefBase::weakref_type
{
public:
    volatile int32_t    mStrong;
    volatile int32_t    mWeak;
    RefBase* const      mBase;
    volatile int32_t    mFlags;

    weakref_impl(RefBase* base)
        : mStrong(INITIAL_STRONG_VALUE)
        , mWeak(0)
        , mBase(base)
        , mFlags(0)
    {
    }

    void addStrongRef(const void* /*id*/) { }
    void removeStrongRef(const void* /*id*/) { }
    void addWeakRef(const void* /*id*/) { }
    void removeWeakRef(const void* /*id*/) { }
    void printRefs() const { }
    void trackMe(bool, bool) { }

    ~weakref_impl()
    {
        LOG_ALWAYS_FATAL_IF(!mRetain &amp;&amp; mStrongRefs != NULL, "Strong references remain!");
        LOG_ALWAYS_FATAL_IF(!mRetain &amp;&amp; mWeakRefs != NULL, "Weak references remain!");
    }

    // 增加强引用计数
    void addStrongRef(const void* id)
    {
        addRef(&amp;mStrongRefs, id, mStrong);
    }

    // 减少强引用计数
    void removeStrongRef(const void* id)
    {
        if (!mRetain)
            removeRef(&amp;mStrongRefs, id);
        else
            addRef(&amp;mStrongRefs, id, -mStrong);
    }

    // 增加弱引用计数
    void addWeakRef(const void* id)
    {
        addRef(&amp;mWeakRefs, id, mWeak);
    }

    // 减少弱引用计数
    void removeWeakRef(const void* id)
    {
        if (!mRetain)
            removeRef(&amp;mWeakRefs, id);
        else
            addRef(&amp;mWeakRefs, id, -mWeak);
    }

private:
    // 引用计数数据结构
    struct ref_entry
    {
        ref_entry* next;
        const void* id;
#if DEBUG_REFS_CALLSTACK_ENABLED
        CallStack stack;
#endif
        int32_t ref;
    };

    void addRef(ref_entry** refs, const void* id, int32_t mRef)
    {
        if (mTrackEnabled) {
            AutoMutex _l(mMutex);
            ref_entry* ref = new ref_entry;
            // Reference count at the time of the snapshot, but before the
            // update.  Positive value means we increment, negative--we
            // decrement the reference count.
            ref-&gt;ref = mRef;
            ref-&gt;id = id;
#if DEBUG_REFS_CALLSTACK_ENABLED
            ref-&gt;stack.update(2);
#endif
            
            ref-&gt;next = *refs;
            *refs = ref;
        }
    }

    void removeRef(ref_entry** refs, const void* id)
    {
        if (mTrackEnabled) {
            AutoMutex _l(mMutex);
            
            ref_entry* ref = *refs;
            while (ref != NULL) {
                if (ref-&gt;id == id) {
                    *refs = ref-&gt;next;
                    delete ref;
                    return;
                }
                
                refs = &amp;ref-&gt;next;
                ref = *refs;
            }
        }
    }
    ......

    Mutex mMutex;
    // 强引用对象
    ref_entry* mStrongRefs;
    // 弱引用对象
    ref_entry* mWeakRefs;

    bool mTrackEnabled;
    bool mRetain;

#if 0
    mutable Mutex mMutex;
    KeyedVector&lt;const void*, int32_t&gt; mStrongRefs;
    KeyedVector&lt;const void*, int32_t&gt; mWeakRefs;
#endif

#endif
};
</pre>

<h3 id="toc_1.5.7">RefBase::weakref_type::incWeak</h3>
<pre class="brush:c++">
void RefBase::weakref_type::incWeak(const void* id)
{
    weakref_impl* const impl = static_cast&lt;weakref_impl*&gt;(this);
    impl-&gt;addWeakRef(id);
    const int32_t c = android_atomic_inc(&amp;impl-&gt;mWeak);
}
</pre>

<h3 id="toc_1.5.8">RefBase::weakref_type::decWeak</h3>
<pre class="brush:c++">
void RefBase::weakref_type::decWeak(const void* id)
{
    weakref_impl* const impl = static_cast&lt;weakref_impl*&gt;(this);
    impl-&gt;removeWeakRef(id);
    const int32_t c = android_atomic_dec(&amp;impl-&gt;mWeak);
    if (c != 1) return;
    
    if ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_WEAK) != OBJECT_LIFETIME_WEAK) {
        if (impl-&gt;mStrong == INITIAL_STRONG_VALUE)
            delete impl-&gt;mBase;
        else {
            delete impl;
        }
    } else {
        impl-&gt;mBase-&gt;onLastWeakRef(id);
        if ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_FOREVER) != OBJECT_LIFETIME_FOREVER) {
            delete impl-&gt;mBase;
        }
    }
}
</pre>

<h3 id="toc_1.5.9">sp</h3>
<pre class="brush:c++">
template &lt;typename T&gt;
class sp
{
public:
    typedef typename RefBase::weakref_type weakref_type;
    
    inline sp() : m_ptr(0) { }

    sp(T* other);
    sp(const sp&lt;T&gt;&amp; other);
    template&lt;typename U&gt; sp(U* other);
    template&lt;typename U&gt; sp(const sp&lt;U&gt;&amp; other);

    ~sp();
    
    sp&amp; operator = (T* other);
    sp&amp; operator = (const sp&lt;T&gt;&amp; other);
    
    template&lt;typename U&gt; sp&amp; operator = (const sp&lt;U&gt;&amp; other);
    template&lt;typename U&gt; sp&amp; operator = (U* other);
    
    void force_set(T* other);
    void clear();
    
    // 可以对对象进行操作
    inline  T&amp;      operator* () const  { return *m_ptr; }
    inline  T*      operator-&gt; () const { return m_ptr;  }
    inline  T*      get() const         { return m_ptr; }

    COMPARE(==)
    COMPARE(!=)
    COMPARE(&gt;)
    COMPARE(&lt;)
    COMPARE(&lt;=)
    COMPARE(&gt;=)

private:    
    template&lt;typename Y&gt; friend class sp;
    template&lt;typename Y&gt; friend class wp;

    sp(T* p, weakref_type* refs);
    T*              m_ptr;
};
</pre>

<h3 id="toc_1.5.10">wp</h3>
<pre class="brush:c++">
template &lt;typename T&gt;
class wp
{
public:
    typedef typename RefBase::weakref_type weakref_type;
    
    inline wp() : m_ptr(0) { }

    wp(T* other);
    wp(const wp&lt;T&gt;&amp; other);
    wp(const sp&lt;T&gt;&amp; other);
    template&lt;typename U&gt; wp(U* other);
    template&lt;typename U&gt; wp(const sp&lt;U&gt;&amp; other);
    template&lt;typename U&gt; wp(const wp&lt;U&gt;&amp; other);

    ~wp();
    
    wp&amp; operator = (T* other);
    wp&amp; operator = (const wp&lt;T&gt;&amp; other);
    wp&amp; operator = (const sp&lt;T&gt;&amp; other);
    
    template&lt;typename U&gt; wp&amp; operator = (U* other);
    template&lt;typename U&gt; wp&amp; operator = (const wp&lt;U&gt;&amp; other);
    template&lt;typename U&gt; wp&amp; operator = (const sp&lt;U&gt;&amp; other);
    
    void set_object_and_refs(T* other, weakref_type* refs);

    // 升级成sp
    // 缺少目标对象的引用，因此无法使用目标对象
    sp&lt;T&gt; promote() const;

    void clear();

    inline  weakref_type* get_refs() const { return m_refs; }
    inline  T* unsafe_get() const { return m_ptr; }
        
    COMPARE(==)
    COMPARE(!=)
    COMPARE(&gt;)
    COMPARE(&lt;)
    COMPARE(&lt;=)
    COMPARE(&gt;=)

private:
    template&lt;typename Y&gt; friend class sp;
    template&lt;typename Y&gt; friend class wp;

    T*              m_ptr;
    weakref_type*   m_refs;
};
</pre>


<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

</body>
</html>
