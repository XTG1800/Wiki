<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Audio系统</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
	<link type="text/css" rel="stylesheet" href="css_style/style_zenki.css"/>

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>


<h1 id="toc_1">Audio系统(Android 2.3)</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">Audio系统(Android 2.3)</a></li>
<ul>
<li><a href="#toc_1.1">相关文件</a></li>
<li><a href="#toc_1.2">Audio系统概述</a></li>
<li><a href="#toc_1.3">Audio各个层次的对应关系</a></li>
<li><a href="#toc_1.4">Audio系统管理接口</a></li>
<ul>
<li><a href="#toc_1.4.1">Audio系统的管理(AudioManager)</a></li>
<ul>
<li><a href="#toc_1.4.1.1">请求声音焦点</a></li>
<li><a href="#toc_1.4.1.2">注册Media按键的监听</a></li>
</ul>
<li><a href="#toc_1.4.2">Audio的Java层系统服务(AudioService)</a></li>
</ul>
<li><a href="#toc_1.5">声音系统的功能接口</a></li>
<ul>
<li><a href="#toc_1.5.1">管理接口(AudioSystem)</a></li>
<li><a href="#toc_1.5.2">声音输出(AudioTrack)</a></li>
<li><a href="#toc_1.5.3">音频采集(AudioRecord)</a></li>
</ul>
<li><a href="#toc_1.6">核心服务(C++层)</a></li>
<ul>
<li><a href="#toc_1.6.1">工作引擎(AudioFlinger)</a></li>
<li><a href="#toc_1.6.2">策略管理(AudioPolicyService)</a></li>
<li><a href="#toc_1.6.3">音频多路输出</a></li>
<li><a href="#toc_1.6.4">混音处理(AudioMixer)</a></li>
</ul>
<li><a href="#toc_1.7">Audio硬件抽象层</a></li>
</ul>
</ul>
</div>

<h2 id="toc_1.1">相关文件</h2>
<pre class="brush:text">
// java
frameworks/base/media/java/android/media/AudioManager.java
frameworks/base/media/java/android/media/AudioSystem.java
frameworks/base/media/java/android/media/AudioTrack.java
frameworks/base/media/java/android/media/AudioRecord.java
frameworks/base/media/java/android/media/AudioFormat.java
frameworks/base/media/java/android/media/AudioService.java

// jni
frameworks/base/core/jni/android_media_AudioTrack.cpp
frameworks/base/core/jni/android_media_AudioRecord.cpp
frameworks/base/core/jni/android_media_AudioSystem.cpp

// C/C++
frameworks/base/include/media/*
frameworks/base/media/mediaserver/main_mediaserver.cpp
frameworks/base/services/audioflinger/AudioFlinger.cpp
frameworks/base/services/audioflinger/AudioPolicyService.cpp
frameworks/base/services/audioflinger/AudioPolicyManagerBase.cpp
frameworks/base/media/libmedia/AudioTrack.cpp
frameworks/base/media/libmedia/AudioRecord.cpp
frameworks/base/media/libmedia/AudioSystem.cpp
frameworks/base/media/libmedia/AudioEffect.cpp

// HAL
hardware/libhardware_legacy/include/hardware_legacy/AudioHardwareInterface.h 
hardware/libhardware_legacy/include/hardware_legacy/AudioPolicyInterface.h 
hardware/libhardware_legacy/include/hardware_legacy/AudioPolicyManagerBase.h 
</pre>

<h2 id="toc_1.2">Audio系统概述</h2>
<ul>
<li>
Audio系统主要包含以下几个层次：
</li>
<ul>
<li>
Java层
</li>
<ul>
<li>
AudioManager，该类为应用层提供接口，是Audio系统的管理类，提供设置Audio参数等功能，具体实现调用Service接口。
</li>
<li>
AudioService，该Service在SystemServer中注册，为AudioManager提供接口实现。
</li>
<li>
AudioSystem，该类是声音系统在Java层的抽象，主要通过JNI访问下层的接口。
</li>
<li>
AudioTrack，该类是放音系统在Java层的抽象，主要通过JNI访问下层的接口。
</li>
<li>
AudioRecord，该类是录用系统在Java层的抽象，主要通过JNI访问下层的接口。
</li>
<li>
AudioFormat，该类为Java层提供Audio的参数设置。
</li>
</ul>
<li>
C++层
</li>
<ul>
<li>
IAudioPolicyService，该接口负责提供声音控制的服务，包括调节音量大小、设置耳机类型等，主要通过AudioSystem接口实现具体功能。
</li>
<li>
AudioSystem，该类声音系统在C++层的抽象，主要通过IAudioFlinger接口实现具体功能。
</li>
<li>
AudioTrack，该类是放音系统在C++层的抽象，主要通过IAudioFlinger接口获取IAudioTrack来实现具体功能。
</li>
<li>
AudioRecord，该类是录用系统在C++层的抽象，主要通过IAudioFlinger接口获取IAudioRecord来实现具体功能。
</li>
<li>
AudioEffect，该类是混音效果在C++层的抽象，主要通过IAudioFlinger接口实现具体功能。
</li>
<li>
AudioFlinger，该类是IAudioFlinger的具体实现类，提供了方法来获取IAudioTrack和IAudioRecord。
</li>
<li>
TrackHandle，该类是IAudioTrack的具体实现类。
</li>
<li>
RecordHandle，该类是IAudioRecord的具体实现类。
</li>
</ul>
<li>
硬件抽象层
</li>
<ul>
<li>
AudioHardwareInterface，硬件接口类。
</li>
<li>
AudioStreamIn，硬件输入接口类。
</li>
<li>
AudioStreamOut，硬件输出接口类。
</li>
</ul>
</ul>
</ul>

<h2 id="toc_1.3">Audio各个层次的对应关系</h2>
<table>
<tr>
<th>&nbsp;</th>
<th>Audio管理环节</th>
<th>Audio输出</th>
<th>Audio输入</th>
</tr>
<tr>
<td>Java层</td>
<td>android.media.AudioSystem</td>
<td>android.media.AudioTrack</td>
<td>android.media.AudioRecord</td>
</tr>
<tr>
<td>本地框架层</td>
<td>AudioSystem</td>
<td>AudioTrack</td>
<td>AudioRecord</td>
</tr>
<tr>
<td>AudioFlinger</td>
<td>AudioFlinger</td>
<td>TrackHandle(实现IAudioTrack)</td>
<td>RecordHandle(实现IAudioRecord)</td>
</tr>
<tr>
<td>硬件抽象层</td>
<td>AudioHardwareInterface</td>
<td>AudioStreamOut</td>
<td>AudioStreamIn</td>
</tr>
</table>

<h2 id="toc_1.4">Audio系统管理接口</h2>
<h3 id="toc_1.4.1">Audio系统的管理(AudioManager)</h3>
<pre class="brush:text">
    声音系统的管理由AudioManager负责，它是提供给应用层的接口，用来设置音效、蓝牙耳机开关、麦克风开关。
该类不做实际的放音和录音的操作，它会向下调用AudioService和AudioSystem接口来做具体操作。这里需要注意一下
声音焦点的处理。
    主要方法可参考以下列表：
</pre>

<table>
<tr>
<th>方法名</th>
<th>描述</th>
<th>备注</th>
</tr>
<tr>
<td>adjustVolume</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>adjustStreamVolume</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>getStreamMaxVolume</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>getStreamVolume</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>setRingerMode</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>getRingerMode</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>setVibrateSetting</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>getVibrateSetting</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>setSpeakerphoneOn</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>isSpeakerphoneOn</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>startBluetoothSco</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>stopBluetoothSco</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>setBluetoothScoOn</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>isBluetoothScoOn</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>setWiredHeadsetOn</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>isWiredHeadsetOn</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>setMicrophoneMute</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>isMicrophoneMute</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>setMode</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>getMode</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>setRouting</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>getRouting</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>isMusicActive</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>setParameter</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>playSoundEffect</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</table>

<h4 id="toc_1.4.1.1">请求声音焦点</h4>
<ul>
<li>
AudioManager.requestAudioFocus方法用来向AudioService请求获得声音焦点，该方法首先会注册OnAudioFocusChangeListener，随后调用AudioService.requestAudioFocus。
</li>
<li>
请求声音焦点可以加入回调机制，AudioService.requestAudioFocus可以传入IAudioFocusDispatcher对象作为参数来处理回调。
</li>
<li>
IAudioFocusDispatcher是用来进程间通讯的回调，因为要求获取焦点的通常是不同进程。查看该接口的实现，它会使用FocusEventHandlerDelegate类处理本地的回调，因此我们还需要注册一个本地的回调。
</li>
<li>
AudioManager.registerAudioFocusListener方法注册一个本地回调接口OnAudioFocusChangeListener，该对象会加入到HashMap中，在IAudioFocusDispatcher调用时从HashMap中查找。
</li>
<li>
其他相关方法
</li>
<ul>
<li>
注销声音回调：unregisterAudioFocusListener。
</li>
<li>
放弃声音焦点：abandonAudioFocus。
</li>
</ul>
</ul>

<ul>
<li>
调用AudioService的同名方法，并注册一个回调来响应焦点变化。
</li>
</ul>

<pre class="brush:java">
public int requestAudioFocus(OnAudioFocusChangeListener l, int streamType, int durationHint) {
    int status = AUDIOFOCUS_REQUEST_FAILED;
    if ((durationHint &lt; AUDIOFOCUS_GAIN) || (durationHint &gt; AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK))
    {
        return status;
    }
    // 注册本地回调
    registerAudioFocusListener(l);
    
    IAudioService service = getService();
    try {
        // 向service请求声音焦点
        status = service.requestAudioFocus(streamType, durationHint, mICallBack,
                mAudioFocusDispatcher, getIdForAudioFocusListener(l));
    } catch (RemoteException e) {
    }
    return status;
}
</pre>

<ul>
<li>
在本地维护一个回调的HashMap。
</li>
</ul>

<pre class="brush:java">
public void registerAudioFocusListener(OnAudioFocusChangeListener l) {
    synchronized(mFocusListenerLock) {
        if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
            return;
        }
        mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l), l);
    }
}
</pre>

<ul>
<li>
创建一个响应焦点变化的IAudioFocusDispatcher接口实现，该实现使用了FocusEventHandlerDelegate类。
</li>
</ul>

<pre class="brush:java">
private IAudioFocusDispatcher mAudioFocusDispatcher = new IAudioFocusDispatcher.Stub() {
    public void dispatchAudioFocusChange(int focusChange, String id) {
        Message m = mAudioFocusEventHandlerDelegate.getHandler().obtainMessage(focusChange, id);
        mAudioFocusEventHandlerDelegate.getHandler().sendMessage(m);
    }
};
</pre>

<ul>
<li>
当发生声音焦点变化时，会根据相应的事件回调已注册的OnAudioFocusChangeListener对象。
</li>
</ul>

<pre class="brush:java">
// Handler for audio focus events coming from the audio service.
private FocusEventHandlerDelegate mAudioFocusEventHandlerDelegate =
        new FocusEventHandlerDelegate();

// Helper class to handle the forwarding of audio focus events to the appropriate listener
private class FocusEventHandlerDelegate {
    ......
    FocusEventHandlerDelegate() {
        ...... 
        if (looper != null) {
            mHandler = new Handler(looper) {
                @Override
                public void handleMessage(Message msg) {
                    OnAudioFocusChangeListener listener = null;
                    synchronized(mFocusListenerLock) {
                        // 查找本地回调
                        listener = findFocusListener((String)msg.obj);
                    }
                    if (listener != null) {
                        // 调用本地回调
                        listener.onAudioFocusChange(msg.what);
                    }
                }
            };
        } 
        ......
    }
    ......
}
</pre>

<h4 id="toc_1.4.1.2">注册Media按键的监听</h4>
<ul>
<li>
该功能是将相关应用注册给Service，当Media按键触发时，由Service调用注册的组件打开相应的媒体应用。
</li>
<li>
registerMediaButtonEventReceiver用来注册监听，unregisterMediaButtonEventReceiver用来注销监听。这两个方法都是调用AudioService同名方法进行注册。
</li>
<li>
相关方法如下：
</li>
</ul>

<table>
<tr>
<th>方法名</th>
<th>描述</th>
<th>备注</th>
</tr>
<tr>
<td>registerMediaButtonEventReceiver</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>unregisterMediaButtonEventReceiver</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</table>


<h3 id="toc_1.4.2">Audio的Java层系统服务(AudioService)</h3>
<ul>
<li>
<a href="AudioService.html">AudioService</a>
</li>
</ul>

<h2 id="toc_1.5">声音系统的功能接口</h2>
<h3 id="toc_1.5.1">管理接口(AudioSystem)</h3>
<ul>
<li>
<a href="AudioSystem.html">AudioSystem</a>：该组件主要用来管理AudioFlinger。
</li>
</ul>

<h3 id="toc_1.5.2">声音输出(AudioTrack)</h3>
<ul>
<li>
<a href="AudioTrack.html">AudioTrack</a>：该组件主要负责声音的输出。
</li>
</ul>

<h3 id="toc_1.5.3">音频采集(AudioRecord)</h3>
<ul>
<li>
<a href="AudioRecord.html">AudioRecord</a>：该组件主要负责音频数据的采集。
</li>
</ul>

<h2 id="toc_1.6">核心服务(C++层)</h2>
<ul>
<li>
Audio系统在C++层的两个核心服务是<code>AudioPolicyService</code>和<code>AudioFlinger</code>，见mediaserver的初始化。这两个服务使用Binder机制为上层提供接口调用。其中AudioPolicyService负责声音的控制，AudioFlinger负责音频数据的处理。
</li>
<li>
参考main_mediaserver示例
</li>
</ul>

<pre class="brush:c++">
int main(int argc, char** argv)
{
    sp&lt;ProcessState&gt; proc(ProcessState::self());
    sp&lt;IServiceManager&gt; sm = defaultServiceManager();
    AudioFlinger::instantiate();
    MediaPlayerService::instantiate();
    CameraService::instantiate();
    AudioPolicyService::instantiate();
    ProcessState::self()-&gt;startThreadPool();
    IPCThreadState::self()-&gt;joinThreadPool();
}
</pre>

<h3 id="toc_1.6.1">工作引擎(AudioFlinger)</h3>
<ul>
<li>
<a href="AudioFlinger.html">AudioFlinger</a>：该组件是Audio系统的工作引擎，管理系统中的输入输出音频流、音频数据的混音，及通过HAL层读写硬件。
</li>
</ul>

<h3 id="toc_1.6.2">策略管理(AudioPolicyService)</h3>
<ul>
<li>
<a href="AudioPolicyService.html">AudioPolicyService</a>：该组件负责Audio系统的策略控制，具体掌管系统中声音设备的选择和切换、音量控制等功能。
</li>
</ul>

<h3 id="toc_1.6.3">音频多路输出</h3>
<ul>
<li>
<a href="音频多路输出处理.html">音频多路输出处理</a>
</li>
</ul>

<h3 id="toc_1.6.4">混音处理(AudioMixer)</h3>
<ul>
<li>
<a href="混音处理.html">混音处理</a>
</li>
</ul>

<h2 id="toc_1.7">Audio硬件抽象层</h2>
<ul>
<li>
<a href="Audio硬件抽象层.html">Audio硬件抽象层</a>
</li>
</ul>
<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

<!--<script type="text/javascript">-->
<!--var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");-->
<!--document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));-->
<!--</script>-->
<!--<script type="text/javascript">-->
<!--try {-->
<!--var pageTracker = _gat._getTracker("UA-15922433-1");-->
<!--pageTracker._trackPageview();-->
<!--} catch(err) {}-->
<!--</script>-->

</body>
</html>
