<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>守护进程的驱动者</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
	<link type="text/css" rel="stylesheet" href="css_style/style_zenki.css"/>

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>


<h1 id="toc_1">守护进程的驱动者</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">守护进程的驱动者</a></li>
<ul>
<li><a href="#toc_1.1">相关文件</a></li>
<li><a href="#toc_1.2">框架图</a></li>
<li><a href="#toc_1.3">要点分析</a></li>
<ul>
<li><a href="#toc_1.3.1">示例代码</a></li>
</ul>
<li><a href="#toc_1.4">IServiceManager.h</a></li>
<ul>
<li><a href="#toc_1.4.1">IServiceManager</a></li>
<li><a href="#toc_1.4.2">BnServiceManager</a></li>
</ul>
<li><a href="#toc_1.5">IServiceManager.cpp</a></li>
<ul>
<li><a href="#toc_1.5.1">defaultServiceManager</a></li>
<li><a href="#toc_1.5.2">interface_cast</a></li>
<li><a href="#toc_1.5.3">BpServiceManager</a></li>
<li><a href="#toc_1.5.4">BnServiceManager</a></li>
</ul>
<li><a href="#toc_1.6">IInterface.h</a></li>
<ul>
<li><a href="#toc_1.6.1">DECLARE_META_INTERFACE</a></li>
<li><a href="#toc_1.6.2">IMPLEMENT_META_INTERFACE</a></li>
</ul>
<li><a href="#toc_1.7">ProcessState.cpp</a></li>
<ul>
<li><a href="#toc_1.7.1">getContextObject 方法1</a></li>
<li><a href="#toc_1.7.2">getContextObject 方法2</a></li>
<li><a href="#toc_1.7.3">getStrongProxyForHandle</a></li>
</ul>
<li><a href="#toc_1.8">BpBinder.cpp</a></li>
<ul>
<li><a href="#toc_1.8.1">BpBinder::BpBinder</a></li>
<li><a href="#toc_1.8.2">transact</a></li>
</ul>
<li><a href="#toc_1.9">ServiceManager.h</a></li>
<ul>
<li><a href="#toc_1.9.1">BServiceManager</a></li>
</ul>
<li><a href="#toc_1.10">ServiceManager.cpp</a></li>
<ul>
<li><a href="#toc_1.10.1">BServiceManager</a></li>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">相关文件</h2>
<pre class="brush:text">
frameworks/base/include/binder/IServiceManager.h
frameworks/base/libs/binder/IServiceManager.cpp
frameworks/base/cmds/runtime/ServiceManager.h
frameworks/base/cmds/runtime/ServiceManager.cpp
frameworks/base/include/binde/IInterface.h
frameworks/base/libs/binde/IInterface.cpp
frameworks/base/include/binde/BpBinder.h
frameworks/base/libs/binde/BpBinder.cpp
</pre>

<h2 id="toc_1.2">框架图</h2>
<p>
<img src="pic/Binder_frame.png" />
</p>

<h2 id="toc_1.3">要点分析</h2>
<ul>
<li>
之所以分离这一部分内容，是因为Android存在一个特殊的，也是基于Binder实现的一个守护进程ServiceManager。服务端如何注册？客户端又如何去查询？这是本章要解决的问题。Android提供了与进程ServiceManager交互的机制，它是ServiceManager的驱动者，服务端通过它来注册服务，客户端又通过它来查询服务。
</li>
<li>
注册和查询的功能主要是通过<code>IServiceManager</code>、<code>BpServiceManager</code>来完成。这一机制自身也是通过Binder来实现，它与系统进程ServiceManager合作来完成服务的注册、查询等等功能。
</li>
<li>
参见<a href="服务端守护进程.html">服务端守护进程</a>
</li>
</ul>

<h3 id="toc_1.3.1">示例代码</h3>
<pre class="brush:c++">
void CameraService::instantiate() {
    defaultServiceManager()-&gt;addService(
            String16("media.camera"), new CameraService());
}
</pre>

<h2 id="toc_1.4">IServiceManager.h</h2>
<ul>
<li>
IServiceManager为Android的基础服务，它用来完成添加各种其他服务的功能并为客户端提供查询接口。它是一个完整Binder机制的C++实现。
</li>
<li>
IServiceManager定义了几个接口方法<code>getService</code>、<code>checkService</code>、<code>addService</code>和<code>listServices</code>。
</li>
<li>
BnServiceManager为该服务的实现类。
</li>
<li>
BpServiceManager为该服务的代理类。
</li>
<li>
分析从defaultServiceManager()方法开始。
</li>
</ul>

<h3 id="toc_1.4.1">IServiceManager</h3>
<pre class="brush:c++">
class IServiceManager : public IInterface
{
public:
    DECLARE_META_INTERFACE(ServiceManager);

    virtual sp&lt;IBinder&gt;         getService( const String16&amp; name) const = 0;
    virtual sp&lt;IBinder&gt;         checkService( const String16&amp; name) const = 0;
    virtual status_t            addService( const String16&amp; name, const sp&lt;IBinder&gt;&amp; service) = 0;
    virtual Vector&lt;String16&gt;    listServices() = 0;

    enum {
        GET_SERVICE_TRANSACTION = IBinder::FIRST_CALL_TRANSACTION,
        CHECK_SERVICE_TRANSACTION,
        ADD_SERVICE_TRANSACTION,
        LIST_SERVICES_TRANSACTION,
    };
};

sp&lt;IServiceManager&gt; defaultServiceManager();

template&lt;typename INTERFACE&gt;
status_t getService(const String16&amp; name, sp&lt;INTERFACE&gt;* outService)
{
    const sp&lt;IServiceManager&gt; sm = defaultServiceManager();
    if (sm != NULL) {
        *outService = interface_cast&lt;INTERFACE&gt;(sm-&gt;getService(name));
        if ((*outService) != NULL) return NO_ERROR;
    }
    return NAME_NOT_FOUND;
}

bool checkCallingPermission(const String16&amp; permission);
bool checkCallingPermission(const String16&amp; permission, int32_t* outPid, int32_t* outUid);
bool checkPermission(const String16&amp; permission, pid_t pid, uid_t uid);
</pre>

<h3 id="toc_1.4.2">BnServiceManager</h3>
<pre class="brush:c++">
class BnServiceManager : public BnInterface&lt;IServiceManager&gt;
{
public:
    virtual status_t onTransact( uint32_t code,
                                    const Parcel&amp; data,
                                    Parcel* reply,
                                    uint32_t flags = 0);
};
</pre>

<h2 id="toc_1.5">IServiceManager.cpp</h2>
<h3 id="toc_1.5.1">defaultServiceManager</h3>
<ul>
<li>
首先通过<code>ProcessState::self()-&gt;getContextObject(NULL)</code>获取<code>0</code>号句柄的<code>BpBinder</code>对象。
</li>
<li>
通过interface_cast()方法转换成<code>BpServiceManager</code>，INTERFACE::asInterface(obj)的实现需查看<code>IMPLEMENT_META_INTERFACE</code>宏。这里有一个要点：基于Binder的接口还需要继承自IInterface类。该类的宏定义提供了一系列关于Binder与接口之间的转换。
</li>
<li>
随后BpServiceManager会通过代理方法，访问驱动层，从而实现addService()功能。
</li>
</ul>

<pre class="brush:c++">
sp&lt;IServiceManager&gt; defaultServiceManager()
{
    if (gDefaultServiceManager != NULL) return gDefaultServiceManager;
    
    {
        AutoMutex _l(gDefaultServiceManagerLock);
        if (gDefaultServiceManager == NULL) {
            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(
                ProcessState::self()-&gt;getContextObject(NULL));
        }
    }
    
    return gDefaultServiceManager;
}
</pre>

<h3 id="toc_1.5.2">interface_cast</h3>
<pre class="brush:c++">
template&lt;typename INTERFACE&gt;
inline sp&lt;INTERFACE&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)
{
    return INTERFACE::asInterface(obj);
}
</pre>

<h3 id="toc_1.5.3">BpServiceManager</h3>
<ul>
<li>
该类为ServiceManager方法的代理类，它实现了一套自己的<code>*Service()</code>方法。
</li>
<li>
代理类的*Service()方法会使用remote()-&gt;transact()方法调用远程对象的实现。
</li>
<li>
remote()返回的是BpBinder的对象，由此调用BpBinder的transact()方法。
</li>
</ul>

<pre class="brush:c++">
// 实现代理端的方法
class BpServiceManager : public BpInterface&lt;IServiceManager&gt;
{
public:
    BpServiceManager(const sp&lt;IBinder&gt;&amp; impl)
        : BpInterface&lt;IServiceManager&gt;(impl)
    {
    }
        
    virtual sp&lt;IBinder&gt; getService(const String16&amp; name) const
    {
        unsigned n;
        for (n = 0; n &lt; 5; n++){
            sp&lt;IBinder&gt; svc = checkService(name);
            if (svc != NULL) return svc;
            sleep(1);
        }
        return NULL;
    }
    
    virtual sp&lt;IBinder&gt; checkService( const String16&amp; name) const
    {
        Parcel data, reply;
        // 写入接口描述
        data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());
        // 写入服务名
        data.writeString16(name);
        // 调用BpBinder对象的transact()方法
        remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply);
        return reply.readStrongBinder();
    }

    virtual status_t addService(const String16&amp; name, const sp&lt;IBinder&gt;&amp; service)
    {
        Parcel data, reply;
        data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());
        data.writeString16(name);
        data.writeStrongBinder(service);
        status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);
        return err == NO_ERROR ? reply.readInt32() : err;
    }

    virtual Vector&lt;String16&gt; listServices()
    {
        Vector&lt;String16&gt; res;
        int n = 0;

        for (;;) {
            Parcel data, reply;
            data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());
            data.writeInt32(n++);
            status_t err = remote()-&gt;transact(LIST_SERVICES_TRANSACTION, data, &amp;reply);
            if (err != NO_ERROR)
                break;
            res.add(reply.readString16());
        }
        return res;
    }
};

IMPLEMENT_META_INTERFACE(ServiceManager, "android.os.IServiceManager");
</pre>

<h3 id="toc_1.5.4">BnServiceManager</h3>
<pre class="brush:c++">
// 该类为抽象类，会调用它的子类BServiceManager来实现Server端的功能
status_t BnServiceManager::onTransact(
    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)
{
    //printf("ServiceManager received: "); data.print();
    switch(code) {
        case GET_SERVICE_TRANSACTION: {
            CHECK_INTERFACE(IServiceManager, data, reply);
            String16 which = data.readString16();
            sp&lt;IBinder&gt; b = const_cast&lt;BnServiceManager*&gt;(this)-&gt;getService(which);
            reply-&gt;writeStrongBinder(b);
            return NO_ERROR;
        } break;
        case CHECK_SERVICE_TRANSACTION: {
            CHECK_INTERFACE(IServiceManager, data, reply);
            String16 which = data.readString16();
            sp&lt;IBinder&gt; b = const_cast&lt;BnServiceManager*&gt;(this)-&gt;checkService(which);
            reply-&gt;writeStrongBinder(b);
            return NO_ERROR;
        } break;
        case ADD_SERVICE_TRANSACTION: {
            CHECK_INTERFACE(IServiceManager, data, reply);
            String16 which = data.readString16();
            sp&lt;IBinder&gt; b = data.readStrongBinder();
            status_t err = addService(which, b);
            reply-&gt;writeInt32(err);
            return NO_ERROR;
        } break;
        case LIST_SERVICES_TRANSACTION: {
            CHECK_INTERFACE(IServiceManager, data, reply);
            Vector&lt;String16&gt; list = listServices();
            const size_t N = list.size();
            reply-&gt;writeInt32(N);
            for (size_t i=0; i&lt;N; i++) {
                reply-&gt;writeString16(list[i]);
            }
            return NO_ERROR;
        } break;
        default:
            return BBinder::onTransact(code, data, reply, flags);
    }
}
</pre>

<h2 id="toc_1.6">IInterface.h</h2>
<h3 id="toc_1.6.1">DECLARE_META_INTERFACE</h3>
<pre class="brush:c++">
#define DECLARE_META_INTERFACE(INTERFACE)                               \
    static const String16 descriptor;                                   \
    static sp&lt;I##INTERFACE&gt; asInterface(const sp&lt;IBinder&gt;&amp; obj);        \
    virtual const String16&amp; getInterfaceDescriptor() const;             \
    I##INTERFACE();                                                     \
    virtual ~I##INTERFACE(); 
</pre>

<h3 id="toc_1.6.2">IMPLEMENT_META_INTERFACE</h3>
<pre class="brush:c++">
#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \
    const String16 I##INTERFACE::descriptor(NAME);                      \
    const String16&amp; I##INTERFACE::getInterfaceDescriptor() const {      \
        return I##INTERFACE::descriptor;                                \
    }                                                                   \
    sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(const sp&lt;IBinder&gt;&amp; obj)  \
    {                                                                   \
        sp&lt;I##INTERFACE&gt; intr;                                          \
        if (obj != NULL) {                                              \
            intr = static_cast&lt;I##INTERFACE*&gt;(                          \
                obj-&gt;queryLocalInterface(                               \
                        I##INTERFACE::descriptor).get());               \
            if (intr == NULL) {                                         \
                intr = new Bp##INTERFACE(obj);                          \
            }                                                           \
        }                                                               \
        return intr;                                                    \
    }                                                                   \
    I##INTERFACE::I##INTERFACE() { }                                    \
    I##INTERFACE::~I##INTERFACE() { }                                   \
</pre>

<h2 id="toc_1.7">ProcessState.cpp</h2>
<h3 id="toc_1.7.1">getContextObject 方法1</h3>
<pre class="brush:c++">
sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; caller)
{
    if (supportsProcesses()) {
        // 根据0句柄查找ServiceManager
        return getStrongProxyForHandle(0);
    } else {
        return getContextObject(String16("default"), caller);
    }
}
</pre>

<h3 id="toc_1.7.2">getContextObject 方法2</h3>
<pre class="brush:c++">
sp&lt;IBinder&gt; ProcessState::getContextObject(const String16&amp; name, const sp&lt;IBinder&gt;&amp; caller)
{
    mLock.lock();
    sp&lt;IBinder&gt; object(
        mContexts.indexOfKey(name) &gt;= 0 ? mContexts.valueFor(name) : NULL);
    mLock.unlock();
    
    if (object != NULL) return object;

    // Don't attempt to retrieve contexts if we manage them
    if (mManagesContexts) {
        return NULL;
    }
    
    // 取得IPC通信渠道
    IPCThreadState* ipc = IPCThreadState::self();
    {
        // 封装Binder的请求数据
        Parcel data, reply;
        data.writeString16(name);
        data.writeStrongBinder(caller);
        // 向0号引用的ServiceManager发送请求
        status_t result = ipc-&gt;transact(0 /*magic*/, 0, data, &amp;reply, 0);
        if (result == NO_ERROR) {
            object = reply.readStrongBinder();
        }
    }
    
    ipc-&gt;flushCommands();
    
    if (object != NULL) setContextObject(object, name);
    return object;
}
</pre>

<h3 id="toc_1.7.3">getStrongProxyForHandle</h3>
<pre class="brush:c++">
sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)
{
    sp&lt;IBinder&gt; result;

    AutoMutex _l(mLock);

    handle_entry* e = lookupHandleLocked(handle);

    if (e != NULL) {
        // We need to create a new BpBinder if there isn't currently one, OR we
        // are unable to acquire a weak reference on this current one.  See comment
        // in getWeakProxyForHandle() for more info about this.
        IBinder* b = e-&gt;binder;
        if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) {
            b = new BpBinder(handle); 
            e-&gt;binder = b;
            if (b) e-&gt;refs = b-&gt;getWeakRefs();
            result = b;
        } else {
            // This little bit of nastyness is to allow us to add a primary
            // reference to the remote proxy when this team doesn't have one
            // but another team is sending the handle to us.
            result.force_set(b);
            e-&gt;refs-&gt;decWeak(this);
        }
    }

    return result;
}
</pre>

<h2 id="toc_1.8">BpBinder.cpp</h2>
<ul>
<li>
BpBinder构造方法会通过IPCThreadState将自身的引用计数加一。
</li>
<li>
当代理类调用BpBinder的transact()方法时，它会调用IPCThreadState的transact()方法与驱动交互。参见<a href="驱动适配层.html">驱动适配层</a>。
</li>
<li>
ServiceManager是一个特殊的服务，它的服务端实现其实就是进程ServiceManager。因此，当BpServiceManager访问驱动时，进程ServiceManager会处理这些请求。参见<a href="服务端守护进程.html">服务端守护进程</a>。
</li>
</ul>

<h3 id="toc_1.8.1">BpBinder::BpBinder</h3>
<pre class="brush:c++">
BpBinder::BpBinder(int32_t handle)
    : mHandle(handle)
    , mAlive(1)
    , mObitsSent(0)
    , mObituaries(NULL)
{
    extendObjectLifetime(OBJECT_LIFETIME_WEAK);
    // 最终调用IPCThreadState来添加引用计数
    IPCThreadState::self()-&gt;incWeakHandle(handle);
}
</pre>

<h3 id="toc_1.8.2">transact</h3>
<pre class="brush:c++">
status_t BpBinder::transact(
    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)
{
    // Once a binder has died, it will never come back to life.
    if (mAlive) {
        // 最终通过IPCThreadState调用transact()方法
        status_t status = IPCThreadState::self()-&gt;transact(
            mHandle, code, data, reply, flags);
        if (status == DEAD_OBJECT) mAlive = 0;
        return status;
    }

    return DEAD_OBJECT;
}
</pre>

<h2 id="toc_1.9">ServiceManager.h</h2>
<ul>
<li>
BServiceManager继承自BnServiceManager，它是<code>*Service()</code>方法的本地实现，主要是通过KeyedVector&lt;String16, sp&lt;IBinder&gt;&gt;记录服务名与对应的IBinder对象。
</li>
</ul>

<h3 id="toc_1.9.1">BServiceManager</h3>
<pre class="brush:c++">
// BnServiceManager的继承类
class BServiceManager : public BnServiceManager
{
public:
                                BServiceManager();
    
    virtual sp&lt;IBinder&gt;         getService( const String16&amp; name) const;
    virtual sp&lt;IBinder&gt;         checkService( const String16&amp; name) const;
    virtual status_t            addService( const String16&amp; name,
                                            const sp&lt;IBinder&gt;&amp; service);
    virtual Vector&lt;String16&gt;    listServices();

    
private:
    mutable Mutex               mLock;
    mutable Condition           mChanged;
    sp&lt;IPermissionController&gt;   mPermissionController;
    KeyedVector&lt;String16, sp&lt;IBinder&gt; &gt; mServices;
};
</pre>

<h2 id="toc_1.10">ServiceManager.cpp</h2>
<h3 id="toc_1.10.1">BServiceManager</h3>
<pre class="brush:c++">
// 真正的IServiceManager接口方法实现
BServiceManager::BServiceManager()
{
}

sp&lt;IBinder&gt; BServiceManager::getService(const String16&amp; name) const
{
    AutoMutex _l(mLock);
    ssize_t i = mServices.indexOfKey(name);
    if (i &gt;= 0) return mServices.valueAt(i);
    return NULL;
}

sp&lt;IBinder&gt; BServiceManager::checkService(const String16&amp; name) const
{
    AutoMutex _l(mLock);
    ssize_t i = mServices.indexOfKey(name);
    if (i &gt;= 0) return mServices.valueAt(i);
    return NULL;
}

status_t BServiceManager::addService(const String16&amp; name, const sp&lt;IBinder&gt;&amp; service)
{
    AutoMutex _l(mLock);
    const ssize_t res = mServices.add(name, service);
    if (res &gt;= NO_ERROR) {
        mChanged.broadcast();
        return NO_ERROR;
    }
    return res;
}

Vector&lt;String16&gt; BServiceManager::listServices()
{
    Vector&lt;String16&gt; res;

    AutoMutex _l(mLock);
    const size_t N = mServices.size();
    for (size_t i=0; i&lt;N; i++) {
        res.add(mServices.keyAt(i));
    }

    return res;
}
</pre>
<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

<!--<script type="text/javascript">-->
<!--var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");-->
<!--document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));-->
<!--</script>-->
<!--<script type="text/javascript">-->
<!--try {-->
<!--var pageTracker = _gat._getTracker("UA-15922433-1");-->
<!--pageTracker._trackPageview();-->
<!--} catch(err) {}-->
<!--</script>-->

</body>
</html>
