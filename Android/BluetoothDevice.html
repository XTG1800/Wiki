<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>BluetoothDevice</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <link rel="Stylesheet" type="text/css" href="../css_style/style_zenki.css">

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>

<!-- wrap the vimwiki html -->

<h1 id="toc_1">BluetoothDevice</h1>

<h2 id="toc_1.1">功能描述</h2>
<pre class="brush:text">
    该类是一个远程蓝牙设备。我们可以创建一个带有各自设备的BluetoothDevice或者查询其皆如名称、地址、类和连接状态等信息。
对于蓝牙硬件地址而言，这个类仅仅是一个包装器。这个类的对象是不可改变的。这个类上的操作会使用这个用来创建BluetoothDevice类的 
BluetoothAdapter类执行在远程蓝牙硬件上。为了获得BluetoothDevice类，我们可以使用BluetoothAdapter.getRemoteDevice(String)
方法去创建一个指定MAC地址的设备（用户可以通过带有 BluetoothAdapter类来完成对设备的查找）或者从一个通过
BluetoothAdapter.getBondedDevices()得到返回值的有联系的设备集合来得到该设备。注意：使用该类需要加入BLUETOOTH权限。
</pre>

<h2 id="toc_1.2">相关方法说明</h2>
<h3 id="toc_1.2.1">常量说明</h3>
<table>
<tr>
<th>
类型
</th>
<th>
名称
</th>
<th>
描述
</th>
</tr>
<tr>
<td>
String
</td>
<td>
ACTION_ACL_CONNECTED
</td>
<td>
广播活动：指明一个与远程设备建立的低级别（ACL）连接。
</td>
</tr>
<tr>
<td>
String
</td>
<td>
ACTION_ACL_DISCONNECTED
</td>
<td>
广播活动：指明一个来自于远程设备的低级别（ACL）连接的断开。
</td>
</tr>
<tr>
<td>
String
</td>
<td>
ACTION_ACL_DISCONNECT_REQUESTED
</td>
<td>
广播活动：指明一个为远程设备提出的低级别（ACL）的断开连接请求，并即将断开连接。
</td>
</tr>
<tr>
<td>
String
</td>
<td>
ACTION_BOND_STATE_CHANGED
</td>
<td>
广播活动：指明一个远程设备的连接状态的改变。
</td>
</tr>
<tr>
<td>
String
</td>
<td>
ACTION_CLASS_CHANGED
</td>
<td>
广播活动：一个已经改变的远程设备的蓝牙类。
</td>
</tr>
<tr>
<td>
String
</td>
<td>
ACTION_FOUND
</td>
<td>
广播活动：发现远程设备。
</td>
</tr>
<tr>
<td>
String
</td>
<td>
ACTION_NAME_CHANGED
</td>
<td>
广播活动：指明一个远程设备的名称第一次找到，或者自从最后一次找到该名称开始已经改变。
</td>
</tr>
<tr>
<td>
int
</td>
<td>
BOND_BONDED
</td>
<td>
表明远程设备已经匹配。
</td>
</tr>
<tr>
<td>
int
</td>
<td>
BOND_BONDING
</td>
<td>
表明和远程设备的匹配正在进行中。
</td>
</tr>
<tr>
<td>
int
</td>
<td>
BOND_NONE
</td>
<td>
表明远程设备并未匹配。
</td>
</tr>
<tr>
<td>
int
</td>
<td>
ERROR
</td>
<td>
错误信息。
</td>
</tr>
<tr>
<td>
String
</td>
<td>
EXTRA_BOND_STATE
</td>
<td>
作为一个ACTION_BOND_STATE_CHANGED的整型附加域。
</td>
</tr>
<tr>
<td>
String
</td>
<td>
EXTRA_CLASS
</td>
<td>
作为一个ACTION_FOUND and和ACTION_CLASS_CHANGED的Parcelabe BluetoothClass附加域。
</td>
</tr>
<tr>
<td>
String
</td>
<td>
EXTRA_DEVICE
</td>
<td>
每次通过该类进行广播时，作为Parcelable BluetoothDevice的附加域。
</td>
</tr>
<tr>
<td>
String
</td>
<td>
EXTRA_NAME
</td>
<td>
作为ACTION_NAME_CHANGED和ACTION_FOUND的字符串附加域。
</td>
</tr>
<tr>
<td>
String
</td>
<td>
EXTRA_PREVIOUS_BOND_STATE
</td>
<td>
作为ACTION_BOND_STATE_CHANGED的整型附加域。
</td>
</tr>
<tr>
<td>
String
</td>
<td>
EXTRA_RSSI
</td>
<td>
作为ACTION_FOUND的可选短整型附加域。
</td>
</tr>
</table>

<h3 id="toc_1.2.2">方法说明</h3>
<table>
<tr>
<th>
类型
</th>
<th>
名称
</th>
<th>
描述
</th>
</tr>
<tr>
<td>
BluetoothSocket
</td>
<td>
createRfcommSocketToServiceRecord(UUID uuid)
</td>
<td>
创建一个RFCOMM 以准备开始一个对使用uuid的SDP查找的远程设备进行安全而连接。
</td>
</tr>
<tr>
<td>
int
</td>
<td>
describeContents()
</td>
<td>
描述了包含在Parcelable's marshalled representation中的特殊对象的种类。
</td>
</tr>
<tr>
<td>
String
</td>
<td>
getAddress()
</td>
<td>
返回该蓝牙设备的硬件地址。
</td>
</tr>
<tr>
<td>
BluetoothClass
</td>
<td>
getBluetoothClass()
</td>
<td>
获得远程设备的蓝牙类。
</td>
</tr>
<tr>
<td>
int
</td>
<td>
getBondState()
</td>
<td>
获得远程设备的连接状态
</td>
</tr>
<tr>
<td>
String
</td>
<td>
getName()
</td>
<td>
获得远程蓝牙设备的名称
</td>
</tr>
</table>
<blockquote>
注意：toSting()函数会返回该蓝牙设备的字符串表达式。当我们在取得蓝牙地址时，一般会得到一个类似于"00:11:22:AA:BB:CC" 的字符串，
如果用户明确需要蓝牙硬件地址以防以后toString()表达式会改变的话，用户总是需要使用getAddress()方法来获取蓝牙的地址。
getName()函数也只获取远程蓝牙设备的名称，当执行设备扫描的时候，本地适配器将自动寻找远程名称。该方法只返回来自存储器中该设备的名称。
该类中大多数方法的使用都需要获得BLUETOOTH权限。
</blockquote>


<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

</body>
</html>
