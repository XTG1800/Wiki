<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>jni使用范例</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
	<link type="text/css" rel="stylesheet" href="css_style/style_zenki.css"/>

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>


<h1 id="toc_1">jni使用范例</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">jni使用范例</a></li>
<ul>
<li><a href="#toc_1.1">数据类型定义</a></li>
<ul>
<li><a href="#toc_1.1.1">基本数据类型</a></li>
<li><a href="#toc_1.1.2">引用数据类型</a></li>
</ul>
<li><a href="#toc_1.2">函数类型签名的使用</a></li>
<li><a href="#toc_1.3">方法的注册和加载</a></li>
<ul>
<li><a href="#toc_1.3.1">方法表的定义</a></li>
<li><a href="#toc_1.3.2">方法表的注册</a></li>
<li><a href="#toc_1.3.3">虚拟机在加载时注册方法表</a></li>
</ul>
<li><a href="#toc_1.4">使用范例</a></li>
<ul>
<li><a href="#toc_1.4.1">Java对象和成员的操作</a></li>
<li><a href="#toc_1.4.2">Java类方法调用</a></li>
<li><a href="#toc_1.4.3">创建和释放Java对象的引用</a></li>
<li><a href="#toc_1.4.4">解析Java参数</a></li>
<li><a href="#toc_1.4.5">给Java传递返回值</a></li>
<li><a href="#toc_1.4.6">JNI层的异常处理</a></li>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">数据类型定义</h2>
<h3 id="toc_1.1.1">基本数据类型</h3>
<table>
<tr>
<th>Java</th>
<th>C</th>
<th>符号类型</th>
<th>字节</th>
<th>对应签名字母</th>
</tr>
<tr>
<td>boolean</td>
<td>jboolean</td>
<td>无符号</td>
<td>8  位</td>
<td>Z</td>
</tr>
<tr>
<td>byte</td>
<td>jbyte</td>
<td>无符号</td>
<td>8  位</td>
<td>B</td>
</tr>
<tr>
<td>char</td>
<td>jchar</td>
<td>无符号</td>
<td>16  位</td>
<td>C</td>
</tr>
<tr>
<td>short</td>
<td>jshort</td>
<td>有符号</td>
<td>16  位</td>
<td>S</td>
</tr>
<tr>
<td>int</td>
<td>jint</td>
<td>有符号</td>
<td>32  位</td>
<td>I</td>
</tr>
<tr>
<td>long</td>
<td>jlong</td>
<td>有符号</td>
<td>64  位</td>
<td>J</td>
</tr>
<tr>
<td>float</td>
<td>jfloat</td>
<td>有符号</td>
<td>32  位</td>
<td>F</td>
</tr>
<tr>
<td>double</td>
<td>jdouble</td>
<td>有符号</td>
<td>64  位</td>
<td>D</td>
</tr>
<tr>
<td>无返回值</td>
<td>void</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>V</td>
</tr>
</table>

<h3 id="toc_1.1.2">引用数据类型</h3>
<table>
<tr>
<th>Java</th>
<th>C</th>
<th>符号类型</th>
<th>字节</th>
<th>对应签名字母</th>
</tr>
<tr>
<td>all objects</td>
<td>jobjects</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>L/java/lang/object;</td>
</tr>
<tr>
<td>java.lang.Class</td>
<td>jcalss</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>L/java/lang/Class</td>
</tr>
<tr>
<td>java.lang.String</td>
<td>jstring</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>L/java/lang/String</td>
</tr>
<tr>
<td>Object[]</td>
<td>jobjectArray</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>[L/java/lang/Object;</td>
</tr>
<tr>
<td>boolean[]</td>
<td>jbooleanArray</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>[Z</td>
</tr>
<tr>
<td>byte[]</td>
<td>jbyteArray</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>[B</td>
</tr>
<tr>
<td>java.lang.Throwable</td>
<td>jthrowable</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>L/java/lang/Throwable</td>
</tr>
<tr>
<td>char[]</td>
<td>jcharArray</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>[C</td>
</tr>
<tr>
<td>short[]</td>
<td>jshortArray</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>[S</td>
</tr>
<tr>
<td>int[]</td>
<td>jintArray</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>[I</td>
</tr>
<tr>
<td>long[]</td>
<td>jlongArray</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>[J</td>
</tr>
<tr>
<td>float[]</td>
<td>jfloatArray</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>[F</td>
</tr>
<tr>
<td>double[]</td>
<td>jdoubleArray</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>[D</td>
</tr>
</table>

<h2 id="toc_1.2">函数类型签名的使用</h2>
<ul>
<li>
函数类型签名可用来查询数据类型定义表，解决方法的重载问题。格式为<code>(参数类型)返回类型</code>，括号内为参数类型，括号外为返回值类型，数组类型以<code>[</code>开头，如“(I[B)Z”。其中如果是Java对象类型，则需要以<code>L类名;</code>的形式标识，类名是以<code>/</code>分隔的完整包-类名称，如“Ljava/lang/String;”。如果是内部类，则以<code>L类名$内部类名;</code>形式标识，如“Landroid/os/FileUtils$FileStatus;”。
</li>
<li>
使用javap工具可帮助生产函数或变量的签名信息。
</li>
</ul>

<pre class="brush:bash">
$ javap -s -p demo.class
</pre>

<p>
函数签名示例
<table>
<tr>
<th>函数签名</th>
<th>Java函数定义</th>
</tr>
<tr>
<td>"()Ljava/lang/String"</td>
<td>String()</td>
</tr>
<tr>
<td>"(ILjava/lang/Class)J"</td>
<td>long f(int i, Class c)</td>
</tr>
<tr>
<td>"([B)V"</td>
<td>void f(Byte[] byte)</td>
</tr>
</table>
</p>

<h2 id="toc_1.3">方法的注册和加载</h2>
<h3 id="toc_1.3.1">方法表的定义</h3>
<ul>
<li>
方法表数组成员分别为<code>注册的方法名</code>、<code>类型签名</code>、<code>本地函数指针</code>。
</li>
<ul>
<li>
注册的方法名是提供给Java层调用的方法。
</li>
<li>
本地函数指针是对应注册的方法名的C/C++函数指针。
</li>
</ul>
</ul>

<pre class="brush:c">
static const JNINativeMethod gMethods[] = {
    // 无参数，返回值为boolean
    {"_init", "()Z", (void*)mokoid_init},
    // 参数为int，返回值为boolean
    { "_set_on", "(I)Z", (void*)mokoid_setOn },
    // 参数为jbyte数组，返回值为long 
    { "_set_on", "([B)J", (void*)mokoid_setOn },
    // 第一个参数为String，第二个参数为Parcel，返回值为Canvas
    { "_func2", "(Ljava/lang/String;Landroid/os/Parcel)Landroid/graphics/Canvas;", 
        (void*)func2 },
};
</pre>

<h3 id="toc_1.3.2">方法表的注册</h3>
<ul>
<li>
参数env表示Java虚拟机环境指针。
</li>
<li>
kClassName变量指定了为哪个类注册JNI方法。
</li>
<li>
env-&gt;RegisterNatives方法用来注册JNI的方法表。
</li>
</ul>

<pre class="brush:c">
int registerMethods(JNIEnv* env) {
    // 指定类名称
    static const char* const kClassName = "com/mokoid/server/LedService";
    jclass clazz;

    // 查找指定类
    clazz = env-&gt;FindClass(kClassName);
    if (clazz == NULL) {
        return -1;
    }

    // 将方法列表注册给指定的类
    if (env-&gt;RegisterNatives(clazz, gMethods,
            sizeof(gMethods) / sizeof(gMethods[0])) != JNI_OK) {
        return -1;
    }

    return 0;
}
</pre>

<h3 id="toc_1.3.3">虚拟机在加载时注册方法表</h3>
<ul>
<li>
JNI_OnLoad是Java加载so的入口方法，可以在该方法中调用注册方法表的函数。
</li>
<li>
该方法的vm参数表示Java虚拟机，vm-&gt;GetEnv方法可以初始化环境指针env，并可检查JNI的版本信息。
</li>
</ul>

<pre class="brush:c">
jint JNI_OnLoad(JavaVM* vm, void* reserved) {
    JNIEnv* env = NULL;
    jint result = -1;

    if (vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) {
	    goto bail;
    }
    assert(env != NULL);

    // 调用注册方法表
    registerMethods(env);
    // 调用其他注册函数
    registerMethods2(env);
    registerMethods3(env);

    /* success -- return valid version number */
    result = JNI_VERSION_1_4;

bail:
    return result;
}
</pre>

<h2 id="toc_1.4">使用范例</h2>
<h3 id="toc_1.4.1">Java对象和成员的操作</h3>
<pre class="brush:c">
jobject Java_setLineBreaksForCharArray(JNIEnv *env, 
                                     jobject thiz, 
                                     jcharArray data, 
                                     jint offset, 
                                     jint length, 
                                     jstring lang, 
                                     jbyteArray breaks) {
    // 获取Java类
    jclass cls;
    cls = env-&gt;GetObjectClass(thiz);
    cls = env-&gt;FindClass("com/foxconn/example/reader");
    
    // 获取Java对象
    jobject obj;
    obj = env-&gt;GetObjectField(thiz, reader);
    
    // 获取类并通过构造函数生成的新对象, &lt;init&gt;为构造函数, V为返回值类型签名, I为参数类型签名
    jmethodID constr;
    jobject newObj;
    jclass clazz = env-&gt;FindClass("com/misoo/thread/myData");
    constr = env-&gt;GetMethodID(clazz, "&lt;init&gt;", "(I)V");
    newObj = env-&gt;NewObject(clazz, constr);
    
    // 获取java对象成员的ID标识
    // 第一个参数：jclass对象
    // 第二个参数：成员变量名
    // 第三个参数：变量类型
    jfieldID fid;
    fid = env-&gt;GetFieldID(cls, "retbytes", "[B"]);
    
    // 给该ID标识的变量赋值
    // 第一个参数：jobject对象
    // 第二个参数：变量的ID标识
    // 第三个参数：赋予的变量值
    env-&gt;SetObjectField(obj, fid, bytearray);
    
    return newObj;
</pre>

<h3 id="toc_1.4.2">Java类方法调用</h3>
<pre class="brush:c">
void Java_setLineBreaksForCharArray(JNIEnv *env, 
                                 jobject thiz, 
                                 jcharArray data, 
                                 jint offset, 
                                 jint length, 
                                 jstring lang, 
                                 jbyteArray breaks) {
    // 获取对象方法ID
    // 第一个参数：jclass对象
    // 第二个参数：方法名
    // 第三个参数：(I)V，参数和返回类型签名                                                                     
    int mid = GetMethodID(clazz, "getD1", "(I)V");
    if(mid == 0) {
        return;
    }
    // 调用对象的方法
    // 第一个参数：jobject对象
    // 第二个参数：方法ID
    // 后面可跟方法的参数列表
    env-&gt;CallVoidMethod(jobj, mid, ...);

    // 获取静态方法ID
    // 第一个参数：jclass对象
    // 第二个参数：方法名 
    // 第三个参数：()I，参数和返回值类型签名
    int mid = env-&gt;GetStaticMethodID(clazz, "getD2", "()I");
    if(mid == 0) {
        return;
    }
    // 调用静态方法
    // 第一个参数：jobject对象
    // 第二个参数：方法ID
    // 后面可跟方法的参数列表
    int a = env-&gt;CallStaticIntMethod(clazz, mid, ...);
</pre>

<h3 id="toc_1.4.3">创建和释放Java对象的引用</h3>
<ul>
<li>
本地引用：JNI层函数使用的非全局引用对象，一旦JNI层函数返回，这些对象可能被垃圾回收。
</li>
<li>
全局引用：这种对象除非被主动释放，否则不会被垃圾回收。
</li>
<li>
弱全局引用：在运行过程中可能被回收。因此在使用时需要做判断。
</li>
</ul>

<pre class="brush:c">
void Java_setLineBreaksForCharArray(JNIEnv *env, 
                                 jobject thiz, 
                                 jcharArray data, 
                                 jint offset, 
                                 jint length, 
                                 jstring lang, 
                                 jbyteArray breaks) {
    jobject jref;
    
    // 创建一个全局引用
    jref = env-&gt;NewGlobalRef(thiz);
    if(jref == null) {
        return;
    }
    // 释放一个全局引用
    env-&gt;DeleteGlobalRef(jref);
    
    // 创建一个本地引用
    jref = env-&gt;NewLocalRef(thiz);
    if(jref == null) {
        return;
    }
    // 释放一个本地引用
    env-&gt;DeleteLocalRef(jref);
    
    // 创建一个弱全局引用
    jref = env-&gt;NewWeakGlobalRef(thiz);
    if(jref == null) {
        return;
    }
    // 判断弱全局引用是否被垃圾回收
    if (!env-&gt;IsSameObject(jref, thiz)) {
        return;
    }
    // 释放一个弱全局引用
    env-&gt;DeleteWeakGlobalRef(jref);
</pre>

<h3 id="toc_1.4.4">解析Java参数</h3>
<pre class="brush:c">
void Java_setLineBreaksForCharArray(JNIEnv *env, 
                                 jobject thiz, 
                                 jcharArray data, 
                                 jint offset, 
                                 jint length, 
                                 jstring lang, 
                                 jbyteArray breaks) {
    // 转换Java的char数组类型, 用完后释放内存
    jchar* dataArray = env-&gt;GetCharArrayElements(data, 0);
    env-&gt;ReleaseCharArrayElements(data, dataArray, 0);
	
    // 转换Java的byte数组类型, 用完后释放内存
    jbyte* breaksArray = env-&gt;GetByteArrayElements(breaks, 0);
    env-&gt;ReleaseByteArrayElements(breaks, breaksArray, 0);
	
    // 转换Java的string类型, 用完后释放内存
    const char *langArray = (lang != 0) ? env-&gt;GetStringUTFChars(lang, 0) : 0;
    if (lang != 0) {
        env-&gt;ReleaseStringUTFChars(lang, langArray);
    }

    // 将转换后的类型可与C类型兼容
    set_linebreaks_utf16(dataArray + offset, length, langArray, (char*)breaksArray);

</pre>

<h3 id="toc_1.4.5">给Java传递返回值</h3>
<pre class="brush:c">
jstring Java_setLineBreaksForCharArray(JNIEnv *env, 
                                     jobject thiz, 
                                     jcharArray data, 
                                     jint offset, 
                                     jint length, 
                                     jstring lang, 
                                     jbyteArray breaks) {
    // 创建字节数组类型，并拷贝buffer内容
    jbyteArray bytearray; 
    bytearray = env-&gt;NewByteArray(len);
    env-&gt;SetByteArrayRegion(bytearray, 0, len, buffer);
    
    return bytearray;
    
    // 创建string类型变量并返回给java
    char charStr[50];
    jstring jstr;
    jstr = env -&gt; NewStringUTF(charStr);
    
    return jstr;
}
</pre>

<h3 id="toc_1.4.6">JNI层的异常处理</h3>
<pre class="brush:c">
jstring Java_setLineBreaksForCharArray(JNIEnv *env, 
                                     jobject thiz, 
                                     jcharArray data, 
                                     jint offset, 
                                     jint length, 
                                     jstring lang, 
                                     jbyteArray breaks) {
    jbyteArray bytearray; 
    bytearray = env-&gt;NewByteArray(len);
    const char* const kClassName = "com/mokoid/server/LedService";
    jclass clazz;
    clazz = env-&gt;FindClass(kClassName);

    // 获取当前的异常对象
    jthrowable jthrow = ExceptionOccurred();
    if (jthrow != null) {
        // 抛出异常
        Throw(jthrow);
        ThrowNew(clazz, "send exception message to java");
    }
    
    // 清除异常
    ExceptionClear();
    
    return bytearray;
}
</pre>
<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

<!--<script type="text/javascript">-->
<!--var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");-->
<!--document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));-->
<!--</script>-->
<!--<script type="text/javascript">-->
<!--try {-->
<!--var pageTracker = _gat._getTracker("UA-15922433-1");-->
<!--pageTracker._trackPageview();-->
<!--} catch(err) {}-->
<!--</script>-->

</body>
</html>
