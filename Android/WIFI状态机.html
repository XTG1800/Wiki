<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>WIFI状态机</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
	<link type="text/css" rel="stylesheet" href="css_style/style_zenki.css"/>

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>


<h1 id="toc_1">WIFI状态机</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">WIFI状态机</a></li>
<ul>
<li><a href="#toc_1.1">相关文件</a></li>
<li><a href="#toc_1.2">概述</a></li>
<li><a href="#toc_1.3">WifiStateMachine初始化</a></li>
<li><a href="#toc_1.4">状态机的命令集</a></li>
<ul>
<li><a href="#toc_1.4.1">关于驱动的命令</a></li>
<li><a href="#toc_1.4.2">启停wpa_supplicant的命令</a></li>
<li><a href="#toc_1.4.3">wpa_supplicant功能命令</a></li>
<li><a href="#toc_1.4.4">关于热点的命令</a></li>
<li><a href="#toc_1.4.5">关于性能的命令</a></li>
<li><a href="#toc_1.4.6">关于P2P的命令</a></li>
<li><a href="#toc_1.4.7">其他命令</a></li>
</ul>
<li><a href="#toc_1.5">Wifi状态对象图</a></li>
<li><a href="#toc_1.6">监听wpa_supplicant</a></li>
<ul>
<li><a href="#toc_1.6.1">启动WifiMonitor工作线程</a></li>
</ul>
<li><a href="#toc_1.7">热点配置管理类</a></li>
<ul>
<li><a href="#toc_1.7.1">热点状态对象初始化</a></li>
<li><a href="#toc_1.7.2">配置文件的路径</a></li>
<li><a href="#toc_1.7.3">读取配置文件</a></li>
<li><a href="#toc_1.7.4">写入配置文件</a></li>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">相关文件</h2>
<pre class="brush:text">
framework/base/wifi/java/com/android/net/wifi/WifiStateMachine.java
framework/base/wifi/java/com/android/net/wifi/WifiMonitor.java
framework/base/wifi/java/com/android/net/wifi/WifiApConfigStore.java
framework/base/wifi/java/com/android/net/wifi/SupplicantStateTracker.java
framework/base/wifi/java/com/android/net/wifi/WpsStateMachine.java
frameworks/base/core/java/android/net/DhcpInfoInternal.java

frameworks/base/core/java/com/android/internal/util/StateMachine.java
frameworks/base/core/java/com/android/internal/util/LruCache.java
</pre>

<h2 id="toc_1.2">概述</h2>
<pre class="brush:text">
    Wifi状态机是4.0新增的机制，之前版本的Wifi状态在WifiStateTracker中处理。
Wifi状态机的实现类为WifiStateMachine，它继承于StateMachine。该类实现了比较
复杂的功能，主要包括记录网络连接属性和状态、监听wpa_supplicant的消息、处理DHCP信息、
管理WPS连接、接收并处理扫描网络的广播消息、记录扫描到的热点信息等等。
</pre>

<h2 id="toc_1.3">WifiStateMachine初始化</h2>
<ul>
<li>
该类继承自StateMachine，关于状态机的实现可参照<a href="状态机机制.html">状态机机制</a>
</li>
<li>
状态机接收来自wpa_supplicant的消息，该功能由WifiMonitor实现。
</li>
<li>
通过WpsStateMachine管理WPS连接。
</li>
<li>
通过WifiApConfigStore管理AP。
</li>
<li>
通过TetheringState处理路由功能。
</li>
<li>
扫描热点。
</li>
</ul>

<pre class="brush:java">
public WifiStateMachine(Context context, String wlanInterface) {
    super(TAG);

    mContext = context;
    mInterfaceName = wlanInterface;

    mNetworkInfo = new NetworkInfo(ConnectivityManager.TYPE_WIFI, 0, NETWORKTYPE, "");
    mBatteryStats = IBatteryStats.Stub.asInterface(ServiceManager.getService("batteryinfo"));

    IBinder b = ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
    mNwService = INetworkManagementService.Stub.asInterface(b);

    mWifiMonitor = new WifiMonitor(this);
    mDhcpInfoInternal = new DhcpInfoInternal();
    mWifiInfo = new WifiInfo();
    mSupplicantStateTracker = new SupplicantStateTracker(context, this, getHandler());
    mWpsStateMachine = new WpsStateMachine(context, this, getHandler());
    mLinkProperties = new LinkProperties();

    // 初始化WifiApConfigStore对象
    WifiApConfigStore wifiApConfigStore = WifiApConfigStore.makeWifiApConfigStore(
            context, getHandler());
    wifiApConfigStore.loadApConfiguration();
    mWifiApConfigChannel.connectSync(mContext, getHandler(), wifiApConfigStore.getMessenger());

    // ......
    mAlarmManager = (AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE);
    Intent scanIntent = new Intent(ACTION_START_SCAN, null);
    mScanIntent = PendingIntent.getBroadcast(mContext, SCAN_REQUEST, scanIntent, 0);

    mDefaultFrameworkScanIntervalMs = mContext.getResources().getInteger(
            com.android.internal.R.integer.config_wifi_framework_scan_interval);

    mDefaultSupplicantScanIntervalMs = mContext.getResources().getInteger(
            com.android.internal.R.integer.config_wifi_supplicant_scan_interval);

    // 注册BroadcastReceiver
    // ......

    mScanResultCache = new LruCache&lt;String, ScanResult&gt;(SCAN_RESULT_CACHE_SIZE);

    PowerManager powerManager = (PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
    mWakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);

    // 添加状态对象
    // ......
    
    setInitialState(mInitialState);
    start();
}
</pre>

<h2 id="toc_1.4">状态机的命令集</h2>
<ul>
<li>
状态机对象向外界提供了功能接口，而这些接口在状态机机制的内部则是对应一个整形的命令。
</li>
<li>
状态机通常会运行在一个闭合的循环里面处理这些命令，从而在不同状态下实现不同的功能。
</li>
<li>
可通过查找这些命令关键字来查看各种功能的实现。
</li>
</ul>

<h3 id="toc_1.4.1">关于驱动的命令</h3>
<table>
<tr>
<th>命令表示</th>
<th>描述</th>
<th>备注</th>
</tr>
<tr>
<td>CMD_LOAD_DRIVER</td>
<td>加载驱动</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_UNLOAD_DRIVER</td>
<td>卸载驱动</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_LOAD_DRIVER_SUCCESS</td>
<td>加载驱动成功</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_LOAD_DRIVER_FAILURE</td>
<td>加载驱动失败</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_UNLOAD_DRIVER_SUCCESS</td>
<td>卸载驱动成功</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_UNLOAD_DRIVER_FAILURE</td>
<td>卸载驱动失败</td>
<td>&nbsp;</td>
</tr>
</table>

<h3 id="toc_1.4.2">启停wpa_supplicant的命令</h3>
<table>
<tr>
<th>命令表示</th>
<th>描述</th>
<th>备注</th>
</tr>
<tr>
<td>CMD_START_SUPPLICANT</td>
<td>开启wpa_supplicant服务</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_STOP_SUPPLICANT</td>
<td>停止wpa_supplicant服务</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_START_DRIVER</td>
<td>启用驱动程序</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_STOP_DRIVER</td>
<td>禁用驱动程序</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_STATIC_IP_SUCCESS</td>
<td>设置静态IP成功</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_STATIC_IP_FAILURE</td>
<td>设置静态IP失败</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_STOP_SUPPLICANT_FAILED</td>
<td>停止wpa_supplicant服务失败</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_DELAYED_STOP_DRIVER</td>
<td>延迟停止驱动程序</td>
<td>&nbsp;</td>
</tr>
</table>

<h3 id="toc_1.4.3">wpa_supplicant功能命令</h3>
<table>
<tr>
<th>命令表示</th>
<th>描述</th>
<th>备注</th>
</tr>
<tr>
<td>CMD_PING_SUPPLICANT</td>
<td>探测wpa_supplicant服务是否存在</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_ADD_OR_UPDATE_NETWORK</td>
<td>添加获取更新网络节点</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_REMOVE_NETWORK</td>
<td>移除网络节点</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_ENABLE_NETWORK</td>
<td>启用网络节点</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_ENABLE_ALL_NETWORKS</td>
<td>启用所有网络节点</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_DISABLE_NETWORK</td>
<td>禁用所有网络节点</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_BLACKLIST_NETWORK</td>
<td>设置网络节点黑名单</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_CLEAR_BLACKLIST</td>
<td>清除网络节点黑名单</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_SAVE_CONFIG</td>
<td>保存网络设置</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_START_SCAN</td>
<td>开始扫描</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_SET_SCAN_MODE</td>
<td>设置扫描模式</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_SET_SCAN_TYPE</td>
<td>设置扫描类型</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_DISCONNECT</td>
<td>断开网络连接</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_RECONNECT</td>
<td>重新连接网络</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_REASSOCIATE</td>
<td>重新关联到一个网络节点</td>
<td>&nbsp;</td>
</tr>
</table>

<h3 id="toc_1.4.4">关于热点的命令</h3>
<table>
<tr>
<th>命令表示</th>
<th>描述</th>
<th>备注</th>
</tr>
<tr>
<td>CMD_START_AP</td>
<td>开启热点</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_START_AP_SUCCESS</td>
<td>开启热点成功</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_START_AP_FAILURE</td>
<td>开启热点失败</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_STOP_AP</td>
<td>停止热点</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_SET_AP_CONFIG</td>
<td>配置热点</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_SET_AP_CONFIG_COMPLETED</td>
<td>配置热点完成</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_REQUEST_AP_CONFIG</td>
<td>请求热点配置</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_RESPONSE_AP_CONFIG</td>
<td>应答热点配置</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_TETHER_STATE_CHANGE</td>
<td>路由状态改变</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_TETHER_NOTIFICATION_TIMED_OUT</td>
<td>路由通知超时</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_BLUETOOTH_ADAPTER_STATE_CHANGE</td>
<td>蓝牙适配器状态改变</td>
<td>&nbsp;</td>
</tr>
</table>

<h3 id="toc_1.4.5">关于性能的命令</h3>
<table>
<tr>
<th>命令表示</th>
<th>描述</th>
<th>备注</th>
</tr>
<tr>
<td>CMD_SET_HIGH_PERF_MODE</td>
<td>设置高性能模式，禁用休眠优化方案。休眠优化方案包括：包过滤、关闭漫游、DTIM唤醒设定</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_SET_COUNTRY_CODE</td>
<td>设置国家代码</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_ENABLE_RSSI_POLL</td>
<td>启用RSSI(Received Signal Strength Indication)接收强度指标</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_RSSI_POLL</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_START_PACKET_FILTERING</td>
<td>开启包过滤功能</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_STOP_PACKET_FILTERING</td>
<td>停止包过滤功能</td>
<td>&nbsp;</td>
</tr>
</table>

<h3 id="toc_1.4.6">关于P2P的命令</h3>
<table>
<tr>
<th>命令表示</th>
<th>描述</th>
<th>备注</th>
</tr>
<tr>
<td>WIFI_ENABLE_PENDING</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>P2P_ENABLE_PROCEED</td>
<td>启用P2P</td>
<td>&nbsp;</td>
</tr>
</table>

<h3 id="toc_1.4.7">其他命令</h3>
<table>
<tr>
<th>命令表示</th>
<th>描述</th>
<th>备注</th>
</tr>
<tr>
<td>CMD_CONNECT_NETWORK</td>
<td>连接到一个网络节点</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_SAVE_NETWORK</td>
<td>保存一个网络节点</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_FORGET_NETWORK</td>
<td>丢弃一个网络节点</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_START_WPS</td>
<td>开启WPS安全连接</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_SET_FREQUENCY_BAND</td>
<td>设置带宽频率</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_ENABLE_BACKGROUND_SCAN</td>
<td>开启后台扫描</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_RESET_SUPPLICANT_STATE</td>
<td>重置wpa_supplicant状态</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>WPS_COMPLETED_EVENT</td>
<td>WPS连接已完成</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>CMD_RESET_WPS_STATE</td>
<td>重置WPS连接状态</td>
<td>&nbsp;</td>
</tr>
</table>

<h2 id="toc_1.5">Wifi状态对象图</h2>
<ul>
<li>
状态机<code>(StateMachine)</code>的实现由各种状态对象<code>(State)</code>组合而成，并通过各种命令<code>(CMD_*)</code>进行状态间的跳转。
</li>
<li>
而状态对象在各自的状态下对同一个命令进行不同的处理，并且由于当前状态不同，跳转到的目标状态也有所差异。
</li>
<li>
当我们需要分析一条命令的功能时，必须明确当前处于什么状态，<code>并在该状态下查看该命令的实现代码</code>。
</li>
</ul>

<p>
<a href="pic/WifiStateMachine.png"><img src="pic/WifiStateMachine.png" /></a>
</p>

<h2 id="toc_1.6">监听wpa_supplicant</h2>
<ul>
<li>
WifiMonitor是用来监听wpa_supplicant服务端消息的类，它在启动wpa_supplicant时会启动该类关联的工作线程。
</li>
<li>
<a href="WifiMonitor实现.html">WifiMonitor实现</a>
</li>
</ul>

<h3 id="toc_1.6.1">启动WifiMonitor工作线程</h3>
<pre class="brush:java">
class DriverLoadedState extends State {
    // ...... 
    @Override
    public boolean processMessage(Message message) {
        switch(message.what) {
            // ......
            case CMD_START_SUPPLICANT:
                // ......
                if(WifiNative.startSupplicant()) {
                    mWifiMonitor.startMonitoring();
                    transitionTo(mSupplicantStartingState);
                } else {
                    sendMessage(obtainMessage(CMD_UNLOAD_DRIVER, WIFI_STATE_UNKNOWN, 0));
                }
                break;
            // ......
        }
        return HANDLED;
    }
}
</pre>

<h2 id="toc_1.7">热点配置管理类</h2>
<ul>
<li>
Wifi热点配置通过<code>WifiApConfigStore</code>类完成，该类继承于StateMachine，同时也充当一个状态对象。
</li>
<li>
该类通过异步通道的方式加入消息队列中。参照<a href="异步通道机制.html">异步通道机制</a>的实现。
</li>
<li>
热点配置主要关注一个配置文件，在初始化WifiApConfigStore对象时需要读取该文件。
</li>
</ul>

<h3 id="toc_1.7.1">热点状态对象初始化</h3>
<pre class="brush:java">
WifiApConfigStore wifiApConfigStore = 
        WifiApConfigStore.makeWifiApConfigStore(context, getHandler());
wifiApConfigStore.loadApConfiguration();
mWifiApConfigChannel.connectSync(mContext, getHandler(), 
                                 wifiApConfigStore.getMessenger());
</pre>

<h3 id="toc_1.7.2">配置文件的路径</h3>
<pre class="brush:java">
class WifiApConfigStore extends StateMachine {
    private static final String AP_CONFIG_FILE = 
        Environment.getDataDirectory() + "/misc/wifi/softap.conf";
}
</pre>

<h3 id="toc_1.7.3">读取配置文件</h3>
<ul>
<li>
使用DataInputStream读取Java原始数据类型，并填充WifiConfiguration对象。
</li>
<li>
如果读取配置文件发生异常，则会使用默认的配置。
</li>
</ul>

<pre class="brush:java">
void loadApConfiguration() {
    DataInputStream in = null;
    try {
        WifiConfiguration config = new WifiConfiguration();
        in = new DataInputStream(new BufferedInputStream(new FileInputStream(
                                 AP_CONFIG_FILE)));

        int version = in.readInt();
        if (version != 1) {
            setDefaultApConfiguration();
            return;
        }
        config.SSID = in.readUTF();
        int authType = in.readInt();
        config.allowedKeyManagement.set(authType);
        if (authType != KeyMgmt.NONE) {
            config.preSharedKey = in.readUTF();
        }
        mWifiApConfig = config;
    } catch (IOException ignore) {
        // 在异常情况下读取默认的AP配置
        setDefaultApConfiguration();
    } finally {
        ...... 
    }
}
</pre>

<h3 id="toc_1.7.4">写入配置文件</h3>
<ul>
<li>
使用DataInputStream写入Java原始数据类型。
</li>
</ul>

<pre class="brush:java">
private void writeApConfiguration(final WifiConfiguration config) {
    DataOutputStream out = null;
    try {
        out = new DataOutputStream(new BufferedOutputStream(
                                   new FileOutputStream(AP_CONFIG_FILE)));

        out.writeInt(AP_CONFIG_FILE_VERSION);
        out.writeUTF(config.SSID);
        int authType = config.getAuthType();
        out.writeInt(authType);
        if(authType != KeyMgmt.NONE) {
            out.writeUTF(config.preSharedKey);
        }
    } catch (IOException e) {
    } finally {
        ...... 
    }
}
</pre>
<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

<!--<script type="text/javascript">-->
<!--var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");-->
<!--document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));-->
<!--</script>-->
<!--<script type="text/javascript">-->
<!--try {-->
<!--var pageTracker = _gat._getTracker("UA-15922433-1");-->
<!--pageTracker._trackPageview();-->
<!--} catch(err) {}-->
<!--</script>-->

</body>
</html>
