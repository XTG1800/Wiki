<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Binder内核驱动源码分析</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
	<link type="text/css" rel="stylesheet" href="css_style/style_zenki.css"/>

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>


<h1 id="toc_1">Binder内核驱动源码分析</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">Binder内核驱动源码分析</a></li>
<ul>
<li><a href="#toc_1.1">数据结构定义</a></li>
<ul>
<li><a href="#toc_1.1.1">ioctl定义</a></li>
<li><a href="#toc_1.1.2">binder_write_read</a></li>
<li><a href="#toc_1.1.3">binder_transaction_data</a></li>
<li><a href="#toc_1.1.4">binder_fops</a></li>
<li><a href="#toc_1.1.5">miscdevice</a></li>
<li><a href="#toc_1.1.6">binder_proc</a></li>
<li><a href="#toc_1.1.7">binder_thread</a></li>
<li><a href="#toc_1.1.8">binder_node</a></li>
<li><a href="#toc_1.1.9">binder_ref</a></li>
<li><a href="#toc_1.1.10">binder_ref_death</a></li>
<li><a href="#toc_1.1.11">binder_buffer</a></li>
</ul>
<li><a href="#toc_1.2">函数定义</a></li>
<ul>
<li><a href="#toc_1.2.1">binder_init</a></li>
<li><a href="#toc_1.2.2">binder_open</a></li>
<li><a href="#toc_1.2.3">binder_mmap</a></li>
<li><a href="#toc_1.2.4">binder_update_page_range</a></li>
<li><a href="#toc_1.2.5">binder_ioctl</a></li>
<li><a href="#toc_1.2.6">binder_get_thread</a></li>
<li><a href="#toc_1.2.7">binder_new_node</a></li>
<li><a href="#toc_1.2.8">binder_thread_write</a></li>
<li><a href="#toc_1.2.9">binder_thread_read</a></li>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">数据结构定义</h2>
<h3 id="toc_1.1.1">ioctl定义</h3>
<pre class="brush:c++">
// 在binder文件被打开后，其私有数据（private_data）的类型：struct binder_proc
// 在这个数据结构中，主要包含了当前进程、进程ID、内存映射信息、Binder的统计信息和线程信息等。
// 在用户空间对Binder驱动程序进行控制主要使用的接口是mmap、poll和ioctl，ioctl主要使用的ID为：
    
#define BINDER_WRITE_READ        _IOWR('b', 1, struct binder_write_read)
#define BINDER_SET_IDLE_TIMEOUT  _IOW('b', 3, int64_t)
#define BINDER_SET_MAX_THREADS   _IOW('b', 5, size_t)
#define BINDER_SET_IDLE_PRIORITY _IOW('b', 6, int)
#define BINDER_SET_CONTEXT_MGR   _IOW('b', 7, int)
#define BINDER_THREAD_EXIT       _IOW('b', 8, int)
#define BINDER_VERSION           _IOWR('b', 9, struct binder_version)

// BR_XXX等宏为BinderDriverReturnProtocol，表示Binder驱动返回协议。
// BC_XXX等宏为BinderDriverCommandProtocol，表示Binder驱动命令协议。
</pre>

<h3 id="toc_1.1.2">binder_write_read</h3>
<pre class="brush:c++">
// BINDER_WRITE_READ是最重要的ioctl，它使用一个数据结构binder_write_read定义读写的数据。
// 该数据结构能够很好的处理数据传输的同步和异步情形。
// 当write_size为0时，只处理读操作，当read_size为0时只处理写操作，
// 二者都不为0时，先执行写操作再执行读操作，以此实现同步。
struct binder_write_read {
     signed long write_size;
     signed long write_consumed;
     unsigned long write_buffer;
     signed long read_size;
     signed long read_consumed;
     unsigned long read_buffer;
};
</pre>

<h3 id="toc_1.1.3">binder_transaction_data</h3>
<pre class="brush:c++">
struct binder_transaction_data {
	/* The first two are only used for bcTRANSACTION and brTRANSACTION,
	 * identifying the target and contents of the transaction.
	 */
	union {
		size_t	handle;	    /* target descriptor of command transaction */
		void	*ptr;	    /* target descriptor of return transaction */
	} target;
	void		*cookie;	/* target object cookie */
	unsigned int	code;	/* transaction command */

	/* General information about the transaction. */
	unsigned int	flags;
	pid_t		sender_pid;
	uid_t		sender_euid;
	size_t		data_size;	/* number of bytes of data */
	size_t		offsets_size;	/* number of bytes of offsets */

	/* If this transaction is inline, the data immediately
	 * follows here; otherwise, it ends with a pointer to
	 * the data buffer.
	 */
	union {
		struct {
			/* transaction data */
			const void	*buffer;
			/* offsets from buffer to flat_binder_object structs */
			const void	*offsets;
		} ptr;
		uint8_t	buf[8];
	} data;
};
</pre>

<h3 id="toc_1.1.4">binder_fops</h3>
<pre class="brush:c++">
static struct file_operations binder_fops = {  
    .owner = THIS_MODULE,  
    .poll = binder_poll,  
    .unlocked_ioctl = binder_ioctl,  
    .mmap = binder_mmap,  
    .open = binder_open,  
    .flush = binder_flush,  
    .release = binder_release,  
};  
</pre>

<h3 id="toc_1.1.5">miscdevice</h3>
<pre class="brush:c++">
static struct miscdevice binder_miscdev = {
	.minor = MISC_DYNAMIC_MINOR,
	.name = "binder",
	.fops = &amp;binder_fops
};
</pre>

<h3 id="toc_1.1.6">binder_proc</h3>
<pre class="brush:c++">
struct binder_proc {
	struct hlist_node proc_node;
	struct rb_root threads;                 // 线程红黑树，用于保存所有用户进程中的线程
	struct rb_root nodes;                   // Binder实体红黑树
	struct rb_root refs_by_desc;            // Binder引用红黑树，用句柄作为Key
	struct rb_root refs_by_node;            // Binder引用红黑树，用实体节点的地址作为Key
	int pid;                                // 进程ID
	struct vm_area_struct *vma;             // 用户空间的虚拟地址数据结构
	struct task_struct *tsk;
	struct files_struct *files;
	struct hlist_node deferred_work_node;
	int deferred_work;
	void *buffer;                           // 物理内存在内核空间中的地址
	ptrdiff_t user_buffer_offset;           // 内核使用的虚拟地址与进程使用的虚拟地址之间的差值
                                            // user_buffer_offset = proc_start - kernel_start;

	struct list_head buffers;
	struct rb_root free_buffers;            // 空闲的地址区域
	struct rb_root allocated_buffers;       // 正在使用的地址区域
	size_t free_async_space;

	struct page **pages;                    // 物理页面的数据结构
	size_t buffer_size;                     // 映射的内存大小
	uint32_t buffer_free;
	struct list_head todo;
	wait_queue_head_t wait;
	struct binder_stats stats;
	struct list_head delivered_death;
	int max_threads;                        // 用户请求最大线程数
	int requested_threads;
	int requested_threads_started;
	int ready_threads;
	long default_priority;
};
</pre>

<h3 id="toc_1.1.7">binder_thread</h3>
<pre class="brush:c++">
struct binder_thread {
    struct binder_proc *proc;               // 该线程相关的进程
    struct rb_node rb_node;                 // 进程中的所有线程红黑树
    int pid;
    int looper;
    struct binder_transaction *transaction_stack;
    struct list_head todo;
    uint32_t return_error;
    uint32_t return_error2;
    wait_queue_head_t wait;
    struct binder_stats stats;
};
</pre>

<h3 id="toc_1.1.8">binder_node</h3>
<pre class="brush:c++">
// 表示一个Binder实体
struct binder_node {
	int debug_id;
	struct binder_work work;
	union {
		struct rb_node rb_node;
		struct hlist_node dead_node;
	};
	struct binder_proc *proc;
	struct hlist_head refs;
	int internal_strong_refs;
	int local_weak_refs;
	int local_strong_refs;
	void __user *ptr;
	void __user *cookie;
	unsigned has_strong_ref : 1;
	unsigned pending_strong_ref : 1;
	unsigned has_weak_ref : 1;
	unsigned pending_weak_ref : 1;
	unsigned has_async_transaction : 1;
	unsigned accept_fds : 1;
	int min_priority : 8;
	struct list_head async_todo;
};
</pre>

<h3 id="toc_1.1.9">binder_ref</h3>
<pre class="brush:c++">
struct binder_ref {
	/* Lookups needed: */
	/*   node + proc =&gt; ref (transaction) */
	/*   desc + proc =&gt; ref (transaction, inc/dec ref) */
	/*   node =&gt; refs + procs (proc exit) */
	int debug_id;
	struct rb_node rb_node_desc;
	struct rb_node rb_node_node;
	struct hlist_node node_entry;
	struct binder_proc *proc;
	struct binder_node *node;
	uint32_t desc;
	int strong;
	int weak;
	struct binder_ref_death *death;
};
</pre>

<h3 id="toc_1.1.10">binder_ref_death</h3>
<pre class="brush:c++">
struct binder_ref_death {
	struct binder_work work;
	void __user *cookie;
};
</pre>

<h3 id="toc_1.1.11">binder_buffer</h3>
<pre class="brush:c++">
struct binder_buffer {
	struct list_head entry;                 // 链表头
	struct rb_node rb_node;                 // 缓冲空间节点
	
	unsigned free : 1;                      // 当前区域为空闲
	unsigned allow_user_free : 1;
	unsigned async_transaction : 1;
	unsigned debug_id : 29;

	struct binder_transaction *transaction;

	struct binder_node *target_node;
	size_t data_size;
	size_t offsets_size;
	uint8_t data[0];
};
</pre>


<h2 id="toc_1.2">函数定义</h2>
<h3 id="toc_1.2.1">binder_init</h3>
<pre class="brush:c++">
static int __init binder_init(void)
{
	int ret;

	binder_proc_dir_entry_root = proc_mkdir("binder", NULL);
	if (binder_proc_dir_entry_root)
		binder_proc_dir_entry_proc = proc_mkdir("proc", binder_proc_dir_entry_root);
	ret = misc_register(&amp;binder_miscdev);
	if (binder_proc_dir_entry_root) {
		create_proc_read_entry("state", S_IRUGO, binder_proc_dir_entry_root, 
                               binder_read_proc_state, NULL);
		create_proc_read_entry("stats", S_IRUGO, binder_proc_dir_entry_root, 
                               binder_read_proc_stats, NULL);
		create_proc_read_entry("transactions", S_IRUGO, binder_proc_dir_entry_root, 
                               binder_read_proc_transactions, NULL);
		create_proc_read_entry("transaction_log", S_IRUGO, binder_proc_dir_entry_root, 
                               binder_read_proc_transaction_log, &amp;binder_transaction_log);
		create_proc_read_entry("failed_transaction_log", S_IRUGO, binder_proc_dir_entry_root, 
                               binder_read_proc_transaction_log, &amp;binder_transaction_log_failed);
	}
	return ret;
}
</pre>

<h3 id="toc_1.2.2">binder_open</h3>
<pre class="brush:c++">
// 这个函数的主要作用是创建一个struct binder_proc数据结构来保存每个打开设备文件/dev/binder的进程的上下文信息，
// 并且将这个进程上下文信息保存在打开文件结构struct file的私有数据成员变量private_data中。这样，在执行文件操作时，
// 就通过打开文件结构struct file来取回这个进程上下文信息。这个进程上下文信息同时还会保存在一个全局哈希表binder_procs中，
// 供驱动程序内部使用。
static int binder_open(struct inode *nodp, struct file *filp)
{
	struct binder_proc *proc;

	if (binder_debug_mask &amp; BINDER_DEBUG_OPEN_CLOSE)
		printk(KERN_INFO "binder_open: %d:%d\n", current-&gt;group_leader-&gt;pid, current-&gt;pid);

	proc = kzalloc(sizeof(*proc), GFP_KERNEL);
	if (proc == NULL)
		return -ENOMEM;
		
	get_task_struct(current);
	proc-&gt;tsk = current;
	INIT_LIST_HEAD(&amp;proc-&gt;todo);
	init_waitqueue_head(&amp;proc-&gt;wait);
	proc-&gt;default_priority = task_nice(current);
	mutex_lock(&amp;binder_lock);
	binder_stats.obj_created[BINDER_STAT_PROC]++;
	hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);
	proc-&gt;pid = current-&gt;group_leader-&gt;pid;
	INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);
	filp-&gt;private_data = proc;
	mutex_unlock(&amp;binder_lock);

	if (binder_proc_dir_entry_proc) {
		char strbuf[11];
		snprintf(strbuf, sizeof(strbuf), "%u", proc-&gt;pid);
		remove_proc_entry(strbuf, binder_proc_dir_entry_proc);
		create_proc_read_entry(strbuf, S_IRUGO, binder_proc_dir_entry_proc, binder_read_proc_proc, proc);
	}

	return 0;
}
</pre>

<h3 id="toc_1.2.3">binder_mmap</h3>
<pre class="brush:c++">
static int binder_mmap(struct file *filp, struct vm_area_struct *vma)
{
	int ret;
	struct vm_struct *area;
	struct binder_proc *proc = filp-&gt;private_data;
	const char *failure_string;
	struct binder_buffer *buffer;

    // 检查映射的内存大小不能超过4M
	if ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)
		vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;

	if (binder_debug_mask &amp; BINDER_DEBUG_OPEN_CLOSE)
		printk(KERN_INFO
			"binder_mmap: %d %lx-%lx (%ld K) vma %lx pagep %lx\n",
			proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end,
			(vma-&gt;vm_end - vma-&gt;vm_start) / SZ_1K, vma-&gt;vm_flags,
			(unsigned long)pgprot_val(vma-&gt;vm_page_prot));

	if (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) {
		ret = -EPERM;
		failure_string = "bad vm_flags";
		goto err_bad_arg;
	}
	vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE;

	if (proc-&gt;buffer) {
		ret = -EBUSY;
		failure_string = "already mapped";
		goto err_already_mapped;
	}

    // 获取内核空间的虚拟地址空间，和用户进程的大小相同
	area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);
	if (area == NULL) {
		ret = -ENOMEM;
		failure_string = "get_vm_area";
		goto err_get_vm_area_failed;
	}
	
	// 将内核空间的起始地址存入binder_proc结构的buffer变量中，
    // 并计算内核空间地址与用户进程空间地址的偏移
	proc-&gt;buffer = area-&gt;addr;
	proc-&gt;user_buffer_offset = vma-&gt;vm_start - (uintptr_t)proc-&gt;buffer;

#ifdef CONFIG_CPU_CACHE_VIPT
	if (cache_is_vipt_aliasing()) {
		while (CACHE_COLOUR((vma-&gt;vm_start ^ (uint32_t)proc-&gt;buffer))) {
			printk(KERN_INFO "binder_mmap: %d %lx-%lx maps %p bad alignment\n", proc-&gt;pid, 
                   vma-&gt;vm_start, vma-&gt;vm_end, proc-&gt;buffer);
			vma-&gt;vm_start += PAGE_SIZE;
		}
	}
#endif

    // 申请物理页面，并计算虚拟地址空间大小
	proc-&gt;pages = kzalloc(sizeof(proc-&gt;pages[0]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);
	if (proc-&gt;pages == NULL) {
		ret = -ENOMEM;
		failure_string = "alloc page array";
		goto err_alloc_pages_failed;
	}
	proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;

	vma-&gt;vm_ops = &amp;binder_vm_ops;
	vma-&gt;vm_private_data = proc;

    // 将物理页面映射到用户空间和内核空间
	// Server端的用户空间虚拟地址与内核端的虚拟地址共享同一物理内存区域
	if (binder_update_page_range(proc, 1, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) {
		ret = -ENOMEM;
		failure_string = "alloc small buf";
		goto err_alloc_small_buf_failed;
	}
	
    // 将内核空间的地址区域划分成若干binder_buffer数据结构进行分配，并加入到链表结构中
	buffer = proc-&gt;buffer;
	INIT_LIST_HEAD(&amp;proc-&gt;buffers);
	list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers);
	buffer-&gt;free = 1;
	binder_insert_free_buffer(proc, buffer);
	proc-&gt;free_async_space = proc-&gt;buffer_size / 2;
	barrier();
	proc-&gt;files = get_files_struct(current);
	proc-&gt;vma = vma;

	/*printk(KERN_INFO "binder_mmap: %d %lx-%lx maps %p\n", proc-&gt;pid, 
      vma-&gt;vm_start, vma-&gt;vm_end, proc-&gt;buffer);*/
	return 0;

err_alloc_small_buf_failed:
	kfree(proc-&gt;pages);
	proc-&gt;pages = NULL;
err_alloc_pages_failed:
	vfree(proc-&gt;buffer);
	proc-&gt;buffer = NULL;
err_get_vm_area_failed:
err_already_mapped:
err_bad_arg:
	printk(KERN_ERR "binder_mmap: %d %lx-%lx %s failed %d\n", proc-&gt;pid, vma-&gt;vm_start, 
           vma-&gt;vm_end, failure_string, ret);
	return ret;
}
</pre>

<h3 id="toc_1.2.4">binder_update_page_range</h3>
<pre class="brush:c++">
// 将物理页面映射到用户空间和内核空间
static int binder_update_page_range(struct binder_proc *proc, int allocate,
	void *start, void *end, struct vm_area_struct *vma)
{
	void *page_addr;
	unsigned long user_page_addr;
	struct vm_struct tmp_area;
	struct page **page;
	struct mm_struct *mm;

	if (binder_debug_mask &amp; BINDER_DEBUG_BUFFER_ALLOC)
		printk(KERN_INFO "binder: %d: %s pages %p-%p\n",
		       proc-&gt;pid, allocate ? "allocate" : "free", start, end);

	if (end &lt;= start)
		return 0;

	if (vma)
		mm = NULL;
	else
		mm = get_task_mm(proc-&gt;tsk);

	if (mm) {
		down_write(&amp;mm-&gt;mmap_sem);
		vma = proc-&gt;vma;
	}

    // 如果表示为0，则跳转到释放物理内存的代码段
	if (allocate == 0)
		goto free_range;

	if (vma == NULL) {
		printk(KERN_ERR "binder: %d: binder_alloc_buf failed to "
		       "map pages in userspace, no vma\n", proc-&gt;pid);
		goto err_no_vma;
	}

    // 分配物理内存，并映射到用户虚拟地址空间和内核虚拟地址空间
	for (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) {
		int ret;
		struct page **page_array_ptr;
		page = &amp;proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE];

		BUG_ON(*page);
		// alloc_page分配内存
		*page = alloc_page(GFP_KERNEL | __GFP_ZERO);
		if (*page == NULL) {
			printk(KERN_ERR "binder: %d: binder_alloc_buf failed "
			       "for page at %p\n", proc-&gt;pid, page_addr);
			goto err_alloc_page_failed;
		}
		tmp_area.addr = page_addr;
		tmp_area.size = PAGE_SIZE + PAGE_SIZE /* guard page? */;
		page_array_ptr = page;
		
        // 映射内核虚拟地址空间
		ret = map_vm_area(&amp;tmp_area, PAGE_KERNEL, &amp;page_array_ptr);
		if (ret) {
			printk(KERN_ERR "binder: %d: binder_alloc_buf failed "
			       "to map page at %p in kernel\n",
			       proc-&gt;pid, page_addr);
			goto err_map_kernel_failed;
		}
		
        // 根据偏移查找用户虚拟地址
		user_page_addr = (uintptr_t)page_addr + proc-&gt;user_buffer_offset;
		// 映射到用户虚拟地址空间
		ret = vm_insert_page(vma, user_page_addr, page[0]);
		if (ret) {
			printk(KERN_ERR "binder: %d: binder_alloc_buf failed "
			       "to map page at %lx in userspace\n",
			       proc-&gt;pid, user_page_addr);
			goto err_vm_insert_page_failed;
		}
		/* vm_insert_page does not seem to increment the refcount */
	}
	if (mm) {
		up_write(&amp;mm-&gt;mmap_sem);
		mmput(mm);
	}
	return 0;

// 释放物理内存
free_range:
	for (page_addr = end - PAGE_SIZE; page_addr &gt;= start;
	     page_addr -= PAGE_SIZE) {
		page = &amp;proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE];
		if (vma)
			zap_page_range(vma, (uintptr_t)page_addr +
				proc-&gt;user_buffer_offset, PAGE_SIZE, NULL);
err_vm_insert_page_failed:
		unmap_kernel_range((unsigned long)page_addr, PAGE_SIZE);
err_map_kernel_failed:
		__free_page(*page);
		*page = NULL;
err_alloc_page_failed:
		;
	}
err_no_vma:
	if (mm) {
		up_write(&amp;mm-&gt;mmap_sem);
		mmput(mm);
	}
	return -ENOMEM;
}
</pre>

<h3 id="toc_1.2.5">binder_ioctl</h3>
<pre class="brush:c++">
static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) {
	int ret;
	struct binder_proc *proc = filp-&gt;private_data;
	struct binder_thread *thread;
	unsigned int size = _IOC_SIZE(cmd);
	void __user *ubuf = (void __user *)arg;

	ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);
	if (ret)
		return ret;

	mutex_lock(&amp;binder_lock);
	// 从相关进程中获取binder_thread数据结构信息
	thread = binder_get_thread(proc);
	if (thread == NULL) {
		ret = -ENOMEM;
		goto err;
	}

	switch (cmd) {
	case BINDER_SET_CONTEXT_MGR:
		if (binder_context_mgr_node != NULL) {
			printk(KERN_ERR "binder: BINDER_SET_CONTEXT_MGR already set\n");
			ret = -EBUSY;
			goto err;
		}
		
		if (binder_context_mgr_uid != -1) {
			if (binder_context_mgr_uid != current-&gt;cred-&gt;euid) {
				printk(KERN_ERR "binder: BINDER_SET_"
					"CONTEXT_MGR bad uid %d != %d\n",
					current-&gt;cred-&gt;euid,
					binder_context_mgr_uid);
				ret = -EPERM;
				goto err;
			}
		} else {
		    // 第一次进入时初始化ServiceManager的uid
			binder_context_mgr_uid = current-&gt;cred-&gt;euid;
        }
        
        // 创建ServiceManager的Binder实体
		binder_context_mgr_node = binder_new_node(proc, NULL, NULL);
		if (binder_context_mgr_node == NULL) {
			ret = -ENOMEM;
			goto err;
		}
		
		// 初始化ServiceManager的Binder实体
		binder_context_mgr_node-&gt;local_weak_refs++;
		binder_context_mgr_node-&gt;local_strong_refs++;
		binder_context_mgr_node-&gt;has_strong_ref = 1;
		binder_context_mgr_node-&gt;has_weak_ref = 1;
		break;
		
    case BINDER_WRITE_READ: {
		struct binder_write_read bwr;
		if (size != sizeof(struct binder_write_read)) {
			ret = -EINVAL;
			goto err;
		}
		
        // 从用户空间拷贝数据到内核空间
		if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) {
			ret = -EFAULT;
			goto err;
		}
		if (binder_debug_mask &amp; BINDER_DEBUG_READ_WRITE)
			printk(KERN_INFO "binder: %d:%d write %ld at %08lx, read %ld at %08lx\n",
			proc-&gt;pid, thread-&gt;pid, bwr.write_size, bwr.write_buffer, bwr.read_size, bwr.read_buffer);
			
        // 如果有写入数据，则调用binder_thread_write
		if (bwr.write_size &gt; 0) {
			ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, 
                                      &amp;bwr.write_consumed);
			if (ret &lt; 0) {
				bwr.read_consumed = 0;
				if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr)))
					ret = -EFAULT;
				goto err;
			}
		}
		
        // 如果有读入数据，则调用binder_thread_read
		if (bwr.read_size &gt; 0) {
			ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, 
                                     &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);
			if (!list_empty(&amp;proc-&gt;todo))
				wake_up_interruptible(&amp;proc-&gt;wait);
			if (ret &lt; 0) {
				if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr)))
					ret = -EFAULT;
				goto err;
			}
		}
		if (binder_debug_mask &amp; BINDER_DEBUG_READ_WRITE)
			printk(KERN_INFO "binder: %d:%d wrote %ld of %ld, read return %ld of %ld\n",
			proc-&gt;pid, thread-&gt;pid, bwr.write_consumed, bwr.write_size, bwr.read_consumed, bwr.read_size);
			
        // 从内核空间拷贝数据到用户空间
		if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) {
			ret = -EFAULT;
			goto err;
		}
		break;
	}
	
    case BINDER_SET_MAX_THREADS:
		if (copy_from_user(&amp;proc-&gt;max_threads, ubuf, sizeof(proc-&gt;max_threads))) {
			ret = -EINVAL;
			goto err;
		}
		break;
		
    case BINDER_THREAD_EXIT:
		if (binder_debug_mask &amp; BINDER_DEBUG_THREADS)
			printk(KERN_INFO "binder: %d:%d exit\n", proc-&gt;pid, thread-&gt;pid);
		binder_free_thread(proc, thread);
		thread = NULL;
		break;
		
	case BINDER_VERSION:
		if (size != sizeof(struct binder_version)) {
			ret = -EINVAL;
			goto err;
		}
		if (put_user(BINDER_CURRENT_PROTOCOL_VERSION, 
                     &amp;((struct binder_version *)ubuf)-&gt;protocol_version)) {
			ret = -EINVAL;
			goto err;
		}
		break;
	
	default:
		ret = -EINVAL;
		goto err;
	}
	ret = 0;
err:
	if (thread)
		thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_NEED_RETURN;
	mutex_unlock(&amp;binder_lock);
	wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);
	if (ret &amp;&amp; ret != -ERESTARTSYS)
		printk(KERN_INFO "binder: %d:%d ioctl %x %lx returned %d\n", 
               proc-&gt;pid, current-&gt;pid, cmd, arg, ret);
	return ret;
}
</pre>

<h3 id="toc_1.2.6">binder_get_thread</h3>
<pre class="brush:c++">
static struct binder_thread *binder_get_thread(struct binder_proc *proc) {
	struct binder_thread *thread = NULL;
	struct rb_node *parent = NULL;
	struct rb_node **p = &amp;proc-&gt;threads.rb_node;

    // 根据当前线程的PID查找红黑树节点
	while (*p) {
		parent = *p;
		thread = rb_entry(parent, struct binder_thread, rb_node);

		if (current-&gt;pid &lt; thread-&gt;pid)
			p = &amp;(*p)-&gt;rb_left;
		else if (current-&gt;pid &gt; thread-&gt;pid)
			p = &amp;(*p)-&gt;rb_right;
		else
			break;
	}
	
	// 如果查找到对应的节点，则填充binder_thread数据结构，并返回
	if (*p == NULL) {
		thread = kzalloc(sizeof(*thread), GFP_KERNEL);
		if (thread == NULL)
			return NULL;
		binder_stats.obj_created[BINDER_STAT_THREAD]++;
		thread-&gt;proc = proc;
		thread-&gt;pid = current-&gt;pid;
		init_waitqueue_head(&amp;thread-&gt;wait);
		INIT_LIST_HEAD(&amp;thread-&gt;todo);
		rb_link_node(&amp;thread-&gt;rb_node, parent, p);
		rb_insert_color(&amp;thread-&gt;rb_node, &amp;proc-&gt;threads);
		thread-&gt;looper |= BINDER_LOOPER_STATE_NEED_RETURN;
		thread-&gt;return_error = BR_OK;
		thread-&gt;return_error2 = BR_OK;
	}
	
	return thread;
}
</pre>

<h3 id="toc_1.2.7">binder_new_node</h3>
<pre class="brush:c++">
// 创建新的Binder实体
static struct binder_node *
binder_new_node(struct binder_proc *proc, void __user *ptr, void __user *cookie)
{
	struct rb_node **p = &amp;proc-&gt;nodes.rb_node;
	struct rb_node *parent = NULL;
	struct binder_node *node;

	while (*p) {
		parent = *p;
		node = rb_entry(parent, struct binder_node, rb_node);

		if (ptr &lt; node-&gt;ptr)
			p = &amp;(*p)-&gt;rb_left;
		else if (ptr &gt; node-&gt;ptr)
			p = &amp;(*p)-&gt;rb_right;
		else
			return NULL;
	}

	node = kzalloc(sizeof(*node), GFP_KERNEL);
	if (node == NULL)
		return NULL;
	binder_stats.obj_created[BINDER_STAT_NODE]++;
	rb_link_node(&amp;node-&gt;rb_node, parent, p);
	rb_insert_color(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes);
	node-&gt;debug_id = ++binder_last_id;
	node-&gt;proc = proc;
	node-&gt;ptr = ptr;
	node-&gt;cookie = cookie;
	node-&gt;work.type = BINDER_WORK_NODE;
	INIT_LIST_HEAD(&amp;node-&gt;work.entry);
	INIT_LIST_HEAD(&amp;node-&gt;async_todo);
	if (binder_debug_mask &amp; BINDER_DEBUG_INTERNAL_REFS)
		printk(KERN_INFO "binder: %d:%d node %d u%p c%p created\n",
		       proc-&gt;pid, current-&gt;pid, node-&gt;debug_id,
		       node-&gt;ptr, node-&gt;cookie);
	return node;
}
</pre>

<h3 id="toc_1.2.8">binder_thread_write</h3>
<pre class="brush:c++">
int
binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
		    void __user *buffer, int size, signed long *consumed)
{
	uint32_t cmd;
	void __user *ptr = buffer + *consumed;
	void __user *end = buffer + size;

	while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) {
		if (get_user(cmd, (uint32_t __user *)ptr))
			return -EFAULT;
		ptr += sizeof(uint32_t);
		if (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) {
			binder_stats.bc[_IOC_NR(cmd)]++;
			proc-&gt;stats.bc[_IOC_NR(cmd)]++;
			thread-&gt;stats.bc[_IOC_NR(cmd)]++;
		}
		switch (cmd) {
		case BC_INCREFS:
		case BC_ACQUIRE:
		case BC_RELEASE:
		case BC_DECREFS: {
			uint32_t target;
			struct binder_ref *ref;
			const char *debug_string;

			if (get_user(target, (uint32_t __user *)ptr))
				return -EFAULT;
			ptr += sizeof(uint32_t);
			if (target == 0 &amp;&amp; binder_context_mgr_node &amp;&amp;
			    (cmd == BC_INCREFS || cmd == BC_ACQUIRE)) {
				ref = binder_get_ref_for_node(proc,
					       binder_context_mgr_node);
				if (ref-&gt;desc != target) {
					binder_user_error("binder: %d:"
						"%d tried to acquire "
						"reference to desc 0, "
						"got %d instead\n",
						proc-&gt;pid, thread-&gt;pid,
						ref-&gt;desc);
				}
			} else
				ref = binder_get_ref(proc, target);
			if (ref == NULL) {
				binder_user_error("binder: %d:%d refcou"
					"nt change on invalid ref %d\n",
					proc-&gt;pid, thread-&gt;pid, target);
				break;
			}
			switch (cmd) {
			case BC_INCREFS:
				debug_string = "IncRefs";
				binder_inc_ref(ref, 0, NULL);
				break;
			case BC_ACQUIRE:
				debug_string = "Acquire";
				binder_inc_ref(ref, 1, NULL);
				break;
			case BC_RELEASE:
				debug_string = "Release";
				binder_dec_ref(ref, 1);
				break;
			case BC_DECREFS:
			default:
				debug_string = "DecRefs";
				binder_dec_ref(ref, 0);
				break;
			}
			if (binder_debug_mask &amp; BINDER_DEBUG_USER_REFS)
				printk(KERN_INFO "binder: %d:%d %s ref %d desc %d s %d w %d for node %d\n",
				       proc-&gt;pid, thread-&gt;pid, debug_string, ref-&gt;debug_id, ref-&gt;desc, 
                       ref-&gt;strong, ref-&gt;weak, ref-&gt;node-&gt;debug_id);
			break;
		}
		case BC_INCREFS_DONE:
		case BC_ACQUIRE_DONE: {
			void __user *node_ptr;
			void *cookie;
			struct binder_node *node;

			if (get_user(node_ptr, (void * __user *)ptr))
				return -EFAULT;
			ptr += sizeof(void *);
			if (get_user(cookie, (void * __user *)ptr))
				return -EFAULT;
			ptr += sizeof(void *);
			node = binder_get_node(proc, node_ptr);
			if (node == NULL) {
				binder_user_error("binder: %d:%d "
					"%s u%p no match\n",
					proc-&gt;pid, thread-&gt;pid,
					cmd == BC_INCREFS_DONE ?
					"BC_INCREFS_DONE" :
					"BC_ACQUIRE_DONE",
					node_ptr);
				break;
			}
			if (cookie != node-&gt;cookie) {
				binder_user_error("binder: %d:%d %s u%p node %d"
					" cookie mismatch %p != %p\n",
					proc-&gt;pid, thread-&gt;pid,
					cmd == BC_INCREFS_DONE ?
					"BC_INCREFS_DONE" : "BC_ACQUIRE_DONE",
					node_ptr, node-&gt;debug_id,
					cookie, node-&gt;cookie);
				break;
			}
			if (cmd == BC_ACQUIRE_DONE) {
				if (node-&gt;pending_strong_ref == 0) {
					binder_user_error("binder: %d:%d "
						"BC_ACQUIRE_DONE node %d has "
						"no pending acquire request\n",
						proc-&gt;pid, thread-&gt;pid,
						node-&gt;debug_id);
					break;
				}
				node-&gt;pending_strong_ref = 0;
			} else {
				if (node-&gt;pending_weak_ref == 0) {
					binder_user_error("binder: %d:%d "
						"BC_INCREFS_DONE node %d has "
						"no pending increfs request\n",
						proc-&gt;pid, thread-&gt;pid,
						node-&gt;debug_id);
					break;
				}
				node-&gt;pending_weak_ref = 0;
			}
			binder_dec_node(node, cmd == BC_ACQUIRE_DONE, 0);
			if (binder_debug_mask &amp; BINDER_DEBUG_USER_REFS)
				printk(KERN_INFO "binder: %d:%d %s node %d ls %d lw %d\n",
				       proc-&gt;pid, thread-&gt;pid, cmd == BC_INCREFS_DONE ? "BC_INCREFS_DONE" : "BC_ACQUIRE_DONE", 
                       node-&gt;debug_id, node-&gt;local_strong_refs, node-&gt;local_weak_refs);
			break;
		}
		case BC_ATTEMPT_ACQUIRE:
			printk(KERN_ERR "binder: BC_ATTEMPT_ACQUIRE not supported\n");
			return -EINVAL;
		case BC_ACQUIRE_RESULT:
			printk(KERN_ERR "binder: BC_ACQUIRE_RESULT not supported\n");
			return -EINVAL;

		case BC_FREE_BUFFER: {
			void __user *data_ptr;
			struct binder_buffer *buffer;

			if (get_user(data_ptr, (void * __user *)ptr))
				return -EFAULT;
			ptr += sizeof(void *);

			buffer = binder_buffer_lookup(proc, data_ptr);
			if (buffer == NULL) {
				binder_user_error("binder: %d:%d "
					"BC_FREE_BUFFER u%p no match\n",
					proc-&gt;pid, thread-&gt;pid, data_ptr);
				break;
			}
			if (!buffer-&gt;allow_user_free) {
				binder_user_error("binder: %d:%d "
					"BC_FREE_BUFFER u%p matched "
					"unreturned buffer\n",
					proc-&gt;pid, thread-&gt;pid, data_ptr);
				break;
			}
			if (binder_debug_mask &amp; BINDER_DEBUG_FREE_BUFFER)
				printk(KERN_INFO "binder: %d:%d BC_FREE_BUFFER u%p found buffer %d for %s transaction\n",
				       proc-&gt;pid, thread-&gt;pid, data_ptr, buffer-&gt;debug_id,
				       buffer-&gt;transaction ? "active" : "finished");

			if (buffer-&gt;transaction) {
				buffer-&gt;transaction-&gt;buffer = NULL;
				buffer-&gt;transaction = NULL;
			}
			if (buffer-&gt;async_transaction &amp;&amp; buffer-&gt;target_node) {
				BUG_ON(!buffer-&gt;target_node-&gt;has_async_transaction);
				if (list_empty(&amp;buffer-&gt;target_node-&gt;async_todo))
					buffer-&gt;target_node-&gt;has_async_transaction = 0;
				else
					list_move_tail(buffer-&gt;target_node-&gt;async_todo.next, &amp;thread-&gt;todo);
			}
			binder_transaction_buffer_release(proc, buffer, NULL);
			binder_free_buf(proc, buffer);
			break;
		}

		case BC_TRANSACTION:
		case BC_REPLY: {
			struct binder_transaction_data tr;

			if (copy_from_user(&amp;tr, ptr, sizeof(tr)))
				return -EFAULT;
			ptr += sizeof(tr);
			binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);
			break;
		}

		case BC_REGISTER_LOOPER:
			if (binder_debug_mask &amp; BINDER_DEBUG_THREADS)
				printk(KERN_INFO "binder: %d:%d BC_REGISTER_LOOPER\n",
				       proc-&gt;pid, thread-&gt;pid);
			if (thread-&gt;looper &amp; BINDER_LOOPER_STATE_ENTERED) {
				thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;
				binder_user_error("binder: %d:%d ERROR:"
					" BC_REGISTER_LOOPER called "
					"after BC_ENTER_LOOPER\n",
					proc-&gt;pid, thread-&gt;pid);
			} else if (proc-&gt;requested_threads == 0) {
				thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;
				binder_user_error("binder: %d:%d ERROR:"
					" BC_REGISTER_LOOPER called "
					"without request\n",
					proc-&gt;pid, thread-&gt;pid);
			} else {
				proc-&gt;requested_threads--;
				proc-&gt;requested_threads_started++;
			}
			thread-&gt;looper |= BINDER_LOOPER_STATE_REGISTERED;
			break;
		case BC_ENTER_LOOPER:
			if (binder_debug_mask &amp; BINDER_DEBUG_THREADS)
				printk(KERN_INFO "binder: %d:%d BC_ENTER_LOOPER\n",
				       proc-&gt;pid, thread-&gt;pid);
			if (thread-&gt;looper &amp; BINDER_LOOPER_STATE_REGISTERED) {
				thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;
				binder_user_error("binder: %d:%d ERROR:"
					" BC_ENTER_LOOPER called after "
					"BC_REGISTER_LOOPER\n",
					proc-&gt;pid, thread-&gt;pid);
			}
			thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;
			break;
		case BC_EXIT_LOOPER:
			if (binder_debug_mask &amp; BINDER_DEBUG_THREADS)
				printk(KERN_INFO "binder: %d:%d BC_EXIT_LOOPER\n",
				       proc-&gt;pid, thread-&gt;pid);
			thread-&gt;looper |= BINDER_LOOPER_STATE_EXITED;
			break;

		case BC_REQUEST_DEATH_NOTIFICATION:
		case BC_CLEAR_DEATH_NOTIFICATION: {
			uint32_t target;
			void __user *cookie;
			struct binder_ref *ref;
			struct binder_ref_death *death;

			if (get_user(target, (uint32_t __user *)ptr))
				return -EFAULT;
			ptr += sizeof(uint32_t);
			if (get_user(cookie, (void __user * __user *)ptr))
				return -EFAULT;
			ptr += sizeof(void *);
			ref = binder_get_ref(proc, target);
			if (ref == NULL) {
				binder_user_error("binder: %d:%d %s "
					"invalid ref %d\n",
					proc-&gt;pid, thread-&gt;pid,
					cmd == BC_REQUEST_DEATH_NOTIFICATION ?
					"BC_REQUEST_DEATH_NOTIFICATION" :
					"BC_CLEAR_DEATH_NOTIFICATION",
					target);
				break;
			}

			if (binder_debug_mask &amp; BINDER_DEBUG_DEATH_NOTIFICATION)
				printk(KERN_INFO "binder: %d:%d %s %p ref %d desc %d s %d w %d for node %d\n",
				       proc-&gt;pid, thread-&gt;pid,
				       cmd == BC_REQUEST_DEATH_NOTIFICATION ?
				       "BC_REQUEST_DEATH_NOTIFICATION" :
				       "BC_CLEAR_DEATH_NOTIFICATION",
				       cookie, ref-&gt;debug_id, ref-&gt;desc,
				       ref-&gt;strong, ref-&gt;weak, ref-&gt;node-&gt;debug_id);

			if (cmd == BC_REQUEST_DEATH_NOTIFICATION) {
				if (ref-&gt;death) {
					binder_user_error("binder: %d:%"
						"d BC_REQUEST_DEATH_NOTI"
						"FICATION death notific"
						"ation already set\n",
						proc-&gt;pid, thread-&gt;pid);
					break;
				}
				death = kzalloc(sizeof(*death), GFP_KERNEL);
				if (death == NULL) {
					thread-&gt;return_error = BR_ERROR;
					if (binder_debug_mask &amp; BINDER_DEBUG_FAILED_TRANSACTION)
						printk(KERN_INFO "binder: %d:%d "
							"BC_REQUEST_DEATH_NOTIFICATION failed\n",
							proc-&gt;pid, thread-&gt;pid);
					break;
				}
				binder_stats.obj_created[BINDER_STAT_DEATH]++;
				INIT_LIST_HEAD(&amp;death-&gt;work.entry);
				death-&gt;cookie = cookie;
				ref-&gt;death = death;
				if (ref-&gt;node-&gt;proc == NULL) {
					ref-&gt;death-&gt;work.type = BINDER_WORK_DEAD_BINDER;
					if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {
						list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;thread-&gt;todo);
					} else {
						list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;proc-&gt;todo);
						wake_up_interruptible(&amp;proc-&gt;wait);
					}
				}
			} else {
				if (ref-&gt;death == NULL) {
					binder_user_error("binder: %d:%"
						"d BC_CLEAR_DEATH_NOTIFI"
						"CATION death notificat"
						"ion not active\n",
						proc-&gt;pid, thread-&gt;pid);
					break;
				}
				death = ref-&gt;death;
				if (death-&gt;cookie != cookie) {
					binder_user_error("binder: %d:%"
						"d BC_CLEAR_DEATH_NOTIFI"
						"CATION death notificat"
						"ion cookie mismatch "
						"%p != %p\n",
						proc-&gt;pid, thread-&gt;pid,
						death-&gt;cookie, cookie);
					break;
				}
				ref-&gt;death = NULL;
				if (list_empty(&amp;death-&gt;work.entry)) {
					death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;
					if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {
						list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo);
					} else {
						list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo);
						wake_up_interruptible(&amp;proc-&gt;wait);
					}
				} else {
					BUG_ON(death-&gt;work.type != BINDER_WORK_DEAD_BINDER);
					death-&gt;work.type = BINDER_WORK_DEAD_BINDER_AND_CLEAR;
				}
			}
		} break;
		case BC_DEAD_BINDER_DONE: {
			struct binder_work *w;
			void __user *cookie;
			struct binder_ref_death *death = NULL;
			if (get_user(cookie, (void __user * __user *)ptr))
				return -EFAULT;

			ptr += sizeof(void *);
			list_for_each_entry(w, &amp;proc-&gt;delivered_death, entry) {
				struct binder_ref_death *tmp_death = container_of(w, struct binder_ref_death, work);
				if (tmp_death-&gt;cookie == cookie) {
					death = tmp_death;
					break;
				}
			}
			if (binder_debug_mask &amp; BINDER_DEBUG_DEAD_BINDER)
				printk(KERN_INFO "binder: %d:%d BC_DEAD_BINDER_DONE %p found %p\n",
				       proc-&gt;pid, thread-&gt;pid, cookie, death);
			if (death == NULL) {
				binder_user_error("binder: %d:%d BC_DEAD"
					"_BINDER_DONE %p not found\n",
					proc-&gt;pid, thread-&gt;pid, cookie);
				break;
			}

			list_del_init(&amp;death-&gt;work.entry);
			if (death-&gt;work.type == BINDER_WORK_DEAD_BINDER_AND_CLEAR) {
				death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;
				if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {
					list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo);
				} else {
					list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo);
					wake_up_interruptible(&amp;proc-&gt;wait);
				}
			}
		} break;

		default:
			printk(KERN_ERR "binder: %d:%d unknown command %d\n", proc-&gt;pid, thread-&gt;pid, cmd);
			return -EINVAL;
		}
		*consumed = ptr - buffer;
	}
	return 0;
}
</pre>

<h3 id="toc_1.2.9">binder_thread_read</h3>
<pre class="brush:c++">
static int
binder_thread_read(struct binder_proc *proc, struct binder_thread *thread,
	void  __user *buffer, int size, signed long *consumed, int non_block)
{
	void __user *ptr = buffer + *consumed;
	void __user *end = buffer + size;

	int ret = 0;
	int wait_for_proc_work;

	if (*consumed == 0) {
		if (put_user(BR_NOOP, (uint32_t __user *)ptr))
			return -EFAULT;
		ptr += sizeof(uint32_t);
	}

retry:
	wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp; list_empty(&amp;thread-&gt;todo);

	if (thread-&gt;return_error != BR_OK &amp;&amp; ptr &lt; end) {
		if (thread-&gt;return_error2 != BR_OK) {
			if (put_user(thread-&gt;return_error2, (uint32_t __user *)ptr))
				return -EFAULT;
			ptr += sizeof(uint32_t);
			if (ptr == end)
				goto done;
			thread-&gt;return_error2 = BR_OK;
		}
		if (put_user(thread-&gt;return_error, (uint32_t __user *)ptr))
			return -EFAULT;
		ptr += sizeof(uint32_t);
		thread-&gt;return_error = BR_OK;
		goto done;
	}


	thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;
	if (wait_for_proc_work)
		proc-&gt;ready_threads++;
	mutex_unlock(&amp;binder_lock);
	if (wait_for_proc_work) {
		if (!(thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |
					BINDER_LOOPER_STATE_ENTERED))) {
			binder_user_error("binder: %d:%d ERROR: Thread waiting "
				"for process work before calling BC_REGISTER_"
				"LOOPER or BC_ENTER_LOOPER (state %x)\n",
				proc-&gt;pid, thread-&gt;pid, thread-&gt;looper);
			wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);
		}
		binder_set_nice(proc-&gt;default_priority);
		if (non_block) {
			if (!binder_has_proc_work(proc, thread))
				ret = -EAGAIN;
		} else
			ret = wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));
	} else {
		if (non_block) {
			if (!binder_has_thread_work(thread))
				ret = -EAGAIN;
		} else
			ret = wait_event_interruptible(thread-&gt;wait, binder_has_thread_work(thread));
	}
	mutex_lock(&amp;binder_lock);
	if (wait_for_proc_work)
		proc-&gt;ready_threads--;
	thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING;

	if (ret)
		return ret;

	while (1) {
		uint32_t cmd;
		struct binder_transaction_data tr;
		struct binder_work *w;
		struct binder_transaction *t = NULL;

		if (!list_empty(&amp;thread-&gt;todo))
			w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);
		else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)
			w = list_first_entry(&amp;proc-&gt;todo, struct binder_work, entry);
		else {
			if (ptr - buffer == 4 &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) /* no data added */
				goto retry;
			break;
		}

		if (end - ptr &lt; sizeof(tr) + 4)
			break;

		switch (w-&gt;type) {
		case BINDER_WORK_TRANSACTION: {
			t = container_of(w, struct binder_transaction, work);
		} break;
		case BINDER_WORK_TRANSACTION_COMPLETE: {
			cmd = BR_TRANSACTION_COMPLETE;
			if (put_user(cmd, (uint32_t __user *)ptr))
				return -EFAULT;
			ptr += sizeof(uint32_t);

			binder_stat_br(proc, thread, cmd);
			if (binder_debug_mask &amp; BINDER_DEBUG_TRANSACTION_COMPLETE)
				printk(KERN_INFO "binder: %d:%d BR_TRANSACTION_COMPLETE\n",
				       proc-&gt;pid, thread-&gt;pid);

			list_del(&amp;w-&gt;entry);
			kfree(w);
			binder_stats.obj_deleted[BINDER_STAT_TRANSACTION_COMPLETE]++;
		} break;
		case BINDER_WORK_NODE: {
			struct binder_node *node = container_of(w, struct binder_node, work);
			uint32_t cmd = BR_NOOP;
			const char *cmd_name;
			int strong = node-&gt;internal_strong_refs || node-&gt;local_strong_refs;
			int weak = !hlist_empty(&amp;node-&gt;refs) || node-&gt;local_weak_refs || strong;
			if (weak &amp;&amp; !node-&gt;has_weak_ref) {
				cmd = BR_INCREFS;
				cmd_name = "BR_INCREFS";
				node-&gt;has_weak_ref = 1;
				node-&gt;pending_weak_ref = 1;
				node-&gt;local_weak_refs++;
			} else if (strong &amp;&amp; !node-&gt;has_strong_ref) {
				cmd = BR_ACQUIRE;
				cmd_name = "BR_ACQUIRE";
				node-&gt;has_strong_ref = 1;
				node-&gt;pending_strong_ref = 1;
				node-&gt;local_strong_refs++;
			} else if (!strong &amp;&amp; node-&gt;has_strong_ref) {
				cmd = BR_RELEASE;
				cmd_name = "BR_RELEASE";
				node-&gt;has_strong_ref = 0;
			} else if (!weak &amp;&amp; node-&gt;has_weak_ref) {
				cmd = BR_DECREFS;
				cmd_name = "BR_DECREFS";
				node-&gt;has_weak_ref = 0;
			}
			if (cmd != BR_NOOP) {
				if (put_user(cmd, (uint32_t __user *)ptr))
					return -EFAULT;
				ptr += sizeof(uint32_t);
				if (put_user(node-&gt;ptr, (void * __user *)ptr))
					return -EFAULT;
				ptr += sizeof(void *);
				if (put_user(node-&gt;cookie, (void * __user *)ptr))
					return -EFAULT;
				ptr += sizeof(void *);

				binder_stat_br(proc, thread, cmd);
				if (binder_debug_mask &amp; BINDER_DEBUG_USER_REFS)
					printk(KERN_INFO "binder: %d:%d %s %d u%p c%p\n",
					       proc-&gt;pid, thread-&gt;pid, cmd_name, node-&gt;debug_id, node-&gt;ptr, node-&gt;cookie);
			} else {
				list_del_init(&amp;w-&gt;entry);
				if (!weak &amp;&amp; !strong) {
					if (binder_debug_mask &amp; BINDER_DEBUG_INTERNAL_REFS)
						printk(KERN_INFO "binder: %d:%d node %d u%p c%p deleted\n",
						       proc-&gt;pid, thread-&gt;pid, node-&gt;debug_id, node-&gt;ptr, node-&gt;cookie);
					rb_erase(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes);
					kfree(node);
					binder_stats.obj_deleted[BINDER_STAT_NODE]++;
				} else {
					if (binder_debug_mask &amp; BINDER_DEBUG_INTERNAL_REFS)
						printk(KERN_INFO "binder: %d:%d node %d u%p c%p state unchanged\n",
						       proc-&gt;pid, thread-&gt;pid, node-&gt;debug_id, node-&gt;ptr, node-&gt;cookie);
				}
			}
		} break;
		case BINDER_WORK_DEAD_BINDER:
		case BINDER_WORK_DEAD_BINDER_AND_CLEAR:
		case BINDER_WORK_CLEAR_DEATH_NOTIFICATION: {
			struct binder_ref_death *death = container_of(w, struct binder_ref_death, work);
			uint32_t cmd;
			if (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION)
				cmd = BR_CLEAR_DEATH_NOTIFICATION_DONE;
			else
				cmd = BR_DEAD_BINDER;
			if (put_user(cmd, (uint32_t __user *)ptr))
				return -EFAULT;
			ptr += sizeof(uint32_t);
			if (put_user(death-&gt;cookie, (void * __user *)ptr))
				return -EFAULT;
			ptr += sizeof(void *);
			if (binder_debug_mask &amp; BINDER_DEBUG_DEATH_NOTIFICATION)
				printk(KERN_INFO "binder: %d:%d %s %p\n",
				       proc-&gt;pid, thread-&gt;pid,
				       cmd == BR_DEAD_BINDER ?
				       "BR_DEAD_BINDER" :
				       "BR_CLEAR_DEATH_NOTIFICATION_DONE",
				       death-&gt;cookie);

			if (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) {
				list_del(&amp;w-&gt;entry);
				kfree(death);
				binder_stats.obj_deleted[BINDER_STAT_DEATH]++;
			} else
				list_move(&amp;w-&gt;entry, &amp;proc-&gt;delivered_death);
			if (cmd == BR_DEAD_BINDER)
				goto done; /* DEAD_BINDER notifications can cause transactions */
		} break;
		}

		if (!t)
			continue;

		BUG_ON(t-&gt;buffer == NULL);
		if (t-&gt;buffer-&gt;target_node) {
			struct binder_node *target_node = t-&gt;buffer-&gt;target_node;
			tr.target.ptr = target_node-&gt;ptr;
			tr.cookie =  target_node-&gt;cookie;
			t-&gt;saved_priority = task_nice(current);
			if (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp;
			    !(t-&gt;flags &amp; TF_ONE_WAY))
				binder_set_nice(t-&gt;priority);
			else if (!(t-&gt;flags &amp; TF_ONE_WAY) ||
				 t-&gt;saved_priority &gt; target_node-&gt;min_priority)
				binder_set_nice(target_node-&gt;min_priority);
			cmd = BR_TRANSACTION;
		} else {
			tr.target.ptr = NULL;
			tr.cookie = NULL;
			cmd = BR_REPLY;
		}
		tr.code = t-&gt;code;
		tr.flags = t-&gt;flags;
		tr.sender_euid = t-&gt;sender_euid;

		if (t-&gt;from) {
			struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk;
			tr.sender_pid = task_tgid_nr_ns(sender, current-&gt;nsproxy-&gt;pid_ns);
		} else {
			tr.sender_pid = 0;
		}

		tr.data_size = t-&gt;buffer-&gt;data_size;
		tr.offsets_size = t-&gt;buffer-&gt;offsets_size;
		tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data + proc-&gt;user_buffer_offset;
		tr.data.ptr.offsets = tr.data.ptr.buffer + ALIGN(t-&gt;buffer-&gt;data_size, sizeof(void *));

		if (put_user(cmd, (uint32_t __user *)ptr))
			return -EFAULT;
		ptr += sizeof(uint32_t);
		if (copy_to_user(ptr, &amp;tr, sizeof(tr)))
			return -EFAULT;
		ptr += sizeof(tr);

		binder_stat_br(proc, thread, cmd);
		if (binder_debug_mask &amp; BINDER_DEBUG_TRANSACTION)
			printk(KERN_INFO "binder: %d:%d %s %d %d:%d, cmd %d"
				"size %zd-%zd ptr %p-%p\n",
			       proc-&gt;pid, thread-&gt;pid,
			       (cmd == BR_TRANSACTION) ? "BR_TRANSACTION" : "BR_REPLY",
			       t-&gt;debug_id, t-&gt;from ? t-&gt;from-&gt;proc-&gt;pid : 0,
			       t-&gt;from ? t-&gt;from-&gt;pid : 0, cmd,
			       t-&gt;buffer-&gt;data_size, t-&gt;buffer-&gt;offsets_size,
			       tr.data.ptr.buffer, tr.data.ptr.offsets);

		list_del(&amp;t-&gt;work.entry);
		t-&gt;buffer-&gt;allow_user_free = 1;
		if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) {
			t-&gt;to_parent = thread-&gt;transaction_stack;
			t-&gt;to_thread = thread;
			thread-&gt;transaction_stack = t;
		} else {
			t-&gt;buffer-&gt;transaction = NULL;
			kfree(t);
			binder_stats.obj_deleted[BINDER_STAT_TRANSACTION]++;
		}
		break;
	}

done:

	*consumed = ptr - buffer;
	if (proc-&gt;requested_threads + proc-&gt;ready_threads == 0 &amp;&amp;
	    proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &amp;&amp;
	    (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |
	     BINDER_LOOPER_STATE_ENTERED)) /* the user-space code fails to */
	     /*spawn a new thread if we leave this out */) {
		proc-&gt;requested_threads++;
		if (binder_debug_mask &amp; BINDER_DEBUG_THREADS)
			printk(KERN_INFO "binder: %d:%d BR_SPAWN_LOOPER\n",
			       proc-&gt;pid, thread-&gt;pid);
		if (put_user(BR_SPAWN_LOOPER, (uint32_t __user *)buffer))
			return -EFAULT;
	}
	return 0;
}
</pre>
<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

<!--<script type="text/javascript">-->
<!--var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");-->
<!--document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));-->
<!--</script>-->
<!--<script type="text/javascript">-->
<!--try {-->
<!--var pageTracker = _gat._getTracker("UA-15922433-1");-->
<!--pageTracker._trackPageview();-->
<!--} catch(err) {}-->
<!--</script>-->

</body>
</html>
