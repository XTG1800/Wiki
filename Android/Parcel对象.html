<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Parcel对象</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <link rel="Stylesheet" type="text/css" href="../css_style/style_zenki.css">

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>

<!-- wrap the vimwiki html -->

<h1 id="toc_1">Parcel详解</h1>
<p>
<em>Parcel是基本数据和对象引用的容器，能够通过IBinder在进程间传递数据。</em>
</p>

<div class="toc">
<ul>
<li><a href="#toc_1">Parcel详解</a>
<ul>
<li><a href="#toc_1.1">相关类</a>
<li><a href="#toc_1.2">基本流程</a>
<li><a href="#toc_1.3">基本类型及计算原则</a>
<ul>
<li><a href="#toc_1.3.1">基本数据类型的大小</a>
<li><a href="#toc_1.3.2">偏移量</a>
<li><a href="#toc_1.3.3">示例代码</a>
</ul>
</ul>
<li><a href="#toc_2">实现Parcelable接口</a>
<ul>
<li><a href="#toc_2.1">已知子类</a>
<li><a href="#toc_2.2">基本流程</a>
<li><a href="#toc_2.3">示例代码</a>
</ul>
</ul>
</div>

<h2 id="toc_1.1">相关类</h2>
<pre class="brush:java">
import android.os.Parcel;
import android.os.Parcelable;
</pre>

<h2 id="toc_1.2">基本流程</h2>
<ul>
<li>
通过<code>Parcel.obtain()</code>构造一个对象

<li>
通过<code>create*</code>、<code>write*</code>、<code>read*</code>等系列方法对数据进行操作

<li>
<code>setDataPosition()</code>方法设置当前的偏移量，<code>dataPosition()</code>返回当前的偏移量，<code>dataSize()</code>返回数据大小，以偏移量为单位

</ul>

<h2 id="toc_1.3">基本类型及计算原则</h2>

<h3 id="toc_1.3.1">基本数据类型的大小</h3>
<table>
<tr>
<th>
数据类型
</th>
<th>
偏移量大小
</th>
</tr>
<tr>
<td>
boolean
</td>
<td>
1bit
</td>
</tr>
<tr>
<td>
byte
</td>
<td>
8bit
</td>
</tr>
<tr>
<td>
char
</td>
<td>
16bit
</td>
</tr>
<tr>
<td>
short
</td>
<td>
16bit
</td>
</tr>
<tr>
<td>
int
</td>
<td>
32bit
</td>
</tr>
<tr>
<td>
float
</td>
<td>
32bit
</td>
</tr>
<tr>
<td>
long
</td>
<td>
64bit
</td>
</tr>
<tr>
<td>
double
</td>
<td>
64bit
</td>
</tr>
</table>

<h3 id="toc_1.3.2">偏移量</h3>
<pre class="brush:text">
Parcel以32bit即4个字节为单位存储数据，因此偏移量总是为4的倍数，
如：0,4,8,12,16,20,24,28,32,36,40,44,48......4*N
</pre>

<h3 id="toc_1.3.3">示例代码</h3>
<pre class="brush:java">
Parcel parcel = Parcel.obtain();

parcel.writeFloat(10);
parcel.writeString("hello");

parcel.setDataPosition(0);
int i = parcel.readInt();
String s = parcel.readString();
</pre>

<h1 id="toc_2">实现Parcelable接口</h1>

<h2 id="toc_2.1">已知子类</h2>
<table>
<tr>
<th>
类名
</th>
<th>
描述
</th>
</tr>
<tr>
<td>
Bitmap
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
Bundle
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
Gesture
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
Intent
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
KeyEvent
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
Message
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
Notification
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
Rect
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
ServiceInfo
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
Surface
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
Uri
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
WifiInfo
</td>
<td>
&nbsp;
</td>
</tr>
</table>

<h2 id="toc_2.2">基本流程</h2>
<ul>
<li>
从Parcelable类继承，并实现<code>Parcelable.Creator接口</code>和<code>writeToParcel</code>方法

</ul>

<h2 id="toc_2.3">示例代码</h2>
<pre class="brush:java">
public class MyParcelable implements Parcelable {

    private int mData;

    // 构造方法
    private MyParcelable(Parcel in) {
        mData = in.readInt();
    }

    // 实现Creator接口，Creator&lt;T&gt;接收该类作为参数
    public static final Parcelable.Creator&lt;MyParcelable&gt; CREATOR = new Parcelable.Creator&lt;MyParcelable&gt;() {
    
        // 在该方法中通过in读出数据，并返回该类对象实例
        public MyParcelable createFromParcel(Parcel in) {
            // int i = in.readInt();
            return new MyParcelable(in);
        }

        // 创建数据类型
        public MyParcelable[] newArray(int size) {
            return new MyParcelable[size];
        }
    };
    
    public int describeContents() {
        return 0;
    }
 
    // 在该方法中通过out写入数据
    public void writeToParcel(Parcel out, int flags) {
        out.writeInt(mData);
    }
}
</pre>


<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

</body>
</html>
