<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>socket通讯</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <link rel="Stylesheet" type="text/css" href="../css_style/style_zenki.css">

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>

<!-- wrap the vimwiki html -->

<h1 id="toc_1">socket通讯</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">socket通讯</a>
<ul>
<li><a href="#toc_1.1">相关文件</a>
<li><a href="#toc_1.2">创建socket节点</a>
<li><a href="#toc_1.3">native层的服务端</a>
<li><a href="#toc_1.4">Java层的客户端</a>
<ul>
<li><a href="#toc_1.4.1">本地socket名字空间</a>
</ul>
<li><a href="#toc_1.5">代码示例(Java)</a>
<li><a href="#toc_1.6">代码示例(C++)</a>
</ul>
</ul>
</div>

<h2 id="toc_1.1">相关文件</h2>
<pre class="brush:c++">
// C++层
#include &lt;cutils/sockets.h&gt;

// Java层
import android.net.LocalSocket;
import android.net.LocalSocketAddress;
import java.io.OutputStream;
</pre>

<h2 id="toc_1.2">创建socket节点</h2>
<ul>
<li>
Android提供了一个方便socket通讯的机制，通过创建一个命名的socket节点为通讯两端架设通道。

<li>
通常在init.rc中创建相关的socket节点。如下例创建的demo节点。

</ul>

<pre class="brush:bash">
# vold：socket名称
# stream：socket类型
# 0660：读取权限
service socketDemo /system/bin/myserver
    socket demo stream 0666 system system
</pre>

<ul>
<li>
当系统运行后会创建/dev/socket/demo的设备节点。

</ul>

<pre class="brush:bash">
$ ls /dev/socket/demo
srw-rw-rw-  1 system system     1,5  2011-12-06 08:21 demo
</pre>

<h2 id="toc_1.3">native层的服务端</h2>
<ul>
<li>
通过&lt;cutils/sockets.h&gt;中的android_get_control_socket方法获取命名的demo设备节点描述符。

</ul>

<pre class="brush:c++">
// 与init.rc中创建的socket节点命名一致
#define socketName "demo"

int initSocket() 
{
    int fd;

    // 获取描述符
    if ((fd = android_get_control_socket(socketName)) &lt; 0) {
        LOGD("demo socket error");
        return -1;
    }

    // 开启监听
    if (listen(fd, 4) &lt; 0) {
        LOGD("demo listen error");
        return -1;
    }

    return fd;
}
</pre>

<h2 id="toc_1.4">Java层的客户端</h2>
<ul>
<li>
客户端同样需要打开demo节点，使用LocalSocket和LocalSocketAddress完成该功能。

<li>
LocalSocketAddress.Namespace决定了如何查找指定名字的socket节点。

</ul>

<pre class="brush:java">
void sendMsgToServer() 
{
    LocalSocket s = null;
    LocalSocketAddress l;
    byte[] buf = new byte[1];
    buf[0] = '1';

    try {
        s = new LocalSocket();
        l = new LocalSocketAddress("demo",LocalSocketAddress.Namespace.RESERVED);
        s.connect(l);

        OutputStream os = s.getOutputStream();
        if (os != null) {
            os.write(buf);
            os.flush();
            os.close();
        }
    } catch (Exception e) {
        Log.d(TAG, "sendMsgToServer error " + e);
    }
}
</pre>

<h3 id="toc_1.4.1">本地socket名字空间</h3>
<table>
<tr>
<th>
标识
</th>
<th>
描述
</th>
<th>
备注
</th>
</tr>
<tr>
<td>
LocalSocketAddress.Namespace.ABSTRACT
</td>
<td>
abstract名字空间
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
LocalSocketAddress.Namespace.FILESYSTEM
</td>
<td>
filesystem名字空间
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
LocalSocketAddress.Namespace.RESERVED
</td>
<td>
/dev/socket名字空间
</td>
<td>
&nbsp;
</td>
</tr>
</table>

<h2 id="toc_1.5">代码示例(Java)</h2>
<pre class="brush:c">
private void listenToSocket() throws IOException {
    LocalSocket socket = null;
    
    try {
        // 初始化socket
        socket = new LocalSocket();
        LocalSocketAddress address = new LocalSocketAddress(mSocket,
                LocalSocketAddress.Namespace.RESERVED);
        socket.connect(address);
        
        // 获取输入输出流
        InputStream inputStream = socket.getInputStream();
        mOutputStream = socket.getOutputStream();

        byte[] buffer = new byte[BUFFER_SIZE];
        int start = 0;

        while (true) {
            int count = inputStream.read(buffer, start, BUFFER_SIZE - start);
            if (count &lt; 0) break;

            // 更新读取的字节数，并重置起始标志
            count += start;
            start = 0;

            for (int i = 0; i &lt; count; i++) {
                // 以0结尾的标识，标识读到正确的数据
                if (buffer[i] == 0) {
                    String event = new String(buffer, start, i - start);
                    // 解析获取的字符串信息
                    // ......
                     
                    // 更新起始标志
                    start = i + 1;
                }
            }

            // 如果没有找到正确的字符串，则重新读取
            if (start != count) {
                final int remaining = BUFFER_SIZE - start;
                System.arraycopy(buffer, start, buffer, 0, remaining);
                start = remaining;
            } else {
                start = 0;
            }
        }
    } catch (IOException ex) {
        throw ex;
    } finally {
        synchronized (this) {
            if (mOutputStream != null) {
                try {
                    mOutputStream.close();
                } catch (IOException e) {
                }
                mOutputStream = null;
            }
        }

        try {
            if (socket != null) {
                socket.close();
            }
        } catch (IOException ex) {
        }
    }
}
</pre>

<h2 id="toc_1.6">代码示例(C++)</h2>
<pre class="brush:c">
bool FrameworkListener::onDataAvailable(SocketClient *c) {
    char buffer[255];
    int len;

    if ((len = read(c-&gt;getSocket(), buffer, sizeof(buffer) - 1)) &lt; 0) {
        return false;
    } else if (!len)
        return false;

    int offset = 0;
    int i;

    for (i = 0; i &lt; len; i++) {
        if (buffer[i] == '\0') {
            dispatchCommand(c, buffer + offset);
            offset = i + 1;
        }
    }
    return true;
}
</pre>


<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

</body>
</html>
