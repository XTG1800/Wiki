<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>init进程解析</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
	<link type="text/css" rel="stylesheet" href="css_style/style_zenki.css"/>

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>


<h1 id="toc_1">init进程解析(基于Android 2.3)</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">init进程解析(基于Android 2.3)</a></li>
<ul>
<li><a href="#toc_1.1">相关文件</a></li>
<li><a href="#toc_1.2">Android系统的启动</a></li>
<li><a href="#toc_1.3">init.rc的作用</a></li>
<li><a href="#toc_1.4">init进程的功能及流程分析</a></li>
<ul>
<li><a href="#toc_1.4.1">1.初始化文件系统</a></li>
<li><a href="#toc_1.4.2">2.创建kmsg和null文件节点</a></li>
<li><a href="#toc_1.4.3">3.解析init.rc文件</a></li>
<li><a href="#toc_1.4.4">4.解析cmdline</a></li>
<ul>
<li><a href="#toc_1.4.4.1">/proc/cmdline示例</a></li>
</ul>
<li><a href="#toc_1.4.5">5.解析init.%hardware.rc文件</a></li>
<ul>
<li><a href="#toc_1.4.5.1">/proc/cpuinfo示例</a></li>
</ul>
<li><a href="#toc_1.4.6">6.执行early-init触发的命令</a></li>
<li><a href="#toc_1.4.7">7.初始化devices</a></li>
<li><a href="#toc_1.4.8">8.初始化属性系统</a></li>
<li><a href="#toc_1.4.9">9.打开keychord和console</a></li>
<li><a href="#toc_1.4.10">10.加载logo</a></li>
<li><a href="#toc_1.4.11">11.判断cmdline参数，设置系统属性</a></li>
<li><a href="#toc_1.4.12">12.执行init触发的命令</a></li>
<li><a href="#toc_1.4.13">13.开启property_service服务</a></li>
<li><a href="#toc_1.4.14">14.创建信号处理机制</a></li>
<li><a href="#toc_1.4.15">15.执行early-boot和boot触发的命令</a></li>
<li><a href="#toc_1.4.16">16. 执行property相关的命令</a></li>
<li><a href="#toc_1.4.17">17.注册轮询事件</a></li>
<li><a href="#toc_1.4.18">18.初始化BOOTCHART</a></li>
<li><a href="#toc_1.4.19">19.进入主循环等待事件处理</a></li>
</ul>
</ul>
<li><a href="#toc_2">参考代码</a></li>
</ul>
</div>

<h2 id="toc_1.1">相关文件</h2>
<pre class="brush:text">
system/core/init/init.c
system/core/init/init.h
system/core/init/devices.c
system/core/init/devices.h
system/core/init/logo.c
system/core/init/bootchart.c
system/core/init/bootchart.h
system/core/init/util.c
system/core/init/ueventd.c
system/core/init/propery_service.c
system/core/init/propery_service.h
system/core/init/parser.c
</pre>

<h2 id="toc_1.2">Android系统的启动</h2>
<pre class="brush:text">
    内核引导启动时，会加上"init=/init"，表示内核成功挂载了这个文件系统之后，首先运行的就是这个根目录下的init程序，该进程启动后，进程号为1。
    从源码分析，如果启动进程是ueventd，则会从ueventd_main()方法进入另一个分支。通常/sbin/ueventd是指向init的链接。
</pre>

<h2 id="toc_1.3">init.rc的作用</h2>
<ul>
<li>
init进程在启动过程中会读取init.rc文件，该文件可作为配置系统的脚本，init对该脚本进行解析，并做出相应的动作。(参见<a href="Android Init Language.html">Android Init Language</a>)
</li>
</ul>

<h2 id="toc_1.4">init进程的功能及流程分析</h2>
<ul>
<li>
我们的分析从system/core/init/init.c文件的main()方法开始，并截取部分main的代码片段，完整代码请参考后面的代码。
</li>
</ul>

<h3 id="toc_1.4.1">1.初始化文件系统</h3>
<ul>
<li>
首先init会创建系统文件夹，并挂载相应分区。
</li>
</ul>

<pre class="brush:c++">
umask(0);

/* Get the basic filesystem setup we need put
 * together in the initramdisk on / and then we'll
 * let the rc file figure out the rest.
 */
mkdir("/dev", 0755);
mkdir("/proc", 0755);
mkdir("/sys", 0755);

mount("tmpfs", "/dev", "tmpfs", 0, "mode=0755");
mkdir("/dev/pts", 0755);
mkdir("/dev/socket", 0755);
mount("devpts", "/dev/pts", "devpts", 0, NULL);
mount("proc", "/proc", "proc", 0, NULL);
mount("sysfs", "/sys", "sysfs", 0, NULL);
</pre>

<h3 id="toc_1.4.2">2.创建kmsg和null文件节点</h3>
<pre class="brush:c++">
// 创建空节点
open_devnull_stdio();
// 创建kmsg(/dev/kmsg)节点，主要用来输出LOG信息
log_init();
</pre>

<h3 id="toc_1.4.3">3.解析init.rc文件</h3>
<ul>
<li>
init.rc的脚本类型分为service和action两种，<code>parse_line_service()</code>和<code>parse_line_action()</code>分别对它们进行处理。
</li>
</ul>

<pre class="brush:c++">
init_parse_config_file("/init.rc");
</pre>

<h3 id="toc_1.4.4">4.解析cmdline</h3>
<ul>
<li>
/proc/cmdline以key=value的形式保存了一些系统参数，init进程会读取这些值并设置系统属性，更重要的是它会改变该文件的属性使其他进程不能访问。
</li>
</ul>

<pre class="brush:c++">
// 从linux内核里获取引导系统给内核的引导参数，并保存到全局变量
import_kernel_cmdline(0);
</pre>

<h4 id="toc_1.4.4.1">/proc/cmdline示例</h4>
<pre class="brush:bash">
console=ttyVSP1,115200n8 rootwait init=/init videoout=omap24xxvout omap_vout.video1_numbuffers=6 omap_vout.vid1_static_vrfb_alloc=y omapfb.vram=0:6M androidboot.console=ttyVSP1
</pre>


<h3 id="toc_1.4.5">5.解析init.%hardware.rc文件</h3>
<ul>
<li>
获取当前android系统运行的硬件信息，比如硬件的CPU名称。
</li>
<li>
init除了解析/init.rc文件外，还会解析/init.%hardware.rc文件。%hardware表示CPU名称，从/proc/cpuinfo中读取。
</li>
</ul>

<pre class="brush:c++">
get_hardware_name(hardware, &amp;revision);
snprintf(tmp, sizeof(tmp), "/init.%s.rc", hardware);
init_parse_config_file(tmp);
</pre>

<h4 id="toc_1.4.5.1">/proc/cpuinfo示例</h4>
<pre class="brush:text">
Processor       : ARMv7 Processor rev 2 (v7l)
BogoMIPS        : 796.19
Features        : swp half thumb fastmult vfp edsp neon vfpv3 
CPU implementer : 0x41
CPU architecture: 7
CPU variant     : 0x3
CPU part        : 0xc08
CPU revision    : 2

Hardware        : OMAP3621 EVT1A board
Revision        : 0010
Serial          : 0000000000000000
</pre>

<h3 id="toc_1.4.6">6.执行early-init触发的命令</h3>
<ul>
<li>
early-init的命令被加入到队列中优先执行。
</li>
</ul>

<pre class="brush:c++">
action_for_each_trigger("early-init", action_add_queue_tail);
drain_action_queue();
</pre>

<h3 id="toc_1.4.7">7.初始化devices</h3>
<ul>
<li>
添加/sys下的设备
</li>
</ul>

<pre class="brush:c++">
INFO("device init\n");
device_fd = device_init();
</pre>

<h3 id="toc_1.4.8">8.初始化属性系统</h3>
<pre class="brush:c++">
property_init();
</pre>

<h3 id="toc_1.4.9">9.打开keychord和console</h3>
<ul>
<li>
如果ro.debuggable是true，则打开keychord
</li>
<li>
如果cmdline中没有指定console，则打开默认的/dev/console
</li>
</ul>

<pre class="brush:c++">
keychord_fd = open_keychord();

if (console[0]) {
    snprintf(tmp, sizeof(tmp), "/dev/%s", console);
    console_name = strdup(tmp);
}

fd = open(console_name, O_RDWR);
if (fd &gt;= 0)
    have_console = 1;
close(fd);
</pre>

<h3 id="toc_1.4.10">10.加载logo</h3>
<ul>
<li>
加载<code>/initlogo.rle</code>图片，如果成功就显示在<code>/dev/graphics/fb0</code>。否则在<code>/dev/tty0</code>中显示Android字串。
</li>
</ul>

<pre class="brush:c++">
if( load_565rle_image(INIT_IMAGE_FILE) ) {
    fd = open("/dev/tty0", O_WRONLY);
    if (fd &gt;= 0) {
        const char *msg;
            msg = "\n"
        "\n"
        "\n"
        "\n"
        "\n"
        "\n"
        "\n"  // console is 40 cols x 30 lines
        "\n"
        "\n"
        "\n"
        "\n"
        "\n"
        "\n"
        "\n"
        "             A N D R O I D ";
        write(fd, msg, strlen(msg));
        close(fd);
    }
}
</pre>

<h3 id="toc_1.4.11">11.判断cmdline参数，设置系统属性</h3>
<pre class="brush:c++">
if (qemu[0])
    import_kernel_cmdline(1); 

// 如果bootmode为factory，设置ro.factorytest值为1
if (!strcmp(bootmode,"factory"))
    property_set("ro.factorytest", "1");
// factory2,设置ro.factorytest值为2
else if (!strcmp(bootmode,"factory2"))
    property_set("ro.factorytest", "2");
// 其他ro.factorytest值为0
else
    property_set("ro.factorytest", "0");

// 设置手机序列号
property_set("ro.serialno", serialno[0] ? serialno : "");
// 设置启动模式
property_set("ro.bootmode", bootmode[0] ? bootmode : "unknown");
// 设置基频率
property_set("ro.baseband", baseband[0] ? baseband : "unknown");
// 设置机器CID
property_set("ro.carrier", carrier[0] ? carrier : "unknown");
// 设置引导程序的版本号，以便知道引导程序的特性
property_set("ro.bootloader", bootloader[0] ? bootloader : "unknown");

// 设置CPU信息
property_set("ro.hardware", hardware);
// 设置硬件修订的版本号
property_set("ro.revision", tmp);
</pre>

<h3 id="toc_1.4.12">12.执行init触发的命令</h3>
<pre class="brush:c++">
action_for_each_trigger("init", action_add_queue_tail);
drain_action_queue();
</pre>

<h3 id="toc_1.4.13">13.开启property_service服务</h3>
<ul>
<li>
当所有属性设置完成后开启属性服务的service，以便其他进程查询和修改。
</li>
<li>
从以下变量指定的文件中读取属性
</li>
<ul>
<li>
PROP_PATH_SYSTEM_BUILD = /system/build.prop
</li>
<li>
PROP_PATH_SYSTEM_DEFAULT = /system/default.prop
</li>
<li>
PROP_PATH_LOCAL_OVERRIDE = /data/local.prop
</li>
</ul>
</ul>

<pre class="brush:c++">
property_set_fd = start_property_service();
</pre>

<h3 id="toc_1.4.14">14.创建信号处理机制</h3>
<ul>
<li>
其实这个信号管理，就是用来让init进程与它的子进程进行沟通的，子进程从signal_fd写入信息，init进程从signal_recv_fd收到信息，然后再做处理。
</li>
</ul>

<pre class="brush:c++">
/* create a signalling mechanism for the sigchld handler */
if (socketpair(AF_UNIX, SOCK_STREAM, 0, s) == 0) {
    signal_fd = s[0];
    signal_recv_fd = s[1];
    fcntl(s[0], F_SETFD, FD_CLOEXEC);
    fcntl(s[0], F_SETFL, O_NONBLOCK);
    fcntl(s[1], F_SETFD, FD_CLOEXEC);
    fcntl(s[1], F_SETFL, O_NONBLOCK);
}

/* make sure we actually have all the pieces we need */
if ((device_fd &lt; 0) ||
    (property_set_fd &lt; 0) ||
    (signal_recv_fd &lt; 0)) {
    ERROR("init startup failure\n");
    return 1;
}
</pre>

<h3 id="toc_1.4.15">15.执行early-boot和boot触发的命令</h3>
<pre class="brush:c++">
action_for_each_trigger("early-boot", action_add_queue_tail);
action_for_each_trigger("boot", action_add_queue_tail);
drain_action_queue();
</pre>

<h3 id="toc_1.4.16">16. 执行property相关的命令</h3>
<pre class="brush:c++">
queue_all_property_triggers();
drain_action_queue();

property_triggers_enabled = 1;
</pre>

<h3 id="toc_1.4.17">17.注册轮询事件</h3>
<pre class="brush:c++">
ufds[0].fd = device_fd;
ufds[0].events = POLLIN;
ufds[1].fd = property_set_fd;
ufds[1].events = POLLIN;
ufds[2].fd = signal_recv_fd;
ufds[2].events = POLLIN;
fd_count = 3;

if (keychord_fd &gt; 0) {
    ufds[3].fd = keychord_fd;
    ufds[3].events = POLLIN;
    fd_count++;
} else {
    ufds[3].events = 0;
    ufds[3].revents = 0;
}
</pre>

<h3 id="toc_1.4.18">18.初始化BOOTCHART</h3>
<ul>
<li>
初始化linux程序启动速度的性能分析工具，这个工具有一个好处，就是图形化显示每个进程启动顺序和占用时间。
</li>
</ul>

<pre class="brush:c++">
#if BOOTCHART
    bootchart_count = bootchart_init();
    if (bootchart_count &lt; 0) {
        ERROR("bootcharting init failure\n");
    } else if (bootchart_count &gt; 0) {
        NOTICE("bootcharting started (period=%d ms)\n", bootchart_count*BOOTCHART_POLLING_MS);
    } else {
        NOTICE("bootcharting ignored\n");
    }
#endif
</pre>

<h3 id="toc_1.4.19">19.进入主循环等待事件处理</h3>
<pre class="brush:c++">
for(;;) {
    int nr, i, timeout = -1;

    // 重置轮询事件的接收状态为0
    for (i = 0; i &lt; fd_count; i++)
        ufds[i].revents = 0;

    // 执行action队列
    drain_action_queue();
    // 重启需要重启的进程
    restart_processes();

    if (process_needs_restart) {
        timeout = (process_needs_restart - gettime()) * 1000;
        if (timeout &lt; 0)
            timeout = 0;
    }

#if BOOTCHART
    // 完成BOOTCHART的log
    if (bootchart_count &gt; 0) {
        if (timeout &lt; 0 || timeout &gt; BOOTCHART_POLLING_MS)
            timeout = BOOTCHART_POLLING_MS;
        if (bootchart_step() &lt; 0 || --bootchart_count == 0) {
            bootchart_finish();
            bootchart_count = 0;
        }
    }
#endif

    // 轮询注册的事件，超时则continue
    nr = poll(ufds, fd_count, timeout);
    if (nr &lt;= 0)
        continue;

    
    if (ufds[2].revents == POLLIN) {
        /* we got a SIGCHLD - reap and restart as needed */
        read(signal_recv_fd, tmp, sizeof(tmp));
        while (!wait_for_one_process(0))
            ;
        continue;
    }

    // 处理device事件
    if (ufds[0].revents == POLLIN)
        handle_device_fd(device_fd);
        
    // 处理设置系统属性的请求
    if (ufds[1].revents == POLLIN)
        handle_property_set_fd(property_set_fd);
        
    // 处理处理调试模式下的组合按键
    if (ufds[3].revents == POLLIN)
        handle_keychord(keychord_fd);
}
</pre>

<h1 id="toc_2">参考代码</h1>
<ul>
<li>
<a href="init进程参考代码.html">init进程参考代码</a>
</li>
</ul>
<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

<!--<script type="text/javascript">-->
<!--var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");-->
<!--document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));-->
<!--</script>-->
<!--<script type="text/javascript">-->
<!--try {-->
<!--var pageTracker = _gat._getTracker("UA-15922433-1");-->
<!--pageTracker._trackPageview();-->
<!--} catch(err) {}-->
<!--</script>-->

</body>
</html>
