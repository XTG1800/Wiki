<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>SurfaceFlinger工作线程</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
	<link type="text/css" rel="stylesheet" href="css_style/style_zenki.css"/>

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>


<h1 id="toc_1">SurfaceFlinger工作线程</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">SurfaceFlinger工作线程</a></li>
<ul>
<li><a href="#toc_1.1">概述</a></li>
<li><a href="#toc_1.2">渲染线程</a></li>
<ul>
<li><a href="#toc_1.2.1">SurfaceFlinger::threadLoop</a></li>
</ul>
<li><a href="#toc_1.3">状态变化处理</a></li>
<ul>
<li><a href="#toc_1.3.1">SurfaceFlinger::handleTransaction</a></li>
<li><a href="#toc_1.3.2">SurfaceFlinger::handleTransactionLocked</a></li>
</ul>
<li><a href="#toc_1.4">翻转处理</a></li>
<ul>
<li><a href="#toc_1.4.1">SurfaceFlinger::handlePageFlip</a></li>
<li><a href="#toc_1.4.2">SurfaceFlinger::lockPageFlip</a></li>
<li><a href="#toc_1.4.3">Layer::lockPageFlip</a></li>
<li><a href="#toc_1.4.4">SurfaceFlinger::unlockPageFlip</a></li>
<li><a href="#toc_1.4.5">Layer::unlockPageFlip</a></li>
</ul>
<li><a href="#toc_1.5">重画处理</a></li>
<ul>
<li><a href="#toc_1.5.1">SurfaceFlinger::handleRepaint</a></li>
<li><a href="#toc_1.5.2">SurfaceFlinger::composeSurfaces</a></li>
</ul>
<li><a href="#toc_1.6">刷新显示</a></li>
<ul>
<li><a href="#toc_1.6.1">SurfaceFlinger::postFramebuffer</a></li>
</ul>
<li><a href="#toc_1.7">Client/Server的通知机制</a></li>
<ul>
<li><a href="#toc_1.7.1">Surface::queueBuffer</a></li>
<li><a href="#toc_1.7.2">SurfaceFlinger::signal</a></li>
<li><a href="#toc_1.7.3">SurfaceFlinger::signalEvent</a></li>
<li><a href="#toc_1.7.4">SurfaceFlinger::waitForEvent</a></li>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">概述</h2>
<ul>
<li>
SurfaceFlinger继承了Thread类，自然也继承了Thread类的threadLoop方法，SurfaceFlinger工作线程的主代码都在threadLoop()方法中。
</li>
<li>
工作线程启动后，基类Thread会循环地调用threadLoop方法，SurfaceFlinger的 threadLoop()主要是要完成系统中各个Layer(Surface)进行混合(compose)，然后不停地把一帧帧混合好的图像数据传送到显示设备中。
</li>
</ul>

<p>
<a href="pic/thread_loop.png"><img src="pic/thread_loop.png" /></a>
</p>

<h2 id="toc_1.2">渲染线程</h2>
<h3 id="toc_1.2.1">SurfaceFlinger::threadLoop</h3>
<pre class="brush:c++">
bool SurfaceFlinger::threadLoop()
{
    waitForEvent();

    // check for transactions
    if (UNLIKELY(mConsoleSignals)) {
        handleConsoleEvents();
    }

    if (LIKELY(mTransactionCount == 0)) {
        // if we're in a global transaction, don't do anything.
        const uint32_t mask = eTransactionNeeded | eTraversalNeeded;
        uint32_t transactionFlags = getTransactionFlags(mask);
        if (LIKELY(transactionFlags)) {
            handleTransaction(transactionFlags);
        }
    }
    
    // post surfaces (if needed)
    handlePageFlip();

    const DisplayHardware&amp; hw(graphicPlane(0).displayHardware());
    if (LIKELY(hw.canDraw() &amp;&amp; !isFrozen())) {
        ......
        // repaint the framebuffer (if needed)
        const int index = hw.getCurrentBufferIndex();
        GraphicLog&amp; logger(GraphicLog::getInstance());
        handleRepaint();

        // inform the h/w that we're done compositing
        hw.compositionComplete();
        postFramebuffer();
    } else {
        // pretend we did the post
        hw.compositionComplete();
        usleep(16667); // 60 fps period
    }
    return true;
}
</pre>

<h2 id="toc_1.3">状态变化处理</h2>
<ul>
<li>
因为Layer的混合是在线程中进行的，而混合的过程中，应用程序或者系统可能会改变Layer的状态，例如屏幕旋转、增加或删除Layer、某个Layer可见或不可见，为了使这些变动不会破坏当前正在进行的混合动作，SurfaceFlinger维护着两个Layer列表：
</li>
<ul>
<li>
mCurrentState.layersSortedByZ  ---- 当前系统最新的Layer列表
</li>
<li>
mDrawingState.layersSortedByZ  ---- 本次混合操作使用的Layer列表
</li>
</ul>
<li>
handleTransaction就是根据Layer列表的这些状态的变化，计算是否有可见区域内需要更新，并设置状态变量mVisibleRegionsDirty，然后把mCurrentState赋值给mDrawingState，最后释放已经被丢弃的Layer
</li>
<ul>
<li>
上一次混合过程中，可能应用程序释放了一个Layer，可是mDrawingState正在使用，不能马上销毁，所以要等到本次混合前才能做出销毁的动作。
</li>
<li>
如果Layer的大小有变化并且可见，Layer的handleTransaction将会重新分配缓冲区，并且冻结SurfaceFlinger后续的混合操作，也就是屏幕的内容本次将不会刷新，直到下一个循环的handlePageFlip阶段才解除冻结。
</li>
</ul>
</ul>

<h3 id="toc_1.3.1">SurfaceFlinger::handleTransaction</h3>
<pre class="brush:c++">
void SurfaceFlinger::handleTransaction(uint32_t transactionFlags)
{
    Vector&lt; sp&lt;LayerBase&gt; &gt; ditchedLayers;

    { 
        ......
        // 调用handleTransactionLocked
        handleTransactionLocked(transactionFlags, ditchedLayers);
        ......
    }

    // 销毁不需要显示的Layer
    const size_t count = ditchedLayers.size();
    for (size_t i=0 ; i&lt;count ; i++) {
        if (ditchedLayers[i] != 0) {
            ditchedLayers[i]-&gt;ditch();
        }
    }
}
</pre>

<h3 id="toc_1.3.2">SurfaceFlinger::handleTransactionLocked</h3>
<pre class="brush:c++">
void SurfaceFlinger::handleTransactionLocked(
        uint32_t transactionFlags, Vector&lt; sp&lt;LayerBase&gt; &gt;&amp; ditchedLayers)
{
    const LayerVector&amp; currentLayers(mCurrentState.layersSortedByZ);
    const size_t count = currentLayers.size();

    const bool layersNeedTransaction = transactionFlags &amp; eTraversalNeeded;
    if (layersNeedTransaction) {
        for (size_t i=0 ; i&lt;count ; i++) {
            const sp&lt;LayerBase&gt;&amp; layer = currentLayers[i];
            uint32_t trFlags = layer-&gt;getTransactionFlags(eTransactionNeeded);
            // 不需要更新则continue
            if (!trFlags) continue;

            // 需要更新则调用Layer::doTransaction，并设置mVisibleRegionsDirty为true
            const uint32_t flags = layer-&gt;doTransaction(0);
            if (flags &amp; Layer::eVisibleRegion)
                mVisibleRegionsDirty = true;
        }
    }

    if (transactionFlags &amp; eTransactionNeeded) {
        // 如果布局变化，则重新计算更新范围并刷新
        if (mCurrentState.orientation != mDrawingState.orientation) {
            const int dpy = 0;
            const int orientation = mCurrentState.orientation;
            const uint32_t type = mCurrentState.orientationType;
            GraphicPlane&amp; plane(graphicPlane(dpy));
            plane.setOrientation(orientation);

            // update the shared control block
            const DisplayHardware&amp; hw(plane.displayHardware());
            volatile display_cblk_t* dcblk = mServerCblk-&gt;displays + dpy;
            dcblk-&gt;orientation = orientation;
            dcblk-&gt;w = plane.getWidth();
            dcblk-&gt;h = plane.getHeight();

            mVisibleRegionsDirty = true;
            mDirtyRegion.set(hw.bounds());
        }

        if (mCurrentState.freezeDisplay != mDrawingState.freezeDisplay) {
            mFreezeDisplay = mCurrentState.freezeDisplay;
            if (mFreezeDisplay)
                 mFreezeDisplayTime = 0;
        }

        if (currentLayers.size() &gt; mDrawingState.layersSortedByZ.size()) {
            mVisibleRegionsDirty = true;
        }

        if (mLayersRemoved) {
            mLayersRemoved = false;
            mVisibleRegionsDirty = true;
            const LayerVector&amp; previousLayers(mDrawingState.layersSortedByZ);
            const size_t count = previousLayers.size();
            for (size_t i=0 ; i&lt;count ; i++) {
                const sp&lt;LayerBase&gt;&amp; layer(previousLayers[i]);
                if (currentLayers.indexOf( layer ) &lt; 0) {
                    // 将需要丢弃的Layer加入到容器返回给调用者
                    ditchedLayers.add(layer);
                    mDirtyRegionRemovedLayer.orSelf(layer-&gt;visibleRegionScreen);
                }
            }
        }
    }

    commitTransaction();
}
</pre>

<h2 id="toc_1.4">翻转处理</h2>
<ul>
<li>
该阶段会遍历各个Layer，在每个Layer中，取得并锁住该Layer的frontBuffer，然后利用frontBuffer中的图像数据生成该Layer的2D贴图(Texture)，并且计算更新区域，为后续的混合操作做准备。
</li>
<li>
Layer::lockPageFlip()首先通过SharedBufferServer类的成员变量lcblk，调用retireAndLock取得该Layer当前可用的frontBuffer，然后通过 reloadTexture方法生成openGLES的纹理贴图，最后通过unlockPageFlip完成更新区域的Layer坐标到屏幕坐标的变换。
</li>
</ul>

<h3 id="toc_1.4.1">SurfaceFlinger::handlePageFlip</h3>
<pre class="brush:c++">
void SurfaceFlinger::handlePageFlip()
{
    bool visibleRegions = mVisibleRegionsDirty;
    LayerVector&amp; currentLayers = const_cast&lt;LayerVector&amp;&gt;(
            mDrawingState.layersSortedByZ);
    // 处理每一个Layer
    visibleRegions |= lockPageFlip(currentLayers);

    const DisplayHardware&amp; hw = graphicPlane(0).displayHardware();
    const Region screenRegion(hw.bounds());
    if (visibleRegions) {
        Region opaqueRegion;
        computeVisibleRegions(currentLayers, mDirtyRegion, opaqueRegion);

        mVisibleLayersSortedByZ.clear();
        const LayerVector&amp; currentLayers(mDrawingState.layersSortedByZ);
        size_t count = currentLayers.size();
        mVisibleLayersSortedByZ.setCapacity(count);
        for (size_t i=0 ; i&lt;count ; i++) {
            if (!currentLayers[i]-&gt;visibleRegionScreen.isEmpty())
                mVisibleLayersSortedByZ.add(currentLayers[i]);
        }

#ifdef USE_COMPOSITION_BYPASS
            sp&lt;LayerBase&gt; bypassLayer;
            const size_t numVisibleLayers = mVisibleLayersSortedByZ.size();
            if (numVisibleLayers == 1) {
                const sp&lt;LayerBase&gt;&amp; candidate(mVisibleLayersSortedByZ[0]);
                const Region&amp; visibleRegion(candidate-&gt;visibleRegionScreen);
                const Region reminder(screenRegion.subtract(visibleRegion));
                if (reminder.isEmpty()) {
                    // fullscreen candidate!
                    bypassLayer = candidate;
                }
            }
            setBypassLayer(bypassLayer);
#endif
            mWormholeRegion = screenRegion.subtract(opaqueRegion);
            mVisibleRegionsDirty = false;
        }
    unlockPageFlip(currentLayers);
    mDirtyRegion.andSelf(screenRegion);
}
</pre>

<h3 id="toc_1.4.2">SurfaceFlinger::lockPageFlip</h3>
<pre class="brush:c++">
bool SurfaceFlinger::lockPageFlip(const LayerVector&amp; currentLayers)
{
    bool recomputeVisibleRegions = false;
    size_t count = currentLayers.size();
    sp&lt;LayerBase&gt; const* layers = currentLayers.array();
    for (size_t i=0 ; i&lt;count ; i++) {
        const sp&lt;LayerBase&gt;&amp; layer(layers[i]);
        layer-&gt;lockPageFlip(recomputeVisibleRegions);
    }
    return recomputeVisibleRegions;
}
</pre>

<h3 id="toc_1.4.3">Layer::lockPageFlip</h3>
<p>
<a href="pic/handle_page_flip.png"><img src="pic/handle_page_flip.png" /></a>
</p>

<pre class="brush:c++">
void Layer::lockPageFlip(bool&amp; recomputeVisibleRegions)
{
    ClientRef::Access sharedClient(mUserClientRef);
    SharedBufferServer* lcblk(sharedClient.get());
    if (!lcblk) {
        // client died
        recomputeVisibleRegions = true;
        return;
    }

    // 获取当前可用的buffer，如果没有可用buffer则返回
    ssize_t buf = lcblk-&gt;retireAndLock();
    if (buf == NOT_ENOUGH_DATA) {
        return;
    }

    ...... 
    // 创建可用的frontBuffer
    sp&lt;GraphicBuffer&gt; newFrontBuffer(getBuffer(buf));
    if (newFrontBuffer != NULL) {
        // get the dirty region
        // compute the posted region
        const Region dirty(lcblk-&gt;getDirtyRegion(buf));
        mPostedDirtyRegion = dirty.intersect( newFrontBuffer-&gt;getBounds() );

        // update the layer size and release freeze-lock
        const Layer::State&amp; front(drawingState());
        if (newFrontBuffer-&gt;getWidth()  == front.requested_w &amp;&amp;
            newFrontBuffer-&gt;getHeight() == front.requested_h)
        {
            if ((front.w != front.requested_w) ||
                (front.h != front.requested_h))
            {
                // Here we pretend the transaction happened by updating the
                // current and drawing states. Drawing state is only accessed
                // in this thread, no need to have it locked
                Layer::State&amp; editDraw(mDrawingState);
                editDraw.w = editDraw.requested_w;
                editDraw.h = editDraw.requested_h;

                // We also need to update the current state so that we don't
                // end-up doing too much work during the next transaction.
                // NOTE: We actually don't need hold the transaction lock here
                // because State::w and State::h are only accessed from
                // this thread
                Layer::State&amp; editTemp(currentState());
                editTemp.w = editDraw.w;
                editTemp.h = editDraw.h;

                // recompute visible region
                recomputeVisibleRegions = true;
            }

            // we now have the correct size, unfreeze the screen
            mFreezeLock.clear();
        }

        // get the crop region
        setBufferCrop( lcblk-&gt;getCrop(buf) );
        // get the transformation
        setBufferTransform( lcblk-&gt;getTransform(buf) );
    } else {
        // this should not happen unless we ran out of memory while
        // allocating the buffer. we're hoping that things will get back
        // to normal the next time the app tries to draw into this buffer.
        // meanwhile, pretend the screen didn't update.
        mPostedDirtyRegion.clear();
    }

    if (lcblk-&gt;getQueuedCount()) {
        // signal an event if we have more buffers waiting
        mFlinger-&gt;signalEvent();
    }

    /* a buffer was posted, so we need to call reloadTexture(), which
     * will update our internal data structures (eg: EGLImageKHR or
     * texture names). we need to do this even if mPostedDirtyRegion is
     * empty -- it's orthogonal to the fact that a new buffer was posted,
     * for instance, a degenerate case could be that the user did an empty
     * update but repainted the buffer with appropriate content (after a
     * resize for instance).
     */
    reloadTexture( mPostedDirtyRegion );
}
</pre>

<h3 id="toc_1.4.4">SurfaceFlinger::unlockPageFlip</h3>
<pre class="brush:c++">
void SurfaceFlinger::unlockPageFlip(const LayerVector&amp; currentLayers)
{
    const GraphicPlane&amp; plane(graphicPlane(0));
    const Transform&amp; planeTransform(plane.transform());
    size_t count = currentLayers.size();
    sp&lt;LayerBase&gt; const* layers = currentLayers.array();
    for (size_t i=0 ; i&lt;count ; i++) {
        const sp&lt;LayerBase&gt;&amp; layer(layers[i]);
        layer-&gt;unlockPageFlip(planeTransform, mDirtyRegion);
    }
}
</pre>

<h3 id="toc_1.4.5">Layer::unlockPageFlip</h3>
<pre class="brush:c++">
void Layer::unlockPageFlip(
        const Transform&amp; planeTransform, Region&amp; outDirtyRegion)
{
    Region dirtyRegion(mPostedDirtyRegion);
    if (!dirtyRegion.isEmpty()) {
        mPostedDirtyRegion.clear();
        // The dirty region is given in the layer's coordinate space
        // transform the dirty region by the surface's transformation
        // and the global transformation.
        const Layer::State&amp; s(drawingState());
        const Transform tr(planeTransform * s.transform);
        dirtyRegion = tr.transform(dirtyRegion);

        // At this point, the dirty region is in screen space.
        // Make sure it's constrained by the visible region (which
        // is in screen space as well).
        dirtyRegion.andSelf(visibleRegionScreen);
        outDirtyRegion.orSelf(dirtyRegion);
    }
    if (visibleRegionScreen.isEmpty()) {
        // an invisible layer should not hold a freeze-lock
        // (because it may never be updated and therefore never release it)
        mFreezeLock.clear();
    }
}
</pre>

<h2 id="toc_1.5">重画处理</h2>
<ul>
<li>
handleRepaint首先重置了openGL的观察矩阵，然后遍历mDrawingState.layersSortedByZ 中的Layer列表，调用每个Layer的onDraw方法，在onDraw方法中，会调用drawWithOpenGL()方法，将在handlePageFlip阶段生成的贴图混合到OpenGL的主表面，最后handleRepaint把需要刷新的区域清除。
</li>
</ul>

<p>
<a href="pic/handle_repaint.png"><img src="pic/handle_repaint.png" /></a>
</p>

<h3 id="toc_1.5.1">SurfaceFlinger::handleRepaint</h3>
<pre class="brush:c++">
void SurfaceFlinger::handleRepaint()
{
    // compute the invalid region
    mInvalidRegion.orSelf(mDirtyRegion);
    if (mInvalidRegion.isEmpty()) {
        // nothing to do
        return;
    }

    ......
    // 设置OpenGL 
    const DisplayHardware&amp; hw(graphicPlane(0).displayHardware());
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    uint32_t flags = hw.getFlags();
    if ((flags &amp; DisplayHardware::SWAP_RECTANGLE) || 
        (flags &amp; DisplayHardware::BUFFER_PRESERVED)) 
    {
        // we can redraw only what's dirty, but since SWAP_RECTANGLE only
        // takes a rectangle, we must make sure to update that whole
        // rectangle in that case
        if (flags &amp; DisplayHardware::SWAP_RECTANGLE) {
            // TODO: we really should be able to pass a region to
            // SWAP_RECTANGLE so that we don't have to redraw all this.
            mDirtyRegion.set(mInvalidRegion.bounds());
        } else {
            // in the BUFFER_PRESERVED case, obviously, we can update only
            // what's needed and nothing more.
            // NOTE: this is NOT a common case, as preserving the backbuffer
            // is costly and usually involves copying the whole update back.
        }
    } else {
        if (flags &amp; DisplayHardware::PARTIAL_UPDATES) {
            // We need to redraw the rectangle that will be updated
            // (pushed to the framebuffer).
            // This is needed because PARTIAL_UPDATES only takes one
            // rectangle instead of a region (see DisplayHardware::flip())
            mDirtyRegion.set(mInvalidRegion.bounds());
        } else {
            // we need to redraw everything (the whole screen)
            mDirtyRegion.set(hw.bounds());
            mInvalidRegion = mDirtyRegion;
        }
    }
    
    if(mDirtyRegion.bounds().right==hw.bounds().bottom)
    {
        mDirtyRegion.set(hw.bounds());
        mInvalidRegion = mDirtyRegion;
    }
    
    // compose all surfaces
    composeSurfaces(mDirtyRegion);

    // clear the dirty regions
    mDirtyRegion.clear();
}
</pre>

<h3 id="toc_1.5.2">SurfaceFlinger::composeSurfaces</h3>
<pre class="brush:c++">
void SurfaceFlinger::composeSurfaces(const Region&amp; dirty)
{
    if (UNLIKELY(!mWormholeRegion.isEmpty())) {
        // should never happen unless the window manager has a bug
        // draw something...
        drawWormhole();
    }
    const Vector&lt; sp&lt;LayerBase&gt; &gt;&amp; layers(mVisibleLayersSortedByZ);
    const size_t count = layers.size();
    for (size_t i=0 ; i&lt;count ; ++i) {
        const sp&lt;LayerBase&gt;&amp; layer(layers[i]);
        const Region clip(dirty.intersect(layer-&gt;visibleRegionScreen));
        if (!clip.isEmpty()) {
            layer-&gt;draw(clip);
        }
    }
}
</pre>

<h2 id="toc_1.6">刷新显示</h2>
<h3 id="toc_1.6.1">SurfaceFlinger::postFramebuffer</h3>
<pre class="brush:c++">
void SurfaceFlinger::postFramebuffer()
{
    if (!mInvalidRegion.isEmpty()) {
        const DisplayHardware&amp; hw(graphicPlane(0).displayHardware());
        ......
        // 调用HAL层俄flip刷新屏幕
        hw.flip(mInvalidRegion);
        ......
        mInvalidRegion.clear();
    }
}
</pre>

<h2 id="toc_1.7">Client/Server的通知机制</h2>
<ul>
<li>
前面提到Surface在解锁缓冲区后，会调用SurfaceClient::signalServer方法通知SurfaceFlinger。而该调用是通过其成员ISurfaceComposer接口对象通过Binder机制调用SurfaceFlinger端的signalServer方法。
</li>
<li>
SurfaceFlinger内部会维护一个消息队列，waitForEvent会循环等待消息到来，其实是在条件变量上等待被唤醒。
</li>
<li>
当waitForEvent返回后，SurfaceFlinger则继续走threadLoop的调用流程。
</li>
</ul>

<h3 id="toc_1.7.1">Surface::queueBuffer</h3>
<pre class="brush:c++">
int Surface::queueBuffer(android_native_buffer_t* buffer)
{
    ......
    if (err == NO_ERROR) {
        mClient.signalServer();
    }
    return err;
}
</pre>

<h3 id="toc_1.7.2">SurfaceFlinger::signal</h3>
<pre class="brush:c++">
void SurfaceFlinger::signal() const {
    // 通过Binder的IPC调用SurfaceFlinger::signal
    const_cast&lt;SurfaceFlinger*&gt;(this)-&gt;signalEvent();
}
</pre>

<h3 id="toc_1.7.3">SurfaceFlinger::signalEvent</h3>
<pre class="brush:c++">
void SurfaceFlinger::signalEvent() {
    // 触发条件变量，让waitForEvent返回消息
    mEventQueue.invalidate();
}
</pre>

<h3 id="toc_1.7.4">SurfaceFlinger::waitForEvent</h3>
<pre class="brush:c++">
void SurfaceFlinger::waitForEvent()
{
    while (true) {
        ...... 
        sp&lt;MessageBase&gt; msg = mEventQueue.waitMessage(timeout);

        ...... 
        if (msg != 0) {
            switch (msg-&gt;what) {
                case MessageQueue::INVALIDATE:
                    // invalidate message, just return to the main loop
                    return;
            }
        }
    }
}
</pre>
<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

<!--<script type="text/javascript">-->
<!--var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");-->
<!--document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));-->
<!--</script>-->
<!--<script type="text/javascript">-->
<!--try {-->
<!--var pageTracker = _gat._getTracker("UA-15922433-1");-->
<!--pageTracker._trackPageview();-->
<!--} catch(err) {}-->
<!--</script>-->

</body>
</html>
