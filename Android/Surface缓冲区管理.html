<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Surface缓冲区管理</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
	<link type="text/css" rel="stylesheet" href="css_style/style_zenki.css"/>

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>


<h1 id="toc_1">缓冲区管理</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">缓冲区管理</a></li>
<ul>
<li><a href="#toc_1.1">概述</a></li>
<li><a href="#toc_1.2">缓冲区的建立</a></li>
<ul>
<li><a href="#toc_1.2.1">第一阶段</a></li>
<ul>
<li><a href="#toc_1.2.1.1">Surface::Surface</a></li>
<li><a href="#toc_1.2.1.2">SurfaceClient</a></li>
<li><a href="#toc_1.2.1.3">SurfaceFlinger::createClientConnection</a></li>
<li><a href="#toc_1.2.1.4">UserClient::UserClient</a></li>
<li><a href="#toc_1.2.1.5">UserClient::getControlBlock</a></li>
</ul>
<li><a href="#toc_1.2.2">第二阶段</a></li>
<ul>
<li><a href="#toc_1.2.2.1">Surface::init</a></li>
<li><a href="#toc_1.2.2.2">UserClient::getTokenForSurface</a></li>
<li><a href="#toc_1.2.2.3">Layer::setToken</a></li>
<li><a href="#toc_1.2.2.4">SharedClient</a></li>
<li><a href="#toc_1.2.2.5">SharedBufferClient</a></li>
<li><a href="#toc_1.2.2.6">SharedBufferServer</a></li>
</ul>
</ul>
<li><a href="#toc_1.3">缓冲区堆栈</a></li>
<ul>
<li><a href="#toc_1.3.1">SharedBufferStack</a></li>
</ul>
<li><a href="#toc_1.4">缓冲区操作</a></li>
<ul>
<li><a href="#toc_1.4.1">Surface::dequeueBuffer</a></li>
<li><a href="#toc_1.4.2">SharedBufferClient::dequeue</a></li>
<li><a href="#toc_1.4.3">Surface::queueBuffer</a></li>
<li><a href="#toc_1.4.4">SharedBufferClient::queue</a></li>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">概述</h2>
<ul>
<li>
从<a href="显示缓冲区的作用.html">显示缓冲区的作用</a>可以发现，Canvas绑定缓冲区时，要通过SharedBufferClient的dequeue方法取得空闲的缓冲区，而解除绑定并提交缓冲区投递时，最后也要调用SharedBufferClient的queue方法通知SurfaceFlinger的工作线程。
</li>
<li>
实际上，在SurfaceFlinger里，每个Layer也会关联一个SharedBufferServer，SurfaceFlinger的工作线程通过 SharedBufferServer管理着Layer的缓冲区，在SurfaceComposerClient建立连接的阶段，SurfaceFlinger就已经为该连接创建了一个SharedBufferServer对象。
</li>
<li>
SharedClient对象中包含了一个SharedBufferStack数组，数组的大小是31，每当创建一个Surface，就会占用数组中的一个 SharedBufferStack，然后SurfaceComposerClient端的Surface会创建一个SharedBufferClient和该SharedBufferStack关联，而SurfaceFlinger端的Layer也会创建 SharedBufferServer和SharedBufferStack关联，实际上每对SharedBufferClient/SharedBufferServer是控制着同一个SharedBufferStack对象，通过 SharedBufferStack，保证了负责对Surface的画图操作的应用端和负责刷新屏幕的服务端(SurfaceFlinger)可以使用不同的缓冲区，并且让他们之间知道对方何时锁定/释放缓冲区。
</li>
</ul>

<h2 id="toc_1.2">缓冲区的建立</h2>
<h3 id="toc_1.2.1">第一阶段</h3>
<ul>
<li>
Surface(C++层)在构造方法中会初始化SurfaceClient类型的变量mClient。
</li>
<ul>
<li>
SurfaceClient构造方法会通过ISurfaceComposer接口的createClientConnection方法创建SurfaceFlinger端的<code>UserClient</code>对象。
</li>
<ul>
<li>
UserClient在构造方法中会初始化MemoryHeapBase类型的变量mCblkHeap。
</li>
</ul>
<li>
接下来使用mClient-&gt;getControlBlock()方法获取Server端上一步创建的mCblkHeap对象，并转换成对应的SharedClient对象。
</li>
</ul>
<li>
至此，在Surface初始化的第一阶段已经在SurfaceFlinger服务端创建了MemoryHeapBase，并通过Binder机制转换成Client端对应的SharedClient对象。这片内存是为了将来管理Layer对象的内存缓冲区。
</li>
</ul>


<h4 id="toc_1.2.1.1">Surface::Surface</h4>
<pre class="brush:c++">
Surface::Surface(const sp&lt;SurfaceControl&gt;&amp; surface)
    : mBufferMapper(GraphicBufferMapper::get()),
      mClient(SurfaceClient::getInstance()),    // 初始化SurfaceClient
      mSharedBufferClient(NULL),
      mInitCheck(NO_INIT),
      mSurface(surface-&gt;mSurface),
      mIdentity(surface-&gt;mIdentity),
      mFormat(surface-&gt;mFormat), mFlags(surface-&gt;mFlags),
      mWidth(surface-&gt;mWidth), mHeight(surface-&gt;mHeight)
{
    ......
    init();
}
</pre>

<h4 id="toc_1.2.1.2">SurfaceClient</h4>
<pre class="brush:c++">
class SurfaceClient : public Singleton&lt;SurfaceClient&gt;
{
    sp&lt;ISurfaceComposerClient&gt; mClient;
    ......

    SurfaceClient() : Singleton&lt;SurfaceClient&gt;(), mStatus(NO_INIT)
    {
        sp&lt;ISurfaceComposer&gt; sf(ComposerService::getComposerService());
        mComposerService = sf;
        // 从SurfaceFlinger创建UserClient对象
        mClient = sf-&gt;createClientConnection();
        if (mClient != NULL) {
            // 获得SurfaceFlinger服务端的内存对象并转换成SharedClient
            mControlMemory = mClient-&gt;getControlBlock();
            if (mControlMemory != NULL) {
                mControl = static_cast&lt;SharedClient *&gt;(
                        mControlMemory-&gt;getBase());
                if (mControl) {
                    mStatus = NO_ERROR;
                }
            }
        }
    }
    
    ......
public:
    SharedClient* getSharedClient() const {
        return mControl;
    }
    ssize_t getTokenForSurface(const sp&lt;ISurface&gt;&amp; sur) const {
        // TODO: we could cache a few tokens here to avoid an IPC
        return mClient-&gt;getTokenForSurface(sur);
    }
    ...... 
};
</pre>

<h4 id="toc_1.2.1.3">SurfaceFlinger::createClientConnection</h4>
<pre class="brush:c++">
sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createClientConnection()
{
    sp&lt;ISurfaceComposerClient&gt; bclient;
    sp&lt;UserClient&gt; client(new UserClient(this));
    status_t err = client-&gt;initCheck();
    if (err == NO_ERROR) {
        bclient = client;
    }
    return bclient;
}
</pre>

<h4 id="toc_1.2.1.4">UserClient::UserClient</h4>
<pre class="brush:c++">
UserClient::UserClient(const sp&lt;SurfaceFlinger&gt;&amp; flinger)
    : ctrlblk(0), mBitmap(0), mFlinger(flinger)
{
    const int pgsize = getpagesize();
    const int cblksize = ((sizeof(SharedClient)+(pgsize-1))&amp;~(pgsize-1));

    // 创建MemoryHeapBase对象
    mCblkHeap = new MemoryHeapBase(cblksize, 0,
            "SurfaceFlinger Client control-block");

    ctrlblk = static_cast&lt;SharedClient *&gt;(mCblkHeap-&gt;getBase());
    if (ctrlblk) { // construct the shared structure in-place.
        new(ctrlblk) SharedClient;
    }
}
</pre>

<h4 id="toc_1.2.1.5">UserClient::getControlBlock</h4>
<pre class="brush:c++">
sp&lt;IMemoryHeap&gt; UserClient::getControlBlock() const {
    return mCblkHeap;
}
</pre>

<h3 id="toc_1.2.2">第二阶段</h3>
<ul>
<li>
这个阶段是在Surface的构造函数的方法块中，会调用init方法，mClient.getTokenForSurface是通过Binder调用UserClient::getTokenForSurface方法(第一阶段在SurfaceFlinger端创建的)。
</li>
<ul>
<li>
该方法会调用Layer::getToken方法，实际是创建SharedBufferServer对象。
</li>
<li>
如果创建成功，则会以该对象句柄和第一阶段创建的SharedClient对象为参数，构造一个SharedBufferClient对象与之相对应。
</li>
</ul>
<li>
至此Client端和Server是分别通过SharedBufferClient和SharedBufferServer来维护各自的缓冲区，但是这些缓冲区都是构建于token这个索引，该索引就是SharedClient中的SharedBufferStack数组的索引。所以管理这些缓冲区的堆栈只有一个，即SharedBufferStack。
</li>
</ul>

<h4 id="toc_1.2.2.1">Surface::init</h4>
<pre class="brush:c++">
void Surface::init()
{
    ......
    if (mSurface != 0 &amp;&amp; mClient.initCheck() == NO_ERROR) {
        // 获得对应Server端的缓冲区句柄
        int32_t token = mClient.getTokenForSurface(mSurface);
        if (token &gt;= 0) {
            // 初始化SharedBufferClient对象
            mSharedBufferClient = new SharedBufferClient(
                    mClient.getSharedClient(), token, 2, mIdentity);
            mInitCheck = mClient.getSharedClient()-&gt;validate(token);
        }
    }
}
</pre>

<h4 id="toc_1.2.2.2">UserClient::getTokenForSurface</h4>
<pre class="brush:c++">
ssize_t UserClient::getTokenForSurface(const sp&lt;ISurface&gt;&amp; sur) const
{
    int32_t name = NAME_NOT_FOUND;
    sp&lt;Layer&gt; layer(mFlinger-&gt;getLayer(sur));
    if (layer == 0) return name;

    // if this layer already has a token, just return it
    name = layer-&gt;getToken();
    if ((name &gt;= 0) &amp;&amp; (layer-&gt;getClient() == this))
        return name;

    name = 0;
    do {
        int32_t mask = 1LU&lt;&lt;name;
        if ((android_atomic_or(mask, &amp;mBitmap) &amp; mask) == 0) {
            // we found and locked that name
            status_t err = layer-&gt;setToken(
                    const_cast&lt;UserClient*&gt;(this), ctrlblk, name);
            if (err != NO_ERROR) {
                // free the name
                android_atomic_and(~mask, &amp;mBitmap);
                name = err;
            }
            break;
        }
        if (++name &gt;= SharedBufferStack::NUM_LAYERS_MAX)
            name = NO_MEMORY;
    } while(name &gt;= 0);

    return name;
}
</pre>

<h4 id="toc_1.2.2.3">Layer::setToken</h4>
<pre class="brush:c++">
status_t Layer::setToken(const sp&lt;UserClient&gt;&amp; userClient,
        SharedClient* sharedClient, int32_t token)
{
    // 创建SharedBufferServer
    sp&lt;SharedBufferServer&gt; lcblk = new SharedBufferServer(
            sharedClient, token, mBufferManager.getDefaultBufferCount(),
            getIdentity());

    // 保存在ClientRef中
    status_t err = mUserClientRef.setToken(userClient, lcblk, token);
    ......

    return err;
}
</pre>

<h4 id="toc_1.2.2.4">SharedClient</h4>
<pre class="brush:c++">
class SharedClient
{
public:
    SharedClient();
    ~SharedClient();
    status_t validate(size_t token) const;

private:
    friend class SharedBufferBase;
    friend class SharedBufferClient;
    friend class SharedBufferServer;

    // 用来锁定共享的内存
    Mutex lock;
    Condition cv;
    // NUM_LAYERS_MAX = 31
    SharedBufferStack surfaces[ SharedBufferStack::NUM_LAYERS_MAX ];
};
</pre>

<h4 id="toc_1.2.2.5">SharedBufferClient</h4>
<pre class="brush:c++">
class SharedBufferClient : public SharedBufferBase
{
public:
    ......
    ssize_t dequeue();
    status_t undoDequeue(int buf);
    
    status_t lock(int buf);
    status_t cancel(int buf);
    status_t queue(int buf);
    bool needNewBuffer(int buffer) const;
    status_t setDirtyRegion(int buffer, const Region&amp; reg);
    status_t setCrop(int buffer, const Rect&amp; reg);
    status_t setTransform(int buffer, uint32_t transform);

    class SetBufferCountCallback {
        friend class SharedBufferClient;
        virtual status_t operator()(int bufferCount) const = 0;
    protected:
        virtual ~SetBufferCountCallback() { }
    };
    status_t setBufferCount(int bufferCount, const SetBufferCountCallback&amp; ipc);
    ......
};
</pre>

<h4 id="toc_1.2.2.6">SharedBufferServer</h4>
<pre class="brush:c++">
class SharedBufferServer
    : public SharedBufferBase,
      public LightRefBase&lt;SharedBufferServer&gt;
{
public:
    ......
    ssize_t retireAndLock();
    void setStatus(status_t status);
    status_t reallocateAll();
    status_t reallocateAllExcept(int buffer);
    int32_t getQueuedCount() const;
    Region getDirtyRegion(int buffer) const;
    Rect getCrop(int buffer) const;
    uint32_t getTransform(int buffer) const;

    status_t resize(int newNumBuffers);

    SharedBufferStack::Statistics getStats() const;
    ...... 
</pre>

<h2 id="toc_1.3">缓冲区堆栈</h2>
<ul>
<li>
前一章已经分析了创建客户端创建Surface其实是在SurfaceFlinger端创建Layer对象。在SharedClient类中我们可以看见SharedBufferStack成员变量，它用来维护Layer对象的堆栈。
</li>
<ul>
<li>
每次获取Surface时，会通过UserClient::getTokenForSurface方法查找对应的索引，如果没有找到，就会递增这个索引值并保证不会超过SharedBufferStack::NUM_LAYERS_MAX定义的大小，最后通过Layer::setToken方法创建SharedBufferServer对象。
</li>
<li>
而这个索引值通过ClientRef::setToken保存在ClientRef对象中，当下一次再访问这个Layer对象时便会通过ClientRef::getToken获取。Client端便是通过该索引构造一个SharedBufferClient对象与Server端对应。
</li>
</ul>
</ul>

<p>
<a href="pic/shared_buffer_stack.png"><img src="pic/shared_buffer_stack.png" /></a>
</p>

<h3 id="toc_1.3.1">SharedBufferStack</h3>
<pre class="brush:c++">
class SharedBufferStack
{
    friend class SharedClient;
    friend class SharedBufferBase;
    friend class SharedBufferClient;
    friend class SharedBufferServer;

public:
    // 最大Layer
    static const unsigned int NUM_LAYERS_MAX  = 31;
    // 最大buffer
    static const unsigned int NUM_BUFFER_MAX  = 16;
    // 最小buffer
    static const unsigned int NUM_BUFFER_MIN  = 2;
    // 最大显示
    static const unsigned int NUM_DISPLAY_MAX = 4;

    ...... 
    SharedBufferStack();
    void init(int32_t identity);
    status_t setDirtyRegion(int buffer, const Region&amp; reg);
    status_t setCrop(int buffer, const Rect&amp; reg);
    status_t setTransform(int buffer, uint8_t transform);
    Region getDirtyRegion(int buffer) const;
    Rect getCrop(int buffer) const;
    uint32_t getTransform(int buffer) const;
    ...... 
};
</pre>

<h2 id="toc_1.4">缓冲区操作</h2>

<h3 id="toc_1.4.1">Surface::dequeueBuffer</h3>
<pre class="brush:c++">
int Surface::dequeueBuffer(android_native_buffer_t** buffer)
{
    ......
    ssize_t bufIdx = mSharedBufferClient-&gt;dequeue();
    
    ......
    if (err == NO_ERROR) {
        mDirtyRegion.set(backBuffer-&gt;width, backBuffer-&gt;height);
        *buffer = backBuffer.get();
    } else {
        mSharedBufferClient-&gt;undoDequeue(bufIdx);
    }

    return err;
}
</pre>

<h3 id="toc_1.4.2">SharedBufferClient::dequeue</h3>
<pre class="brush:c++">
ssize_t SharedBufferClient::dequeue()
{
    SharedBufferStack&amp; stack( *mSharedStack );

    ......
    DequeueCondition condition(this);
    status_t err = waitForCondition(condition);
    
    ......
    DequeueUpdate update(this);
    updateCondition( update );

    ......
    return dequeued;
}
</pre>

<h3 id="toc_1.4.3">Surface::queueBuffer</h3>
<pre class="brush:c++">
int Surface::queueBuffer(android_native_buffer_t* buffer)
{
    ......
    mSharedBufferClient-&gt;setTransform(bufIdx, mNextBufferTransform);
    mSharedBufferClient-&gt;setCrop(bufIdx, mNextBufferCrop);
    mSharedBufferClient-&gt;setDirtyRegion(bufIdx, mDirtyRegion);
    err = mSharedBufferClient-&gt;queue(bufIdx);

    if (err == NO_ERROR) {
        mClient.signalServer();
    }
    return err;
}
</pre>

<h3 id="toc_1.4.4">SharedBufferClient::queue</h3>
<pre class="brush:c++">
status_t SharedBufferClient::queue(int buf)
{
    RWLock::AutoRLock _rd(mLock);

    SharedBufferStack&amp; stack( *mSharedStack );

    queued_head = (queued_head + 1) % mNumBuffers;
    stack.index[queued_head] = buf;

    QueueUpdate update(this);
    status_t err = updateCondition( update );

    const nsecs_t now = systemTime(SYSTEM_TIME_THREAD);
    stack.stats.totalTime = ns2us(now - mDequeueTime[buf]);
    return err;
}
</pre>
<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

<!--<script type="text/javascript">-->
<!--var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");-->
<!--document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));-->
<!--</script>-->
<!--<script type="text/javascript">-->
<!--try {-->
<!--var pageTracker = _gat._getTracker("UA-15922433-1");-->
<!--pageTracker._trackPageview();-->
<!--} catch(err) {}-->
<!--</script>-->

</body>
</html>
