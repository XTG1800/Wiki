<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>AudioPolicyService</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <link rel="Stylesheet" type="text/css" href="../css_style/style_zenki.css">

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>

<!-- wrap the vimwiki html -->

<h1 id="toc_1">AudioPolicyService</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">AudioPolicyService</a>
<ul>
<li><a href="#toc_1.1">概述</a>
<li><a href="#toc_1.2">接口描述</a>
<li><a href="#toc_1.3">实现AudioPolicyInterface</a>
<ul>
<li><a href="#toc_1.3.1">输入输出设备管理</a>
<li><a href="#toc_1.3.2">audio_io_handle_t</a>
<ul>
<li><a href="#toc_1.3.2.1">相关方法列表</a>
<li><a href="#toc_1.3.2.2">AudioPolicyManagerBase</a>
</ul>
</ul>
<li><a href="#toc_1.4">音量管理</a>
<ul>
<li><a href="#toc_1.4.1">音量值的定义</a>
</ul>
<li><a href="#toc_1.5">音频策略管理</a>
<ul>
<li><a href="#toc_1.5.1">AudioSystem::stream_type</a>
<li><a href="#toc_1.5.2">AudioSystem::audio_devices</a>
<li><a href="#toc_1.5.3">AudioPolicyManagerBase::routing_strategy</a>
<li><a href="#toc_1.5.4">AudioPolicyManagerBase::getStrategy</a>
<li><a href="#toc_1.5.5">AudioPolicyManagerBase::getDeviceForStrategy</a>
</ul>
<li><a href="#toc_1.6">音频控制线程(AudioCommandThread)</a>
<ul>
<li><a href="#toc_1.6.1">命令标识</a>
<li><a href="#toc_1.6.2">命令对应的数据结构</a>
<li><a href="#toc_1.6.3">AudioCommandThread::Command</a>
<li><a href="#toc_1.6.4">AudioCommandThread::threadLoop</a>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">概述</h2>
<ul>
<li>
AudioPolicyService主要完成以下任务：

<ul>
<li>
JAVA应用层通过JNI，经由IAudioPolicyService接口，访问AudioPolicyService提供的服务

<li>
输入输出设备的连接状态

<li>
系统的音频策略（strategy）的切换

<li>
音量/音频参数的设置

</ul>
</ul>

<h2 id="toc_1.2">接口描述</h2>
<ul>
<li>
AudioPolicyService继承了IAudioPolicyService接口，这样AudioPolicyService就可以基于 Android的Binder机制，向外部提供服务；

<li>
AudioPolicyService同时也继承了AudioPolicyClientInterface类，他有一个 AudioPolicyInterface类的成员指针mpPolicyManager，实际上就是指向了AudioPolicyManagerBase(Android 2.3中为AudioPolicyManagerBase类)；

<li>
AudioPolicyManagerBase类继承了AudioPolicyInterface类以便向AudioPolicyService提供服务，反过来同时还有一个AudioPolicyClientInterface指针，该指针在构造函数中被初始化，指向了AudioPolicyService，实际上，AudioPolicyService是通过成员指针mpPolicyManager访问AudioPolicyManagerBase，而 AudioPolicyManagerBase则通过AudioPolicyClientInterface（mpClientInterface）访问 AudioPolicyService；

<li>
AudioPolicyService有一个内部线程类AudioCommandThread，顾名思义，所有的命令（音量控制，输入、输出的切换等）最终都会在该线程中排队执行；

</ul>

<p>
<img src="http:pic/audio_policy_service.png" />
</p>

<h2 id="toc_1.3">实现AudioPolicyInterface</h2>
<ul>
<li>
AudioPolicyService的很大一部分管理工作都是通过AudioPolicyInterface完成的。包括音量管理，音频策略(strategy)管理，输入输出设备管理。而默认实现该接口的类是AudioPolicyManagerBase。对于特定的硬件，只要重新实现这个接口就可以类。

<li>
AudioPolicyInterface的实现类会通过AudioSystem接口去完成具体的功能实现。

<li>
为什么需要AudioPolicyInterface？实际上AudioPolicyInterface(C++)层和AudioPolicyService(C++层)会相互调用，而AudioPolicyInterface负责获取音频设置，而AudioPolicyService则负责将具体操作向下传递。

</ul>

<h3 id="toc_1.3.1">输入输出设备管理</h3>
<ul>
<li>
音频系统为音频设备定义了一个枚举：AudioSystem::audio_devices，例如：DEVICE_OUT_SPEAKER，DEVICE_OUT_WIRED_HEADPHONE，DEVICE_OUT_BLUETOOTH_A2DP，DEVICE_IN_BUILTIN_MIC，DEVICE_IN_VOICE_CALL 等等，每一个枚举值其实对应一个32bit整数的某一个位，所以这些值是可以进行位或操作的。

</ul>

<h3 id="toc_1.3.2">audio_io_handle_t</h3>
<ul>
<li>
AudioPolicyManagerBase需要获取称之为句柄的audio_io_handle_t对象，该句柄对应为AudioFlinger中的工作线程，可能是Track，也可能是Record。并且维护一个对应ID的容器对象，可以方便的获取相应句柄。

</ul>

<pre class="brush:c++">
audio_io_handle_t mHardwareOutput;          // hardware output handler
audio_io_handle_t mA2dpOutput;              // A2DP output handler
audio_io_handle_t mDuplicatedOutput;        // duplicated output handler: outputs to hardware and A2DP.
KeyedVector&lt;audio_io_handle_t, AudioOutputDescriptor *&gt; mOutputs;   // list of output descriptors
KeyedVector&lt;audio_io_handle_t, AudioInputDescriptor *&gt; mInputs;     // list of input descriptors
</pre>
<h4 id="toc_1.3.2.1">相关方法列表</h4>
<table>
<tr>
<th>
方法名
</th>
<th>
描述
</th>
<th>
备注
</th>
</tr>
<tr>
<td>
setPhoneState
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
setRingerMode
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
setForceUse
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
startOutput
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
stopOutput
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
startInput
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
stopInput
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>
</table>

<h4 id="toc_1.3.2.2">AudioPolicyManagerBase</h4>
<pre class="brush:c++">
AudioPolicyManagerBase::AudioPolicyManagerBase(AudioPolicyClientInterface *clientInterface)
    : mPhoneState(AudioSystem::MODE_NORMAL), mRingerMode(0),
    mMusicStopTime(0), mLimitRingtoneVolume(false), mLastVoiceVolume(-1.0f),
    mTotalEffectsCpuLoad(0), mTotalEffectsMemory(0),
    mA2dpSuspended(false)
{
    mpClientInterface = clientInterface;
    for (int i = 0; i &lt; AudioSystem::NUM_FORCE_USE; i++) {
        mForceUse[i] = AudioSystem::FORCE_NONE;
    }

    // 通过枚举值定义音频设备
    mAvailableOutputDevices = AudioSystem::DEVICE_OUT_EARPIECE |
                        AudioSystem::DEVICE_OUT_SPEAKER;
    mAvailableInputDevices = AudioSystem::DEVICE_IN_BUILTIN_MIC;
    
    ......
    // 打开输出设备
    AudioOutputDescriptor *outputDesc = new AudioOutputDescriptor();
    outputDesc-&gt;mDevice = (uint32_t)AudioSystem::DEVICE_OUT_SPEAKER;
    mHardwareOutput = mpClientInterface-&gt;openOutput(&amp;outputDesc-&gt;mDevice,
                                    &amp;outputDesc-&gt;mSamplingRate,
                                    &amp;outputDesc-&gt;mFormat,
                                    &amp;outputDesc-&gt;mChannels,
                                    &amp;outputDesc-&gt;mLatency,
                                    outputDesc-&gt;mFlags);

    // 设置device
    if (mHardwareOutput == 0) {
    } else {
        addOutput(mHardwareOutput, outputDesc);
        setOutputDevice(mHardwareOutput, (uint32_t)AudioSystem::DEVICE_OUT_SPEAKER, true);
    }

    updateDeviceForStrategy();
}
</pre>

<h2 id="toc_1.4">音量管理</h2>
<ul>
<li>
AudioPolicyManagerBase提供了以下几个与音量相关的函数：

</ul>
<table>
<tr>
<th>
方法名
</th>
<th>
描述
</th>
<th>
备注
</th>
</tr>
<tr>
<td>
initStreamVolume
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
setStreamVolumeIndex
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
getStreamVolumeIndex
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>
</table>

<h3 id="toc_1.4.1">音量值的定义</h3>
<ul>
<li>
AudioService.java中定义各种类型音量的最大值和最小值。

<li>
电话铃声可以有7个级别的音量，而音乐则可以有15个音量级别，AudioSystem(java层)通过jni，调用AudioSystem(C++层)的 initStreamVolume()，把这个数组的内容传入AudioPolicyService中，最终通过AudioPolicyManagerBase将每种音频流的音量记录到列表中。应用程序可以调用setStreamVolumeIndex设置各个音频流的音量级别，setStreamVolumeIndex会把这个整数的音量级别转化为适合人耳的对数级别，然后通过AudioPolicyService的 AudioCommandThread，最终会将设置应用到AudioFlinger的相应的Track中。

</ul>

<pre class="brush:java">
private int[] MAX_STREAM_VOLUME = new int[] {
    5,  // STREAM_VOICE_CALL
    7,  // STREAM_SYSTEM
    7,  // STREAM_RING
    15, // STREAM_MUSIC
    7,  // STREAM_ALARM
    7,  // STREAM_NOTIFICATION
    15, // STREAM_BLUETOOTH_SCO
    7,  // STREAM_SYSTEM_ENFORCED
    15, // STREAM_DTMF
    15  // STREAM_TTS
};
</pre>

<h2 id="toc_1.5">音频策略管理</h2>
<ul>
<li>
首先要搞清楚stream_type，device，strategy三者之间的关系：

<ul>
<li>
AudioSystem::stream_type：音频流的类型，一共有10种类型

<li>
AudioSystem::audio_devices：音频输入输出设备，每一个bit代表一种设备，见前面的说明

<li>
AudioPolicyManagerBase::routing_strategy：音频路由策略，可以有4种策略

</ul>
</ul>

<h3 id="toc_1.5.1">AudioSystem::stream_type</h3>
<pre class="brush:c++">
enum stream_type {
    DEFAULT          =-1,
    VOICE_CALL       = 0,
    SYSTEM           = 1,
    RING             = 2,
    MUSIC            = 3,
    ALARM            = 4,
    NOTIFICATION     = 5,
    BLUETOOTH_SCO    = 6,
    ENFORCED_AUDIBLE = 7, 
    DTMF             = 8,
    TTS              = 9,
    NUM_STREAM_TYPES
};
</pre>

<h3 id="toc_1.5.2">AudioSystem::audio_devices</h3>
<pre class="brush:c++">
enum audio_devices {
    // output devices
    DEVICE_OUT_EARPIECE = 0x1,
    DEVICE_OUT_SPEAKER = 0x2,
    DEVICE_OUT_WIRED_HEADSET = 0x4,
    DEVICE_OUT_WIRED_HEADPHONE = 0x8,
    DEVICE_OUT_BLUETOOTH_SCO = 0x10,
    DEVICE_OUT_BLUETOOTH_SCO_HEADSET = 0x20,
    DEVICE_OUT_BLUETOOTH_SCO_CARKIT = 0x40,
    DEVICE_OUT_BLUETOOTH_A2DP = 0x80,
    DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES = 0x100,
    DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER = 0x200,
    DEVICE_OUT_AUX_DIGITAL = 0x400,
    DEVICE_OUT_FM_TRANSMIT = 0x800,
    DEVICE_OUT_LOW_POWER = 0x1000,
    DEVICE_OUT_DEFAULT = 0x8000,

    // input devices
    DEVICE_IN_COMMUNICATION = 0x10000,
    DEVICE_IN_AMBIENT = 0x20000,
    DEVICE_IN_BUILTIN_MIC = 0x40000,
    DEVICE_IN_BLUETOOTH_SCO_HEADSET = 0x80000,
    DEVICE_IN_WIRED_HEADSET = 0x100000,
    DEVICE_IN_AUX_DIGITAL = 0x200000,
    DEVICE_IN_VOICE_CALL = 0x400000,
    DEVICE_IN_BACK_MIC = 0x800000,
    DEVICE_IN_FM_ANALOG = 0x1000000,
    DEVICE_IN_DEFAULT = 0x80000000,
};
</pre>

<h3 id="toc_1.5.3">AudioPolicyManagerBase::routing_strategy</h3>
<pre class="brush:c++">
enum routing_strategy {
    STRATEGY_MEDIA,
    STRATEGY_PHONE,
    STRATEGY_SONIFICATION,
    STRATEGY_DTMF,
    NUM_STRATEGIES
};
</pre>

<ul>
<li>
AudioPolicyManagerBase.getStrategy根据stream type，返回对应的routing strategy值，AudioPolicyManagerBase.getDeviceForStrategy()则是根据routing strategy，返回可用的device。Android把10种stream type归纳为4种路由策略，然后根据路由策略决定具体的输出设备。

</ul>

<p>
<img src="http:pic/audio_strategy.png" />
</p>

<h3 id="toc_1.5.4">AudioPolicyManagerBase::getStrategy</h3>
<pre class="brush:c++">
AudioPolicyManagerBase::routing_strategy AudioPolicyManagerBase::getStrategy(
        AudioSystem::stream_type stream) {
    switch (stream) {
    case AudioSystem::VOICE_CALL:
    case AudioSystem::BLUETOOTH_SCO:
        return STRATEGY_PHONE;
    case AudioSystem::RING:
    case AudioSystem::NOTIFICATION:
    case AudioSystem::ALARM:
    case AudioSystem::ENFORCED_AUDIBLE:
        return STRATEGY_SONIFICATION;
    case AudioSystem::DTMF:
        return STRATEGY_DTMF;
    default:
        LOGE("unknown stream type");
    case AudioSystem::SYSTEM:
    case AudioSystem::TTS:
    case AudioSystem::MUSIC:
        return STRATEGY_MEDIA;
    }
}
</pre>

<h3 id="toc_1.5.5">AudioPolicyManagerBase::getDeviceForStrategy</h3>
<pre class="brush:c++">
uint32_t AudioPolicyManagerBase::getDeviceForStrategy(routing_strategy strategy, bool fromCache)
{
    ...... 
    switch (strategy) {
    case STRATEGY_DTMF:
        ......
    case STRATEGY_PHONE:
        switch (mForceUse[AudioSystem::FOR_COMMUNICATION]) {
        case AudioSystem::FORCE_BT_SCO:
            ...... 
        default:    // FORCE_NONE
            ...... 
            break;
        case AudioSystem::FORCE_SPEAKER:
            ...... 
            break;
        }
        break;
    case STRATEGY_SONIFICATION:
        ...... 
    case STRATEGY_MEDIA:
        ......
         break;
    default:
        break;
    }

    return device;
}
</pre>

<h2 id="toc_1.6">音频控制线程(AudioCommandThread)</h2>
<ul>
<li>
这是AudioPolicyService中的一个线程类，主要用于处理音频设置相关的命令。包括以下命令：

</ul>

<h3 id="toc_1.6.1">命令标识</h3>
<table>
<tr>
<th>
命令标识
</th>
<th>
描述
</th>
<th>
备注
</th>
</tr>
<tr>
<td>
START_TONE
</td>
<td>
播放电话系统中常用的特殊音调，如：TONE_DTMF_0，TONE_SUP_BUSY
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
STOP_TONE
</td>
<td>
播放电话系统中常用的特殊音调，如：TONE_DTMF_0，TONE_SUP_BUSY
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
SET_VOLUME
</td>
<td>
最终会调用AudioFlinger进行音量设置
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
SET_VOICE_VOLUME
</td>
<td>
最终会调用AudioFlinger进行电话音量设置
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
SET_PARAMETERS
</td>
<td>
字符串KeyValuePairs通过AudioPolicyService::setParameters()传入
</td>
<td>
"channels=2"或"sampling_rate=44100;channels=2"
</td>
</tr>
</table>

<h3 id="toc_1.6.2">命令对应的数据结构</h3>
<table>
<tr>
<th>
命令标识
</th>
<th>
数据结构
</th>
</tr>
<tr>
<td>
START_TONE
</td>
<td>
ToneData
</td>
</tr>
<tr>
<td>
STOP_TONE
</td>
<td>
ToneData
</td>
</tr>
<tr>
<td>
SET_VOLUME
</td>
<td>
VolumeData
</td>
</tr>
<tr>
<td>
SET_VOICE_VOLUME
</td>
<td>
VoiceVolumeData
</td>
</tr>
<tr>
<td>
SET_PARAMETERS
</td>
<td>
ParametersData
</td>
</tr>
</table>

<h3 id="toc_1.6.3">AudioCommandThread::Command</h3>
<pre class="brush:c++">
enum {
    START_TONE,
    STOP_TONE,
    SET_VOLUME,
    SET_PARAMETERS,
    SET_VOICE_VOLUME
};
</pre>

<h3 id="toc_1.6.4">AudioCommandThread::threadLoop</h3>
<pre class="brush:c++">
bool AudioPolicyService::AudioCommandThread::threadLoop()
{
    ......
    while (!exitPending())
    {
        while(!mAudioCommands.isEmpty()) {
            if (mAudioCommands[0]-&gt;mTime &lt;= curTime) {
                ...... 
                switch (command-&gt;mCommand) {
                case START_TONE: {
                    mLock.unlock();
                    ToneData *data = (ToneData *)command-&gt;mParam;
                    if (mpToneGenerator != NULL)
                        delete mpToneGenerator;
                    mpToneGenerator = new ToneGenerator(data-&gt;mStream, 1.0);
                    mpToneGenerator-&gt;startTone(data-&gt;mType);
                    delete data;
                    mLock.lock();
                    }break;
                case STOP_TONE: {
                    mLock.unlock();
                    if (mpToneGenerator != NULL) {
                        mpToneGenerator-&gt;stopTone();
                        delete mpToneGenerator;
                        mpToneGenerator = NULL;
                    }
                    mLock.lock();
                    }break;
                case SET_VOLUME: {
                    VolumeData *data = (VolumeData *)command-&gt;mParam;
                    command-&gt;mStatus = AudioSystem::setStreamVolume(data-&gt;mStream,
                                                                    data-&gt;mVolume,
                                                                    data-&gt;mIO);
                    if (command-&gt;mWaitStatus) {
                        command-&gt;mCond.signal();
                        mWaitWorkCV.wait(mLock);
                    }
                    delete data;
                    }break;
                case SET_PARAMETERS: {
                     ParametersData *data = (ParametersData *)command-&gt;mParam;
                     command-&gt;mStatus = AudioSystem::setParameters(data-&gt;mIO, data-&gt;mKeyValuePairs);
                     if (command-&gt;mWaitStatus) {
                         command-&gt;mCond.signal();
                         mWaitWorkCV.wait(mLock);
                     }
                     delete data;
                     }break;
                case SET_VOICE_VOLUME: {
                    VoiceVolumeData *data = (VoiceVolumeData *)command-&gt;mParam;
                    command-&gt;mStatus = AudioSystem::setVoiceVolume(data-&gt;mVolume);
                    if (command-&gt;mWaitStatus) {
                        command-&gt;mCond.signal();
                        mWaitWorkCV.wait(mLock);
                    }
                    delete data;
                    }break;
                default:
                }
                delete command;
                waitTime = INT64_MAX;
            } else {
                waitTime = mAudioCommands[0]-&gt;mTime - curTime;
                break;
            }
        }
        ......
    }
    return false;
}
</pre>


<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

</body>
</html>
