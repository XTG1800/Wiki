<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>显示系统</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
	<link type="text/css" rel="stylesheet" href="css_style/style_zenki.css"/>

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>


<h1 id="toc_1">显示系统(Android 2.3)</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">显示系统(Android 2.3)</a></li>
<ul>
<li><a href="#toc_1.1">相关文件</a></li>
<li><a href="#toc_1.2">概述</a></li>
<li><a href="#toc_1.3">窗口会话</a></li>
<ul>
<li><a href="#toc_1.3.1">WindowManagerService</a></li>
<li><a href="#toc_1.3.2">Session</a></li>
<li><a href="#toc_1.3.3">WindowState</a></li>
</ul>
<li><a href="#toc_1.4">显示层会话</a></li>
<ul>
<li><a href="#toc_1.4.1">SurfaceSession(Java层)</a></li>
<li><a href="#toc_1.4.2">SurfaceSession_init(JNI)</a></li>
<li><a href="#toc_1.4.3">SurfaceComposerClient::onFirstRef(C++)</a></li>
</ul>
<li><a href="#toc_1.5">显示层抽象</a></li>
<ul>
<li><a href="#toc_1.5.1">Surface(Java层)</a></li>
<li><a href="#toc_1.5.2">Surface_init(JNI)</a></li>
<li><a href="#toc_1.5.3">SurfaceComposerClient::createSurface(C++)</a></li>
<li><a href="#toc_1.5.4">Client::createSurface(C++)</a></li>
<li><a href="#toc_1.5.5">SurfaceFlinger::createSurface(C++)</a></li>
</ul>
<li><a href="#toc_1.6">Surface创建时序图</a></li>
<li><a href="#toc_1.7">C++层的Surface显示实现</a></li>
<ul>
<li><a href="#toc_1.7.1">在缓冲区上绘画</a></li>
<li><a href="#toc_1.7.2">缓冲区管理</a></li>
<li><a href="#toc_1.7.3">SurfaceFlinger工作线程</a></li>
</ul>
<li><a href="#toc_1.8">显示系统HAL层</a></li>
</ul>
</ul>
</div>

<h2 id="toc_1.1">相关文件</h2>
<pre class="brush:text">
// java层
frameworks/base/core/java/android/view/Surface.java
frameworks/base/core/java/android/view/SurfaceSession.java

// JNI层
frameworks/base/core/jni/android_view_Surface.cpp

// C++层
frameworks/base/libs/surfaceflinger_client/SurfaceComposerClient.cpp
frameworks/base/libs/surfaceflinger_client/Surface.cpp
frameworks/base/libs/surfaceflinger_client/SharedBufferStack.cpp
frameworks/base/include/surfaceflinger/Surface.h
frameworks/base/include/surfaceflinger/SharedBufferStack.h

// HAL
hardware/libhardware/include/hardware/gralloc.h
hardware/libhardware/include/hardware/hardware.h
hardware/libhardware/modules/gralloc/gralloc.cpp
hardware/libhardware/modules/gralloc/framebuffer.cpp
frameworks/base/libs/ui/FramebufferNativeWindow.h
frameworks/base/include/ui/FramebufferNativeWindow.cpp
frameworks/base/services/surfaceflinger/DisplayHardware.cpp
</pre>

<h2 id="toc_1.2">概述</h2>
<pre class="brush:text">
    Android的显示系统从上到下分为Surface(Java层)、SurfaceSession(Java层)、SurfaceFlinger(C++层)，
Layer(C++层)等。
    SurfaceFlinger在系统启动阶段作为系统服务被加载。应用程序中的每个窗口，对应Java层的Surface，
而Surface又对应于SurfaceFlinger中的各个Layer，SurfaceFlinger的主要作用是为这些Layer申请内存，根据
应用程序的请求管理这些Layer显示、隐藏、重画等操作，最终由SurfaceFlinger把所有的Layer组合到一起，
显示到屏幕上。当应用程序需要在一个Surface上进行画图操作时，首先要拿到这个Surface在内存中的起始地址，
而这块内存是在SurfaceFlinger中分配的，因为SurfaceFlinger和应用程序并不是运行在同一个进程中，如何在
应用客户端(Surface)和服务端(SurfaceFlinger — Layer)之间传递和同步显示缓冲区?这正是本文要讨论的内容。
</pre>

<h2 id="toc_1.3">窗口会话</h2>
<ul>
<li>
我们从窗口初始化开始。WindowManagerService.Session是一个内部类，该类封装了SurfaceSession对象。Session类继承自IWindowSession.Stub，是关于窗口会话的抽象类，它不仅包括图像显示，还包括touch等事件。
</li>
<li>
显示会话被抽象成SurfaceSession类，它负责向Service申请内存。
</li>
<li>
WindowManagerService用HashSet保存所有窗口的Session对象。WindowManagerService在加入一个窗口时，会调用Session.windowAddedLocked方法，它首先初始化一个SurfaceSession对象，然后将自己保存到WindowManagerService的HashSet成员中。
</li>
<li>
接下来再看一个内部类WindowState，它是窗口状态的抽象。该类的attach方法会调用Session.windowAddedLocked。当窗口布局创建时，会使用WindowState.createSurfaceLocked方法创建Surface对象，而这时会传入刚刚创建的SurfaceSession对象作为初始化参数。
</li>
</ul>

<h3 id="toc_1.3.1">WindowManagerService</h3>
<pre class="brush:java">
public class WindowManagerService extends IWindowManager.Stub
    implements Watchdog.Monitor {
    
    ......
    // 创建一个保存Session对象的set
    final HashSet&lt;Session&gt; mSessions = new HashSet&lt;Session&gt;();
    ......
}
</pre>

<h3 id="toc_1.3.2">Session</h3>
<pre class="brush:java">
private final class Session extends IWindowSession.Stub
            implements IBinder.DeathRecipient {
    SurfaceSession mSurfaceSession;
        
    ......
    void windowAddedLocked() {
        if (mSurfaceSession == null) {
            // 当加入窗口时，创建一个SurfaceSession对象
            mSurfaceSession = new SurfaceSession();
            // 加入到HashSet中
            mSessions.add(this);
        }
        mNumWindow++;
    }
    
    ......
}
</pre>

<h3 id="toc_1.3.3">WindowState</h3>
<pre class="brush:java">
WindowState(Session s, IWindow c, WindowToken token, 
            WindowState attachedWindow, WindowManager.LayoutParams a,
            int viewVisibility) {
    ......
    Surface createSurfaceLocked() {
        if (mSurface == null) {
            ......
            try {
                // 通过mSession.mSurfaceSession来创建Surface
                mSurface = new Surface(
                        mSession.mSurfaceSession, mSession.mPid,
                        mAttrs.getTitle().toString(),
                        0, w, h, mAttrs.format, flags);
            } catch (Surface.OutOfResourcesException e) {
                ......
                return null;
            } catch (Exception e) {
                return null;
            }

            ...... 
            Surface.openTransaction();
            try {
                try {
                    ...... 
                } catch (RuntimeException e) {
                    ......
                }
            } finally {
                Surface.closeTransaction();
            }
        }
        return mSurface;
    }
    ......
}
</pre>

<h2 id="toc_1.4">显示层会话</h2>
<ul>
<li>
先看SurfaceSession类，它只是简单的对JNI层进行了封装，在初始化时调用了native层的init方法。
</li>
<ul>
<li>
JAVA层通过JNI调用本地代码，本地代码创建一个SurfaceComposerClient的实例，该实例第一次引用会调用onFirstRef方法，getComposerService实际会返回SurfaceFlinger的Binder引用，并通过引用调用 SurfaceFlinger的createConnection，SurfaceFlinger返回一个ISurfaceComposerClient接口给SurfaceComposerClient。
</li>
<li>
在createConnection的过程中，SurfaceFlinger创建了用于管理缓冲区切换的Client对象，该对象实现ISurfaceComposerClient接口。
</li>
<li>
最后，本地层把SurfaceComposerClient的实例返回给JAVA层，完成SurfaceSession的建立。
</li>
</ul>
</ul>

<h3 id="toc_1.4.1">SurfaceSession(Java层)</h3>
<pre class="brush:java">
public class SurfaceSession {
    public SurfaceSession() {
        init();
    }

    public native void kill();

    @Override
    protected void finalize() throws Throwable {
        destroy();
    }
    
    private native void init();
    private native void destroy();
    
    private int mClient;
}
</pre>

<h3 id="toc_1.4.2">SurfaceSession_init(JNI)</h3>
<pre class="brush:c++">
static void SurfaceSession_init(JNIEnv* env, jobject clazz)
{
    sp&lt;SurfaceComposerClient&gt; client = new SurfaceComposerClient;
    client-&gt;incStrong(clazz);
    env-&gt;SetIntField(clazz, sso.client, (int)client.get());
}
</pre>

<h3 id="toc_1.4.3">SurfaceComposerClient::onFirstRef(C++)</h3>
<pre class="brush:c++">
void SurfaceComposerClient::onFirstRef()
{
    sp&lt;ISurfaceComposer&gt; sm(getComposerService());
    if (sm != 0) {
        sp&lt;ISurfaceComposerClient&gt; conn = sm-&gt;createConnection();
        if (conn != 0) {
            mClient = conn;
            Composer::addClient(this);
            mPrebuiltLayerState = new layer_state_t;
            mStatus = NO_ERROR;
        }
    }
}
</pre>

<h2 id="toc_1.5">显示层抽象</h2>
<ul>
<li>
再看Surface类，它的构造方法先初始化了CompatibleCanvas对象，之后调用native层的init方法。
</li>
<ul>
<li>
JAVA层通过JNI调用本地代码Surface_Init()，本地代码首先取得第一步创建的SurfaceComposerClient实例，通过 该实例调用ISurfaceComposerClient接口(Client对象)的createSurface方法，继而调用SurfaceFlinger.createSurface。
</li>
<li>
SurfaceFlinger根据参数，创建不同类型的Layer，然后返回该Layer的ISurface接口，SurfaceComposerClient使用这个ISurface接口创建一个SurfaceControl实例，并把这个SurfaceControl返回给JAVA层。
</li>
<li>
Java层的Surface实际上对应于native的SurfaceControl对象，以后native可以通过SurfaceControl的getSurface方法，获得C++层的Surface对象；
</li>
</ul>
</ul>

<h3 id="toc_1.5.1">Surface(Java层)</h3>
<pre class="brush:java">
public Surface(SurfaceSession s,
        int pid, int display, int w, int h, int format, int flags)
    // 创建CompatibleCanvas对象
    mCanvas = new CompatibleCanvas();
    // 调用native的init
    init(s,pid,null,display,w,h,format,flags);
}
</pre>

<h3 id="toc_1.5.2">Surface_init(JNI)</h3>
<pre class="brush:c++">
static void Surface_init( JNIEnv* env, jobject clazz, jobject session,
        jint pid, jstring jname, jint dpy, jint w, jint h, jint format, jint flags)
{
    ...... 
    SurfaceComposerClient* client =
            (SurfaceComposerClient*)env-&gt;GetIntField(session, sso.client);

    sp&lt;SurfaceControl&gt; surface;
    if (jname == NULL) {
        surface = client-&gt;createSurface(pid, dpy, w, h, format, flags);
    } else {
        ......
    }
    ......

    // 返回给Java层
    setSurfaceControl(env, clazz, surface);
}
</pre>

<h3 id="toc_1.5.3">SurfaceComposerClient::createSurface(C++)</h3>
<pre class="brush:c++">
sp&lt;SurfaceControl&gt; SurfaceComposerClient::createSurface( int pid,
        const String8&amp; name, DisplayID display, uint32_t w, uint32_t h,
        PixelFormat format, uint32_t flags)
{
    sp&lt;SurfaceControl&gt; result;
    if (mStatus == NO_ERROR) {
        ISurfaceComposerClient::surface_data_t data;
        // mClient为初始化时获取的ISurfaceComposerClient接口，
        // 及SurfaceFlinger的Binder引用 
        sp&lt;ISurface&gt; surface = mClient-&gt;createSurface(&amp;data, pid, name,
                display, w, h, format, flags);
        if (surface != 0) {
            result = new SurfaceControl(this, surface, data, w, h, format, flags);
        }
    }
    return result;
}
</pre>

<h3 id="toc_1.5.4">Client::createSurface(C++)</h3>
<pre class="brush:c++">
sp&lt;ISurface&gt; Client::createSurface(
        ISurfaceComposerClient::surface_data_t* params, int pid,
        const String8&amp; name,
        DisplayID display, uint32_t w, uint32_t h, PixelFormat format,
        uint32_t flags)
{
    return mFlinger-&gt;createSurface(this, pid, name, params,
            display, w, h, format, flags);
}
</pre>

<h3 id="toc_1.5.5">SurfaceFlinger::createSurface(C++)</h3>
<pre class="brush:c++">
sp&lt;ISurface&gt; SurfaceFlinger::createSurface(const sp&lt;Client&gt;&amp; client, int pid,
        const String8&amp; name, ISurfaceComposerClient::surface_data_t* params,
        DisplayID d, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags)
{
    sp&lt;LayerBaseClient&gt; layer;
    sp&lt;LayerBaseClient::Surface&gt; surfaceHandle;

    ...... 
    sp&lt;Layer&gt; normalLayer;
    // 创建Layer
    switch (flags &amp; eFXSurfaceMask) {
        case eFXSurfaceNormal:
            if (UNLIKELY(flags &amp; ePushBuffers)) {
                layer = createPushBuffersSurface(client, d, w, h, flags);
            } else {
                normalLayer = createNormalSurface(client, d, w, h, flags, format);
                layer = normalLayer;
            }
            break;
        case eFXSurfaceBlur:
            layer = createBlurSurface(client, d, w, h, flags);
            break;
        case eFXSurfaceDim:
            layer = createDimSurface(client, d, w, h, flags);
            break;
    }

    if (layer != 0) {
        layer-&gt;initStates(w, h, flags);
        layer-&gt;setName(name);
        ssize_t token = addClientLayer(client, layer);

        // 获取SurfaceHandle
        surfaceHandle = layer-&gt;getSurface();
        ...... 

        setTransactionFlags(eTransactionNeeded);
    }

    return surfaceHandle;
}
</pre>

<h2 id="toc_1.6">Surface创建时序图</h2>
<p>
<a href="pic/create_surface.png"><img src="pic/create_surface.png" /></a>
</p>

<h2 id="toc_1.7">C++层的Surface显示实现</h2>
<ul>
<li>
在IBinder左边的就是客户端部分，也就是需要窗口显示的应用程序，而右边就是SurfaceFlinger。创建一个Surface(C++层)分为两个过程，一个是在SurfaceFlinger 这边为每个应用程序(Client) 创建一个管理结构，另一个就是创建存储内容的buffer，以及在这个buffer上的一系列画图之类的操作。
</li>
<li>
在新版本的Android中，BClient对应<code>UserClient</code>，Client对应<code>SharedClient</code>。
</li>
</ul>

<p>
<a href="pic/surface_class.jpg"><img src="pic/surface_class.jpg" /></a>
</p>

<h3 id="toc_1.7.1">在缓冲区上绘画</h3>
<ul>
<li>
<a href="显示缓冲区的作用.html">显示缓冲区的作用</a>
</li>
</ul>

<h3 id="toc_1.7.2">缓冲区管理</h3>
<ul>
<li>
<a href="Surface缓冲区管理.html">Surface缓冲区管理</a>
</li>
</ul>

<h3 id="toc_1.7.3">SurfaceFlinger工作线程</h3>
<ul>
<li>
<a href="SurfaceFlinger工作线程.html">SurfaceFlinger工作线程</a>
</li>
</ul>

<h2 id="toc_1.8">显示系统HAL层</h2>
<ul>
<li>
<a href="显示系统HAL层.html">显示系统HAL层</a>
</li>
</ul>
<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

<!--<script type="text/javascript">-->
<!--var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");-->
<!--document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));-->
<!--</script>-->
<!--<script type="text/javascript">-->
<!--try {-->
<!--var pageTracker = _gat._getTracker("UA-15922433-1");-->
<!--pageTracker._trackPageview();-->
<!--} catch(err) {}-->
<!--</script>-->

</body>
</html>
