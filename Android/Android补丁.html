<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Android补丁</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <link rel="Stylesheet" type="text/css" href="../css_style/style_zenki.css">

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>

<!-- wrap the vimwiki html -->

<h1 id="toc_1">Android补丁</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">Android补丁</a>
<ul>
<li><a href="#toc_1.1">相关文件</a>
<li><a href="#toc_1.2">Andriod的新概念</a>
<ul>
<li><a href="#toc_1.2.1">Early Suspend</a>
<li><a href="#toc_1.2.2">Late Resume</a>
<li><a href="#toc_1.2.3">Wake Lock</a>
</ul>
<li><a href="#toc_1.3">代码分析</a>
<ul>
<li><a href="#toc_1.3.1">Android Suspend</a>
<li><a href="#toc_1.3.2">Early Suspend</a>
<li><a href="#toc_1.3.3">Late Resume</a>
<li><a href="#toc_1.3.4">Wake Lock</a>
<li><a href="#toc_1.3.5">Suspend</a>
</ul>
<li><a href="#toc_1.4">Android与标准Linux休眠的区别</a>
</ul>
</ul>
</div>

<h2 id="toc_1.1">相关文件</h2>
<pre class="brush:text">
linux_source/kernel/power/main.c
linux_source/kernel/power/earlysuspend.c
linux_source/kernel/power/wakelock.c
</pre>

<h2 id="toc_1.2">Andriod的新概念</h2>
<h3 id="toc_1.2.1">Early Suspend</h3>
<pre class="brush:text">
    Early suspend是android引进的一种机制，这种机制在上游备受争议，这里不做评论。这个机制作用在关闭的时候，
一些和显示有关的设备，比如LCD背光，比如重力感应器、触摸屏，这些设备都会关掉。但是系统可能还是在运行状态
(这时候还有wake lock)进行任务的处理，例如在扫描SD卡上的文件等。在嵌入式设备中，背光是一个很大的电源消耗，
所以android会加入这样一种机制。
</pre>

<h3 id="toc_1.2.2">Late Resume</h3>
<pre class="brush:text">
Late Resume是和suspend配套的一种机制，是在内核唤醒完毕开始执行的。主要就是唤醒在Early Suspend的时候休眠的设备。
</pre>

<h3 id="toc_1.2.3">Wake Lock</h3>
<pre class="brush:text">
    Wake Lock在Android的电源管理系统中扮演一个核心的角色。Wake Lock是一种锁的机制，只要有人拿着这个锁，
系统就无法进入休眠，可以被用户态程序和内核获得。这个锁可以是有超时的或者是没有超时的，超时的锁会在时间过去以后
自动解锁 。如果没有锁了或者超时了，内核就会启动休眠的那套机制来进入休眠。
</pre>

<p>
<img src="http:pic/power_manager.png" />
</p>

<h2 id="toc_1.3">代码分析</h2>
<h3 id="toc_1.3.1">Android Suspend</h3>
<p>
当用户写入mem或者standby到/sys/power/state中的时候，state_store()会被调用，然后Android会在这里调用request_suspend_state()而标准的Linux会在这里进入enter_state()这个函数。
如果请求的是休眠，那么early_suspend这个workqueue就会被调用，并且进入early_suspend状态。
</p>
<pre class="brush:c">
void request_suspend_state(suspend_state_t new_state)
{
    unsigned long irqflags;
    int old_sleep;

    spin_lock_irqsave(&amp;state_lock, irqflags);
    old_sleep = state &amp; SUSPEND_REQUESTED;
    
    if (!old_sleep &amp;&amp; new_state != PM_SUSPEND_ON) {
        state |= SUSPEND_REQUESTED;
        // early_suspend状态
        queue_work(suspend_work_queue, &amp;early_suspend_work);
    } else if (old_sleep &amp;&amp; new_state == PM_SUSPEND_ON) {
        state &amp;= ~SUSPEND_REQUESTED;
        wake_lock(&amp;main_wake_lock);
        // late_resume状态
        queue_work(suspend_work_queue, &amp;late_resume_work);
    }
    
    requested_suspend_state = new_state;
    spin_unlock_irqrestore(&amp;state_lock, irqflags);
}
</pre>

<h3 id="toc_1.3.2">Early Suspend</h3>
<p>
在early_suspend()函数中，首先会检查现在请求的状态还是否是suspend，来防止suspend的请求会在这个时候取消掉(因为这个时候用户进程还在运行)，如果需要退出，就简单的退出了。如果没有，这个函数就会把early suspend中注册的一系列的回调都调用一次，然后同步文件系统，然后放弃掉main_wake_lock，这个wake lock是一个没有超时的锁，如果这个锁不释放，那么系统就无法进入休眠。
</p>
<pre class="brush:c">
static void early_suspend(struct work_struct *work)
{
    struct early_suspend *pos;
    unsigned long irqflags;
    int abort = 0;

    mutex_lock(&amp;early_suspend_lock);
    spin_lock_irqsave(&amp;state_lock, irqflags);
    if (state == SUSPEND_REQUESTED)
        state |= SUSPENDED;
    else
        abort = 1;
    spin_unlock_irqrestore(&amp;state_lock, irqflags);

    if (abort) {
        mutex_unlock(&amp;early_suspend_lock);
        goto abort;
    }

    list_for_each_entry(pos, &amp;early_suspend_handlers, link) {
        if (pos-&gt;suspend != NULL)
            pos-&gt;suspend(pos);
    }
    mutex_unlock(&amp;early_suspend_lock);

    sys_sync();
abort:
    spin_lock_irqsave(&amp;state_lock, irqflags);
    if (state == SUSPEND_REQUESTED_AND_SUSPENDED)
        wake_unlock(&amp;main_wake_lock);
    spin_unlock_irqrestore(&amp;state_lock, irqflags);
}
</pre>

<p>
<img src="http:pic/early_suspend.png" />
</p>

<h3 id="toc_1.3.3">Late Resume</h3>
<ul>
<li>
当所有的唤醒已经结束以后，用户进程都已经开始运行了，唤醒通常会是以下的几种原因：

<li>
来电

</ul>

<pre class="brush:text">
    如果是来电，那么Modem会通过发送命令给rild来让rild通知WindowManager有来电响应，这样就会远程调用
PowerManagerService来写"on"到/sys/power/state来执行late resume的设备，比如点亮屏幕等。
</pre>

<ul>
<li>
用户按键

</ul>

<pre class="brush:text">
    用户按键事件会送到WindowManager中，WindowManager会处理这些按键事件，按键分为几种情况，如果案件不是唤醒键
(能够唤醒系统的按键)，那么WindowManager会主动放弃wakeLock来使系统进入再次休眠，如果按键是唤醒键，那么WindowManger
就会调用PowerManagerService中的接口来执行Late Resume。
</pre>

<ul>
<li>
Late Resume会依次唤醒前面调用了Early Suspend的设备。

</ul>

<pre class="brush:c">
static void late_resume(struct work_struct *work)
{
    struct early_suspend *pos;
    unsigned long irqflags;
    int abort = 0;

    mutex_lock(&amp;early_suspend_lock);
    spin_lock_irqsave(&amp;state_lock, irqflags);
    if (state == SUSPENDED)
        state &amp;= ~SUSPENDED;
    else
        abort = 1;
    spin_unlock_irqrestore(&amp;state_lock, irqflags);

    if (abort) {
        goto abort;
    }
    list_for_each_entry_reverse(pos, &amp;early_suspend_handlers, link)
    if (pos-&gt;resume != NULL)
        pos-&gt;resume(pos);
abort:
    mutex_unlock(&amp;early_suspend_lock);
}
</pre>

<h3 id="toc_1.3.4">Wake Lock</h3>
<ul>
<li>
wake lock有加锁和解锁两种状态，加锁的方式有两种：

<ul>
<li>
第一种是永久的锁住，这样的锁除非显示的放开，否则是不会解锁的，所以这种锁的使用是非常小心的。

<li>
第二种是超时锁，这种锁会锁定系统唤醒一段时间，如果这个时间过去了，这个锁会自动解除。

</ul>
</ul>

<ul>
<li>
锁有两种类型:

<ul>
<li>
1. WAKE_LOCK_SUSPEND 这种锁会防止系统进入睡眠。

<li>
2. WAKE_LOCK_IDLE 这种锁不会影响系统的休眠。

</ul>
</ul>

<ul>
<li>
在wake lock中, 会有3个地方让系统直接开始suspend(), 分别是:

<ul>
<li>
1. 在wake_unlock()中，如果发现解锁以后没有任何其他的wake lock了，就开始休眠。

<li>
2. 在定时器都到时间以后，定时器的回调函数会查看是否有其他的wake lock，如果没有，就在这里让系统进入睡眠。

<li>
3. 在wake_lock() 中，对一个wake lock加锁以后，会再次检查一下有没有锁。

</ul>
</ul>

<h3 id="toc_1.3.5">Suspend</h3>
<ul>
<li>
当wake_lock运行suspend()以后，在wakelock.c的suspend()函数会被调用，这个函数首先sync文件系统，然后调用pm_suspend(request_suspend_state)，接下来pm_suspend()就会调用enter_state()来进入Linux的休眠流程。

</ul>

<pre class="brush:c">
static void suspend(struct work_struct *work)
{
    int ret;
    int entry_event_num;

    if (has_wake_lock(WAKE_LOCK_SUSPEND)) {
        return;
    }

    entry_event_num = current_event_num;
    sys_sync();
    ret = pm_suspend(requested_suspend_state);
    if (current_event_num == entry_event_num) {
        wake_lock_timeout(&amp;unknown_wakeup, HZ / 2);
    }
}
</pre>

<h2 id="toc_1.4">Android与标准Linux休眠的区别</h2>
<ul>
<li>
pm_suspend()虽然会调用enter_state()来进入标准的Linux休眠流程，但是还是有一些区别：

<ul>
<li>
当进入冻结进程的时候，android首先会检查有没有wake lock，如果没有，才会停止这些进程，因为在开始suspend和冻结进程期间有可能有人申请了wake lock，如果是这样，冻结进程会被中断。

<li>
在suspend_late()中，会最后检查一次有没有wake lock，这有可能是某种快速申请wake lock，并且快速释放这个锁的进程导致的，如果有这种情况，这里会返回错误，整个suspend就会全部放弃。

</ul>
</ul>


<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

</body>
</html>
