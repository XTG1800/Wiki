<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>定时器</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <link rel="Stylesheet" type="text/css" href="../css_style/style_zenki.css">

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>

<!-- wrap the vimwiki html -->

<h1 id="toc_1">定时器</h1>

<h2 id="toc_1.1">相关类</h2>
<pre class="brush:java">
// Receiver
import android.content.Context;
import android.content.Intent;
import android.content.BroadcastReceiver;

// Sender
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.Intent;
import android.os.SystemClock;

import java.util.Calendar;
</pre>

<h2 id="toc_1.2">AlarmManager主要方法</h2>
<ul>
<li>
<strong>AlarmManager提供客户端的闹铃注册，其通过Binder机制与AlarmManagerService通信，而AlarmManagerService真正提供服务</strong>

</ul>

<table>
<tr>
<th>
返回值
</th>
<th>
方法名称
</th>
<th>
描述
</th>
</tr>
<tr>
<td>
void
</td>
<td>
cancel(PendingIntent operation)
</td>
<td>
取消已注册的闹铃
</td>
</tr>
<tr>
<td>
void
</td>
<td>
set(int type, long triggerAtTime, PendingIntent operation)
</td>
<td>
注册一个新闹铃
</td>
</tr>
<tr>
<td>
void
</td>
<td>
setRepeating(int type, long triggerAtTime, long interval, PendingIntent operation)
</td>
<td>
注册一个重复的闹铃
</td>
</tr>
<tr>
<td>
void
</td>
<td>
setTime(long millis)
</td>
<td>
设置系统时钟
</td>
</tr>
<tr>
<td>
void
</td>
<td>
setTimeZone(String timeZone)
</td>
<td>
设置时区
</td>
</tr>
</table>

<h2 id="toc_1.3">AlarmManager的闹铃类型</h2>
<table>
<tr>
<th>
类型
</th>
<th>
标识
</th>
<th>
描述
</th>
</tr>
<tr>
<td>
int
</td>
<td>
ELAPSED_REALTIME
</td>
<td>
当系统进入睡眠状态时，该闹铃不会唤醒系统，直到系统下次被唤醒才传递它。该闹铃使用相对时间，通过SystemClock.elapsedRealtime()获得
</td>
</tr>
<tr>
<td>
int
</td>
<td>
ELAPSED_REALTIME_WAKEUP
</td>
<td>
能唤醒系统，用法同ELAPSED_REALTIME
</td>
</tr>
<tr>
<td>
int
</td>
<td>
RTC
</td>
<td>
当系统进入睡眠状态时，该闹铃不会唤醒系统，直到系统下次被唤醒才传递它。该闹铃使用绝对时间，通过System.currentTimeMillis()获得
</td>
</tr>
<tr>
<td>
int
</td>
<td>
RTC_WAKEUP
</td>
<td>
能唤醒系统，用法同RTC
</td>
</tr>
<tr>
<td>
int
</td>
<td>
POWER_OFF_WAKEUP
</td>
<td>
能唤醒系统，它是一种关机闹铃，就是说设备在关机状态下也可以唤醒系统，所以我们把它称之为关机闹铃。使用方法同RTC类型
</td>
</tr>
</table>

<h2 id="toc_1.4">PendingIntent主要方法</h2>
<ul>
<li>
<strong>PendingIntent可以说是Intent的进一步封装，它既包含了Intent的描述又包含了Intent行为的执行</strong>

</ul>

<table>
<tr>
<th>
返回值
</th>
<th>
方法名称
</th>
<th>
描述
</th>
</tr>
<tr>
<td>
static PendingIntent
</td>
<td>
getActivity(Context context, int requestCode, Intent intent, int flags)
</td>
<td>
获得一个Activity的Intent
</td>
</tr>
<tr>
<td>
static PendingIntent
</td>
<td>
getBroadcast(Context context, int requestCode, Intent intent, int flags)
</td>
<td>
获得一个Broadcast的Intent
</td>
</tr>
<tr>
<td>
static PendingIntent
</td>
<td>
getService(Context context, int requestCode, Intent intent, int flags)
</td>
<td>
获得一个Service的Intent
</td>
</tr>
<tr>
<td>
IntentSender
</td>
<td>
getIntentSender()
</td>
<td>
获得IntentSender对象
</td>
</tr>
<tr>
<td>
void
</td>
<td>
send(int code)
</td>
<td>
执行相关的Intent
</td>
</tr>
<tr>
<td>
void
</td>
<td>
send(Context context, int code, Intent intent)
</td>
<td>
执行相关的Intent
</td>
</tr>
<tr>
<td>
void
</td>
<td>
send(int code, PendingIntent.OnFinished onFinished, Handler handler)
</td>
<td>
执行相关的Intent
</td>
</tr>
<tr>
<td>
void
</td>
<td>
send(Context context, int code, Intent intent, PendingIntent.OnFinished onFinished, Handler handler)
</td>
<td>
执行相关的Intent
</td>
</tr>
<tr>
<td>
void
</td>
<td>
send()
</td>
<td>
执行相关的Intent
</td>
</tr>
<tr>
<td>
void
</td>
<td>
cancel()
</td>
<td>
取消当前激活的Intent
</td>
</tr>
</table>

<h2 id="toc_1.5">示例代码</h2>
<h3 id="toc_1.5.1">单次报警器</h3>
<ul>
<li>
创建一个BroadcastReceiver的派生类,作为接收方,重写onReceive方法

<li>
创建一个PendingIntent的实例作为发送方,使用getBroadcast方法将之与接收方关联

<li>
创建Calendar实例,设置一个时钟,用在将来一个时间点触发

<li>
通过getSystemService获取一个AlarmManager对象实例,进行定时发送

</ul>

<h4 id="toc_1.5.1.1">发送方</h4>
<pre class="brush:java">
public void onClick(View v) {
    // When the alarm goes off, we want to broadcast an Intent to our
    // BroadcastReceiver.  Here we make an Intent with an explicit class
    // name to have our own receiver (which has been published in
    // AndroidManifest.xml) instantiated and called, and then create an
    // IntentSender to have the intent executed as a broadcast.
    Intent intent = new Intent(AlarmController.this, OneShotAlarm.class);
    PendingIntent sender = PendingIntent.getBroadcast(AlarmController.this,
            0, intent, 0);

    // We want the alarm to go off 30 seconds from now.
    Calendar calendar = Calendar.getInstance();
    calendar.setTimeInMillis(System.currentTimeMillis());
    calendar.add(Calendar.SECOND, 30);

    // Schedule the alarm!
    AlarmManager am = (AlarmManager)getSystemService(ALARM_SERVICE);
    am.set(AlarmManager.RTC_WAKEUP, calendar.getTimeInMillis(), sender);
}
</pre>

<h4 id="toc_1.5.1.2">接收方</h4>
<pre class="brush:java">
public class OneShotAlarm extends BroadcastReceiver
{
    @Override
    public void onReceive(Context context, Intent intent)
    {
        Toast.makeText(context, R.string.one_shot_received, Toast.LENGTH_SHORT).show();
    }
}
</pre>

<h3 id="toc_1.5.2">重复报警器</h3>
<ul>
<li>
创建一个BroadcastReceiver的派生类,作为接收方,并重写onReceive方法

<li>
创建一个PendingIntent的实例作为发送方,使用getBroadcast方法将之与接收方关联

<li>
设置第一次报警的时间

<li>
通过getSystemService获取一个AlarmManager对象实例,并通过setRepeting方法设置重复的报警器

<li>
通过cancel方法取消重复报警

</ul>

<h4 id="toc_1.5.2.1">发送方</h4>
<pre class="brush:java">
public void onClick(View v) {
    // When the alarm goes off, we want to broadcast an Intent to our
    // BroadcastReceiver.  Here we make an Intent with an explicit class
    // name to have our own receiver (which has been published in
    // AndroidManifest.xml) instantiated and called, and then create an
    // IntentSender to have the intent executed as a broadcast.
    // Note that unlike above, this IntentSender is configured to
    // allow itself to be sent multiple times.
    Intent intent = new Intent(AlarmController.this, RepeatingAlarm.class);
    PendingIntent sender = PendingIntent.getBroadcast(AlarmController.this,
            0, intent, 0);
            
    // We want the alarm to go off 30 seconds from now.
    long firstTime = SystemClock.elapsedRealtime();
    firstTime += 15*1000;

    // Schedule the alarm!
    AlarmManager am = (AlarmManager)getSystemService(ALARM_SERVICE);
    am.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,
                    firstTime, 15*1000, sender);
}
</pre>

<h4 id="toc_1.5.2.2">接收方</h4>
<pre class="brush:java">
public class RepeatingAlarm extends BroadcastReceiver
{
    @Override
    public void onReceive(Context context, Intent intent)
    {
        Toast.makeText(context, R.string.repeating_received, Toast.LENGTH_SHORT).show();
    }
}
</pre>

<h4 id="toc_1.5.2.3">取消重复报警</h4>
<pre class="brush:java">
// And cancel the alarm.
AlarmManager am = (AlarmManager)getSystemService(ALARM_SERVICE);
am.cancel(sender);
</pre>


<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

</body>
</html>
