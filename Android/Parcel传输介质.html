<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Parcel传输介质</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
	<link type="text/css" rel="stylesheet" href="css_style/style_zenki.css"/>

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>


<h1 id="toc_1">Parcel传输介质</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">Parcel传输介质</a></li>
<ul>
<li><a href="#toc_1.1">Parcel的作用</a></li>
<li><a href="#toc_1.2">分析Parcel</a></li>
<li><a href="#toc_1.3">要点总结</a></li>
<li><a href="#toc_1.4">Parcel.h</a></li>
<ul>
<li><a href="#toc_1.4.1">Parcel</a></li>
</ul>
<li><a href="#toc_1.5">Parcel.cpp</a></li>
<ul>
<li><a href="#toc_1.5.1">PAD_SIZE宏定义</a></li>
<li><a href="#toc_1.5.2">Parcel::dataPosition</a></li>
<li><a href="#toc_1.5.3">Parcel::dataSize</a></li>
<li><a href="#toc_1.5.4">Parcel::readAligned</a></li>
<li><a href="#toc_1.5.5">Parcel::writeAligned</a></li>
<li><a href="#toc_1.5.6">Parcel::write</a></li>
<li><a href="#toc_1.5.7">Parcel::writeInplace</a></li>
<li><a href="#toc_1.5.8">Parcel::read</a></li>
<li><a href="#toc_1.5.9">Parcel::readInplace</a></li>
<li><a href="#toc_1.5.10">flatten_binder</a></li>
<li><a href="#toc_1.5.11">unflatten_binder</a></li>
<li><a href="#toc_1.5.12">Parcel::finishWrite</a></li>
<li><a href="#toc_1.5.13">Parcel::growData</a></li>
<li><a href="#toc_1.5.14">Parcel::continueWrite</a></li>
<li><a href="#toc_1.5.15">acquire_object</a></li>
</ul>
<li><a href="#toc_1.6">IPCThreadState.cpp</a></li>
<ul>
<li><a href="#toc_1.6.1">IPCThreadState::joinThreadPool</a></li>
<li><a href="#toc_1.6.2">IPCThreadState::talkWithDriver</a></li>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">Parcel的作用</h2>
<pre class="brush:text">
    我们都知道JAVA中的Serialize机制，译成串行化、序列化……，其作用是能将数据对象存入字节流当中，在需要时重新生成对象。
Android也提供了这样一种机制，而且效率更加高效，所有序列化的行为都在内存中完成。
    Parcel不仅支持普通数据类型的序列化，而且支持Binder对象的序列化。
</pre>

<h2 id="toc_1.2">分析Parcel</h2>
<ul>
<li>
从Parcel类的构造方法可以看到该类保存普通数据和Binder类型的数据分别采用不同的成员<code>mData</code>和<code>mObjects</code>，并提供了读数据的<code>read*</code>方法和写数据的<code>write*</code>方法。
</li>
<li>
之前讨论<a href="驱动适配层.html">驱动适配层</a>时发现IPCThreadState包含两个Parcel的成员对象<code>mIn</code>和<code>mOut</code>，分别代表从驱动读出的数据和写入到驱动中的数据。我们以IPCThreadState::joinThreadPool为例来分析Parcel的运用和实现：
</li>
<ul>
<li>
首先根据isMain的标识往mOut中写入BC_ENTER_LOOPER或BC_REGISTER_LOOPER命令，通知驱动当前的线程状态。writeInt32()方法会调用<code>writeAligned()</code>方法。它首先检查分配的内存大小是否能够容纳写入的数据，如果满足条件，就会给当前的数据指针增加偏移值，再调用finishWrite()方法完成写入操作;否则会调用<code>growData()</code>方法扩充内存大小，它会按照<code>((mDataSize+len)*3)/2</code>的大小分配新的内存空间，并调用<code>continueWrite()</code>方法。continueWrite()会分几种情况处理，具体操作参见continueWrite()的注释。需要注意的是mOwner是一个回调函数指针，用来通知驱动释放它的内存空间。
</li>
<li>
接下来joinThreadPool会进入一个while循环，第一个条件语句调用了mIn的<code>dataPosition()</code>和<code>dataSize()</code>方法，这两个方法分别返回当前指针的偏移位置<code>mDataPos</code>和数据的大小<code>mDataSize</code>。通常我们写入数据会增加mDataPos的值，最终在finishWrite()中会将该值赋予mDataSize。
</li>
<li>
第二个条件语句，IPCThreadState会调用mIn的<code>dataAvail()</code>方法检查请求缓冲区，读取命令字段，再发送给驱动。dataAvail()方法会返回<code>mDataSize-mDataPos</code>。可以在talkWithDriver()方法中发现，如果<code>bwr.read_consumed &gt; 0</code>，则会将mDataPos置为0，因此从dataAvail()的结果判断至少需要int32_t大小的数据才会执行读取操作。如果小于这个数值就continue，否则使用readInt32()方法取出一个int32_t大小数据作为的命令请求发送给驱动。readInt32()会调用<code>readAligned()</code>方法读取指定大小的数据。与此同时，mDataPos的偏移量则改为了<code>mDataPos += sizeof(T)</code>。
</li>
<li>
从目前的分析我们可以发现Parcel的数据是按顺序写入，mDataPos维护这个数据偏移大小的位置，读数据的时候也是按照这个顺序读出来，相应的mDataPos的大小也会改变。通常我们可以理解为<code>当前数据的地址 = 数据起始地址 + 数据偏移地址</code>。
</li>
<li>
Parcel提供了一组read*和write*方法，我们只分析了readInt32()和writeInt32，还有诸如read()、write()、readCString()、writeCString()、readObject()、writeObject()等。其中需要注意的一个细节是<code>PAD_SIZE</code>这个宏，作用是在读写是以<code>4个字节</code>大小对齐，也就是说数据包的字节大小永远是4的倍数。
</li>
</ul>
</ul>

<h2 id="toc_1.3">要点总结</h2>
<ul>
<li>
我们以joinThreadPool()方法流程为例分析了Parcel在Binder传输中的作用，可以做出以下总结：
</li>
<ul>
<li>
序列化主要是进行内存分配，内存拷贝等，所有读写数据的行为都是在内存中，因此效率比较高。
</li>
<li>
<code>读写数据都是4字节对齐的。</code>
</li>
<li>
如果空间不足，会根据((mDataSize+len)*3)/2大小的字节进行扩充。
</li>
<li>
普通数据和IBinder数据分别通过mData和mObjects保存。并且对于整型/浮点型、字符串型和IBinder类型采用不同的处理方式(查看read*和write*方法)。
</li>
<li>
<code>Parcel对数据读写的特性决定了它能够保存一个对象到内存中，再读取该段内存数据后还可以还原这个对象，并借助Binder机制来实现跨进程的对象序列化功能。</code>
</li>
<li>
Parcel还具备与生俱来的与驱动交互的特性，从flatten_binder()和unflatten_binder()中发现在读取IBinder对象类型时，会使用ProcessState对象与驱动交互。
</li>
</ul>
</ul>

<h2 id="toc_1.4">Parcel.h</h2>
<h3 id="toc_1.4.1">Parcel</h3>
<pre class="brush:c++">
class Parcel
{
public:
                        Parcel();
                        ~Parcel();
    
    const uint8_t*      data() const;
    size_t              dataSize() const;
    size_t              dataAvail() const;
    size_t              dataPosition() const;
    size_t              dataCapacity() const;
    
    status_t            setDataSize(size_t size);
    void                setDataPosition(size_t pos) const;
    status_t            setDataCapacity(size_t size);
    
    status_t            setData(const uint8_t* buffer, size_t len);

    status_t            appendFrom(Parcel *parcel, size_t start, size_t len);

    bool                hasFileDescriptors() const;

    status_t            writeInterfaceToken(const String16&amp; interface);
    bool                enforceInterface(const String16&amp; interface) const;
    bool                checkInterface(IBinder*) const;    

    void                freeData();

    const size_t*       objects() const;
    size_t              objectsCount() const;
    
    status_t            errorCheck() const;
    void                setError(status_t err);
    
    status_t            write(const void* data, size_t len);
    void*               writeInplace(size_t len);
    status_t            writeUnpadded(const void* data, size_t len);
    status_t            writeInt32(int32_t val);
    status_t            writeInt64(int64_t val);
    status_t            writeFloat(float val);
    status_t            writeDouble(double val);
    status_t            writeIntPtr(intptr_t val);
    status_t            writeCString(const char* str);
    status_t            writeString8(const String8&amp; str);
    status_t            writeString16(const String16&amp; str);
    status_t            writeString16(const char16_t* str, size_t len);
    status_t            writeStrongBinder(const sp&lt;IBinder&gt;&amp; val);
    status_t            writeWeakBinder(const wp&lt;IBinder&gt;&amp; val);

    // Place a native_handle into the parcel (the native_handle's file-
    // descriptors are dup'ed, so it is safe to delete the native_handle
    // when this function returns). 
    // Doesn't take ownership of the native_handle.
    status_t            writeNativeHandle(const native_handle* handle);
    
    // Place a file descriptor into the parcel.  The given fd must remain
    // valid for the lifetime of the parcel.
    status_t            writeFileDescriptor(int fd);
    
    // Place a file descriptor into the parcel.  A dup of the fd is made, which
    // will be closed once the parcel is destroyed.
    status_t            writeDupFileDescriptor(int fd);
    
    status_t            writeObject(const flat_binder_object&amp; val, bool nullMetaData);

    void                remove(size_t start, size_t amt);
    
    status_t            read(void* outData, size_t len) const;
    const void*         readInplace(size_t len) const;
    int32_t             readInt32() const;
    status_t            readInt32(int32_t *pArg) const;
    int64_t             readInt64() const;
    status_t            readInt64(int64_t *pArg) const;
    float               readFloat() const;
    status_t            readFloat(float *pArg) const;
    double              readDouble() const;
    status_t            readDouble(double *pArg) const;
    intptr_t            readIntPtr() const;
    status_t            readIntPtr(intptr_t *pArg) const;

    const char*         readCString() const;
    String8             readString8() const;
    String16            readString16() const;
    const char16_t*     readString16Inplace(size_t* outLen) const;
    sp&lt;IBinder&gt;         readStrongBinder() const;
    wp&lt;IBinder&gt;         readWeakBinder() const;

    
    // Retrieve native_handle from the parcel. This returns a copy of the
    // parcel's native_handle (the caller takes ownership). The caller
    // must free the native_handle with native_handle_close() and 
    // native_handle_delete().
    native_handle*     readNativeHandle() const;

    
    // Retrieve a file descriptor from the parcel.  This returns the raw fd
    // in the parcel, which you do not own -- use dup() to get your own copy.
    int                 readFileDescriptor() const;
    
    const flat_binder_object* readObject(bool nullMetaData) const;

    // Explicitly close all file descriptors in the parcel.
    void                closeFileDescriptors();
    
    typedef void        (*release_func)(Parcel* parcel,
                                        const uint8_t* data, size_t dataSize,
                                        const size_t* objects, size_t objectsSize,
                                        void* cookie);
                        
    const uint8_t*      ipcData() const;
    size_t              ipcDataSize() const;
    const size_t*       ipcObjects() const;
    size_t              ipcObjectsCount() const;
    void                ipcSetDataReference(const uint8_t* data, size_t dataSize,
                                            const size_t* objects, size_t objectsCount,
                                            release_func relFunc, void* relCookie);
    
    void                print(TextOutput&amp; to, uint32_t flags = 0) const;
        
private:
                        Parcel(const Parcel&amp; o);
    Parcel&amp;             operator=(const Parcel&amp; o);
    
    status_t            finishWrite(size_t len);
    void                releaseObjects();
    void                acquireObjects();
    status_t            growData(size_t len);
    status_t            restartWrite(size_t desired);
    status_t            continueWrite(size_t desired);
    void                freeDataNoInit();
    void                initState();
    void                scanForFds() const;
                        
    template&lt;class T&gt;
    status_t            readAligned(T *pArg) const;

    template&lt;class T&gt;   T readAligned() const;

    template&lt;class T&gt;
    status_t            writeAligned(T val);

    status_t            mError;
    uint8_t*            mData;
    size_t              mDataSize;
    size_t              mDataCapacity;
    mutable size_t      mDataPos;
    size_t*             mObjects;
    size_t              mObjectsSize;
    size_t              mObjectsCapacity;
    mutable size_t      mNextObjectHint;

    mutable bool        mFdsKnown;
    mutable bool        mHasFds;
    
    release_func        mOwner;
    void*               mOwnerCookie;
};
</pre>

<h2 id="toc_1.5">Parcel.cpp</h2>
<h3 id="toc_1.5.1">PAD_SIZE宏定义</h3>
<pre class="brush:c++">
#define PAD_SIZE(s) (((s)+3)&amp;~3)
</pre>

<h3 id="toc_1.5.2">Parcel::dataPosition</h3>
<pre class="brush:c++">
size_t Parcel::dataPosition() const
{
    return mDataPos;
}
</pre>

<h3 id="toc_1.5.3">Parcel::dataSize</h3>
<pre class="brush:c++">
size_t Parcel::dataSize() const
{
    return (mDataSize &gt; mDataPos ? mDataSize : mDataPos);
}
</pre>

<h3 id="toc_1.5.4">Parcel::readAligned</h3>
<pre class="brush:c++">
template&lt;class T&gt;
status_t Parcel::readAligned(T *pArg) const {
    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE(sizeof(T)) == sizeof(T));

    // 如果数据大小没有超出范围则进行数据的转换
    if ((mDataPos+sizeof(T)) &lt;= mDataSize) {
        // 当前数据的地址 = 起始地址 + 数据偏移
        const void* data = mData+mDataPos;
        // 数据的偏移加上T的大小
        mDataPos += sizeof(T);
        // 从当前的起始地址开始转换T类型数据并通过指针回传
        *pArg =  *reinterpret_cast&lt;const T*&gt;(data);
        return NO_ERROR;
    } else {
        return NOT_ENOUGH_DATA;
    }
}
</pre>

<h3 id="toc_1.5.5">Parcel::writeAligned</h3>
<pre class="brush:c++">
template&lt;class T&gt;
status_t Parcel::writeAligned(T val) {
    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE(sizeof(T)) == sizeof(T));

    // 如果有足够大的内存空间，则将mData+mDataPos的指针指向T数据
    if ((mDataPos+sizeof(val)) &lt;= mDataCapacity) {
restart_write:
        *reinterpret_cast&lt;T*&gt;(mData+mDataPos) = val;
        return finishWrite(sizeof(val));
    }

    // 否则增加内存空间的大小
    status_t err = growData(sizeof(val));
    if (err == NO_ERROR) goto restart_write;
    return err;
}
</pre>

<h3 id="toc_1.5.6">Parcel::write</h3>
<pre class="brush:c++">
status_t Parcel::write(const void* data, size_t len)
{
    void* const d = writeInplace(len);
    if (d) {
        memcpy(d, data, len);
        return NO_ERROR;
    }
    return mError;
}
</pre>

<h3 id="toc_1.5.7">Parcel::writeInplace</h3>
<pre class="brush:c++">
void* Parcel::writeInplace(size_t len)
{
    const size_t padded = PAD_SIZE(len);

    // sanity check for integer overflow
    if (mDataPos+padded &lt; mDataPos) {
        return NULL;
    }

    if ((mDataPos+padded) &lt;= mDataCapacity) {
restart_write:
        uint8_t* const data = mData+mDataPos;

        // Need to pad at end?
        if (padded != len) {
#if BYTE_ORDER == BIG_ENDIAN
            static const uint32_t mask[4] = {
                0x00000000, 0xffffff00, 0xffff0000, 0xff000000
            };
#endif
#if BYTE_ORDER == LITTLE_ENDIAN
            static const uint32_t mask[4] = {
                0x00000000, 0x00ffffff, 0x0000ffff, 0x000000ff
            };
#endif
            *reinterpret_cast&lt;uint32_t*&gt;(data+padded-4) &amp;= mask[padded-len];
        }

        finishWrite(padded);
        return data;
    }

    status_t err = growData(padded);
    if (err == NO_ERROR) goto restart_write;
    return NULL;
}
</pre>

<h3 id="toc_1.5.8">Parcel::read</h3>
<pre class="brush:c++">
status_t Parcel::read(void* outData, size_t len) const
{
    if ((mDataPos+PAD_SIZE(len)) &gt;= mDataPos &amp;&amp; (mDataPos+PAD_SIZE(len)) &lt;= mDataSize) {
        memcpy(outData, mData+mDataPos, len);
        mDataPos += PAD_SIZE(len);
        return NO_ERROR;
    }
    return NOT_ENOUGH_DATA;
}
</pre>

<h3 id="toc_1.5.9">Parcel::readInplace</h3>
<pre class="brush:c++">
const void* Parcel::readInplace(size_t len) const
{
    if ((mDataPos+PAD_SIZE(len)) &gt;= mDataPos &amp;&amp; (mDataPos+PAD_SIZE(len)) &lt;= mDataSize) {
        const void* data = mData+mDataPos;
        mDataPos += PAD_SIZE(len);
        return data;
    }
    return NULL;
}
</pre>

<h3 id="toc_1.5.10">flatten_binder</h3>
<pre class="brush:c++">
status_t flatten_binder(const sp&lt;ProcessState&gt;&amp; proc,
    const sp&lt;IBinder&gt;&amp; binder, Parcel* out)
{
    flat_binder_object obj;
    
    obj.flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;
    if (binder != NULL) {
        // 获取本地Binder对象
        IBinder *local = binder-&gt;localBinder();
        if (!local) {
            BpBinder *proxy = binder-&gt;remoteBinder();
            if (proxy == NULL) {
                LOGE("null proxy");
            }
            // 如果是代理对象，则保存句柄
            const int32_t handle = proxy ? proxy-&gt;handle() : 0;
            obj.type = BINDER_TYPE_HANDLE;
            obj.handle = handle;
            obj.cookie = NULL;
        } else {
            // 如果是本地对象，则保存weakref_type对象和IBinder对象
            obj.type = BINDER_TYPE_BINDER;
            obj.binder = local-&gt;getWeakRefs();
            obj.cookie = local;
        }
    } else {
        obj.type = BINDER_TYPE_BINDER;
        obj.binder = NULL;
        obj.cookie = NULL;
    }
    
    return finish_flatten_binder(binder, obj, out);
}
</pre>

<h3 id="toc_1.5.11">unflatten_binder</h3>
<pre class="brush:c++">
status_t unflatten_binder(const sp&lt;ProcessState&gt;&amp; proc,
    const Parcel&amp; in, sp&lt;IBinder&gt;* out)
{
    const flat_binder_object* flat = in.readObject(false);
    
    if (flat) {
        switch (flat-&gt;type) {
            // 如果是本地Binder，则进行类型转换
            case BINDER_TYPE_BINDER:
                *out = static_cast&lt;IBinder*&gt;(flat-&gt;cookie);
                return finish_unflatten_binder(NULL, *flat, in);
            // 如果是代理对象，则需要通过proc向驱动查询
            case BINDER_TYPE_HANDLE:
                *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle);
                return finish_unflatten_binder(
                    static_cast&lt;BpBinder*&gt;(out-&gt;get()), *flat, in);
        }        
    }
    return BAD_TYPE;
}
</pre>

<h3 id="toc_1.5.12">Parcel::finishWrite</h3>
<pre class="brush:c++">
status_t Parcel::finishWrite(size_t len)
{
    // 简单的赋予数据大小的值
    mDataPos += len;
    // 如果mDataPos大于mDataSize，则将较大的值赋予mDataSize
    if (mDataPos &gt; mDataSize) {
        mDataSize = mDataPos;
    }
    return NO_ERROR;
}
</pre>

<h3 id="toc_1.5.13">Parcel::growData</h3>
<pre class="brush:c++">
status_t Parcel::growData(size_t len)
{
    // 按照((mDataSize+len)*3)/2的大小分配新的内存空间
    size_t newSize = ((mDataSize+len)*3)/2;
    return (newSize &lt;= mDataSize)
            ? (status_t) NO_MEMORY
            : continueWrite(newSize);
}
</pre>

<h3 id="toc_1.5.14">Parcel::continueWrite</h3>
<pre class="brush:c++">
status_t Parcel::continueWrite(size_t desired)
{
    // 如果缩小内存，则减少Binder对象
    size_t objectsSize = mObjectsSize;
    if (desired &lt; mDataSize) {
        if (desired == 0) {
            objectsSize = 0;
        } else {
            while (objectsSize &gt; 0) {
                if (mObjects[objectsSize-1] &lt; desired)
                    break;
                objectsSize--;
            }
        }
    }
    
    // 如果有mOwner的回调方法，则分配空间，做内存拷贝操作
    if (mOwner) {
        ......

        uint8_t* data = (uint8_t*)malloc(desired);
        
        ......

        mData = data;
        mObjects = objects;
        mDataSize = (mDataSize &lt; desired) ? mDataSize : desired;
        mDataCapacity = desired;
        mObjectsSize = mObjectsCapacity = objectsSize;
        mNextObjectHint = 0;
        
    // 如果当前存在数据，则做realloc操作
    } else if (mData) {
        if (objectsSize &lt; mObjectsSize) {
            ......

            size_t* objects =
                (size_t*)realloc(mObjects, objectsSize*sizeof(size_t));
            if (objects) {
                mObjects = objects;
            }
            mObjectsSize = objectsSize;
            mNextObjectHint = 0;
        }

        if (desired &gt; mDataCapacity) {
            uint8_t* data = (uint8_t*)realloc(mData, desired);
            if (data) {
                mData = data;
                mDataCapacity = desired;
            } else if (desired &gt; mDataCapacity) {
                mError = NO_MEMORY;
                return NO_MEMORY;
            }
        } else {
            ......
        }
        
    // 第一次初始化，直接做malloc操作
    } else {
        uint8_t* data = (uint8_t*)malloc(desired);
        
        ......
        
        mData = data;
        mDataSize = mDataPos = 0;
        mDataCapacity = desired;
    }

    return NO_ERROR;
}
</pre>

<h3 id="toc_1.5.15">acquire_object</h3>
<pre class="brush:c++">
void acquire_object(const sp&lt;ProcessState&gt;&amp; proc,
    const flat_binder_object&amp; obj, const void* who)
{
    switch (obj.type) {
        case BINDER_TYPE_BINDER:
            if (obj.binder) {
                static_cast&lt;IBinder*&gt;(obj.cookie)-&gt;incStrong(who);
            }
            return;
        case BINDER_TYPE_WEAK_BINDER:
            if (obj.binder)
                static_cast&lt;RefBase::weakref_type*&gt;(obj.binder)-&gt;incWeak(who);
            return;
        case BINDER_TYPE_HANDLE: {
            const sp&lt;IBinder&gt; b = proc-&gt;getStrongProxyForHandle(obj.handle);
            if (b != NULL) {
                b-&gt;incStrong(who);
            }
            return;
        }
        case BINDER_TYPE_WEAK_HANDLE: {
            const wp&lt;IBinder&gt; b = proc-&gt;getWeakProxyForHandle(obj.handle);
            if (b != NULL) b.get_refs()-&gt;incWeak(who);
            return;
        }
        case BINDER_TYPE_FD: {
            return;
        }
    }
}
</pre>

<h2 id="toc_1.6">IPCThreadState.cpp</h2>
<h3 id="toc_1.6.1">IPCThreadState::joinThreadPool</h3>
<pre class="brush:c++">
void IPCThreadState::joinThreadPool(bool isMain)
{
    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);
    
    status_t result;
    do {
        ......

        if (mIn.dataPosition() &gt;= mIn.dataSize()) {
            ......
        }

        result = talkWithDriver();
        if (result &gt;= NO_ERROR) {
            size_t IN = mIn.dataAvail();
            // 如果可用数据大小小于int32_t，则continue
            if (IN &lt; sizeof(int32_t)) continue;
            cmd = mIn.readInt32();

            result = executeCommand(cmd);
        }
        
        ......

    } while (result != -ECONNREFUSED &amp;&amp; result != -EBADF);

    mOut.writeInt32(BC_EXIT_LOOPER);
    talkWithDriver(false);
}
</pre>

<h3 id="toc_1.6.2">IPCThreadState::talkWithDriver</h3>
<pre class="brush:c++">
status_t IPCThreadState::talkWithDriver(bool doReceive)
{
    .....

    if (err &gt;= NO_ERROR) {
        if (bwr.write_consumed &gt; 0) {
            if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize())
                mOut.remove(0, bwr.write_consumed);
            else
                mOut.setDataSize(0);
        }
        // 将mDataPos置0
        if (bwr.read_consumed &gt; 0) {
            mIn.setDataSize(bwr.read_consumed);
            mIn.setDataPosition(0);
        }
        
        return NO_ERROR;
    }
    
    ......
}
</pre>
<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

<!--<script type="text/javascript">-->
<!--var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");-->
<!--document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));-->
<!--</script>-->
<!--<script type="text/javascript">-->
<!--try {-->
<!--var pageTracker = _gat._getTracker("UA-15922433-1");-->
<!--pageTracker._trackPageview();-->
<!--} catch(err) {}-->
<!--</script>-->

</body>
</html>
