<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Vold功能实现</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
	<link type="text/css" rel="stylesheet" href="css_style/style_zenki.css"/>

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>


<h1 id="toc_1">Vold功能实现</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">Vold功能实现</a></li>
<ul>
<li><a href="#toc_1.1">相关文件</a></li>
<li><a href="#toc_1.2">主流程解析</a></li>
<li><a href="#toc_1.3">模块分类</a></li>
<ul>
<li><a href="#toc_1.3.1">挂载点及其管理</a></li>
<li><a href="#toc_1.3.2">socket连接及其管理</a></li>
<li><a href="#toc_1.3.3">命令抽象</a></li>
<li><a href="#toc_1.3.4">内核事件抽象</a></li>
</ul>
</ul>
<li><a href="#toc_2">要点解析</a></li>
<ul>
<li><a href="#toc_2.1">接收framework指令</a></li>
<ul>
<li><a href="#toc_2.1.1">CommandListener::CommandListener</a></li>
<li><a href="#toc_2.1.2">SocketListener::startListener</a></li>
<li><a href="#toc_2.1.3">SocketListener::runListener</a></li>
<li><a href="#toc_2.1.4">FrameworkListener::onDataAvailable</a></li>
<li><a href="#toc_2.1.5">FrameworkListener::dispatchCommand</a></li>
<li><a href="#toc_2.1.6">CommandListener::VolumeCmd::runCommand</a></li>
</ul>
<li><a href="#toc_2.2">接收和上报内核事件</a></li>
<ul>
<li><a href="#toc_2.2.1">NetlinkManager::start</a></li>
<li><a href="#toc_2.2.2">NetlinkHandler::start</a></li>
<li><a href="#toc_2.2.3">NetlinkListener::onDataAvailable</a></li>
<li><a href="#toc_2.2.4">NetlinkEvent::decode</a></li>
<li><a href="#toc_2.2.5">NetlinkHandler::onEvent</a></li>
<li><a href="#toc_2.2.6">VolumeManager::handleBlockEvent</a></li>
<li><a href="#toc_2.2.7">VolumeManager::handleSwitchEvent</a></li>
<li><a href="#toc_2.2.8">VolumeManager::handleUsbCompositeEvent</a></li>
<li><a href="#toc_2.2.9">VolumeManager::notifyUmsAvailable</a></li>
<li><a href="#toc_2.2.10">VolumeManager::notifySIMCardAvailable</a></li>
<li><a href="#toc_2.2.11">DirectVolume::handleBlockEvent</a></li>
</ul>
<li><a href="#toc_2.3">如何向Framework发送消息</a></li>
<ul>
<li><a href="#toc_2.3.1">SocketListener::sendBroadcast</a></li>
<li><a href="#toc_2.3.2">ResponseCode</a></li>
<li><a href="#toc_2.3.3">上报消息的通信协议</a></li>
<ul>
<li><a href="#toc_2.3.3.1">磁盘操作的通信协议</a></li>
<li><a href="#toc_2.3.3.2">状态变更的通信协议</a></li>
</ul>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">相关文件</h2>
<pre class="brush:text">
system/vold/main.cpp
system/vold/CommandListener.cpp
system/vold/DirectVolume.cpp
system/vold/NetlinkManager.cpp
system/vold/NetlinkHandler.cpp
system/vold/Volume.cpp
system/vold/VolumeManager.cpp
</pre>

<h2 id="toc_1.2">主流程解析</h2>
<ul>
<li>
main()方法主要执行以下流程：
</li>
<ul>
<li>
创建VolumeManager单例对象。该对象包含一个Volume对象的列表，通过这些Volume对象对设备做具体操作。
</li>
<li>
创建NetlinkManager单例对象。该对象主要是创建与内核通信的socket，并接收来自底层的信息，然后传交给VolumeManager处理。
</li>
<li>
创建CommandListener对象，该对象用来和framework层通讯。
</li>
<li>
process_config方法解析vold.fstab文件，创建DirectVolume对象并加入链表。参见<a href="什么是Vold.html">什么是Vold</a>。
</li>
<li>
通过NetlinkManager启动线程监听来自内核的事件。
</li>
<li>
coldboot()用来对指定目录下uevent文件写入add信息，触发uevent事件。
</li>
<li>
通过CommandListener对象开启线程获取来自framework层的命令。
</li>
<li>
进入循环状态。
</li>
</ul>
</ul>

<pre class="brush:c++">
int main() {
    ......
    // 创建VolumeManager单例对象
    if (!(vm = VolumeManager::Instance())) {
        exit(1);
    };

    // 创建NetlinkManager单例对象
    if (!(nm = NetlinkManager::Instance())) {
        exit(1);
    };

    // 创建CommandListener
    cl = new CommandListener();
    vm-&gt;setBroadcaster((SocketListener *) cl);
    nm-&gt;setBroadcaster((SocketListener *) cl);

    if (vm-&gt;start()) {
        exit(1);
    }

    // 解析vold.fstab配置文件
    if (process_config(vm)) {
    }

    // 监听内核的消息
    if (nm-&gt;start()) {
        exit(1);
    }

    // 通知内核上报uevent事件
    coldboot("/sys/block");

    // 监听framework层的消息
    if (cl-&gt;startListener()) {
        exit(1);
    }

    while(1) {
        sleep(1000);
    }

    exit(0);
}
</pre>

<h2 id="toc_1.3">模块分类</h2>
<h3 id="toc_1.3.1">挂载点及其管理</h3>
<ul>
<li>
被挂载的设备或分区称为磁盘卷标，这个磁盘卷标被抽象成<code>Volume</code>对象，<code>该对象实现了对于磁盘的通用操作方法</code>。
</li>
<li>
DirectVolume是Volume的子类，从vold.fstab中读取的每个需要挂载的设备都被实例化为<code>DirectVolume</code>对象，该对象提供一系列handle操作，<code>主要是实现了与Framework的交互</code>。而对于磁盘的操作则由基类基完成。
</li>
<li>
VolumeManager是Volume的管理类，它包含Volume对象列表，在必要时会遍历这个列表对指定的Volume对象做操作。它包含一个CommandListener对象，为与Framework通讯提供了方法。
</li>
</ul>

<p>
<a href="pic/volume.png"><img src="pic/volume.png" /></a>
</p>

<h3 id="toc_1.3.2">socket连接及其管理</h3>
<ul>
<li>
Vold与framework层及内核通讯的机制是使用socket。SocketListener是对socket封装的抽象类。
</li>
<ul>
<li>
连接framework层
</li>
<ul>
<li>
FrameworkListener继承自SocketListener，该类同样是抽象类，具体实现子类为CommandListener。它负责与framework层通讯。
</li>
<li>
与framework层通信主要关注的是<code>onDataAvailable</code>方法，该方法又调用<code>dispatchCommand</code>找到相应的Command对象做事件处理。
</li>
</ul>
<li>
连接内核层
</li>
<ul>
<li>
NetlinkListener继承自SocketListener，该类同样是抽象类，具体实现子类为NetlinkHandler。它用来与内核层通讯，将来自内核层的uevent事件向上传递。
</li>
<li>
与内核通信主要关注的是<code>onEvent</code>方法，它通过调用VolumeManager类的<code>handle*</code>方法，将事件通知给framework层。
</li>
<li>
NetlinkManager用来管理NetlinkHander对象。
</li>
</ul>
<li>
从数据流向上分析，和Framework的通信是双向的，而和内核的通信则是单向的，也就是说只能接收内核层的消息。
</li>
</ul>
<li>
SocketListener是作为通信的监听端，接收到客户端请求后会得到一个Socket文件句柄：
</li>
<ul>
<li>
该句柄被封装成SocketClient对象，并将该对象会作为参数传递给FrameworkCommand-&gt;runCommand()方法，从而实现Socket通信过程。
</li>
<li>
SocketListener会维护一个SocketClient对象的集合，从而处理多个客户端请求。
</li>
</ul>
</ul>

<p>
<a href="pic/socketlistener.png"><img src="pic/socketlistener.png" /></a>
</p>

<h3 id="toc_1.3.3">命令抽象</h3>
<ul>
<li>
Framework层的命令通道被抽象成FrameworkCommand类。该类为抽象类，它有个中间子类VolumeCommand，由这个子类派生的实现类分别完成不同的功能。
</li>
<li>
具体子类完成的功能是解析来自Framework层的字符串命令，然后再通过VolumeManager实现相应的功能。
</li>
</ul>

<p>
<a href="pic/command.png"><img src="pic/command.png" /></a>
</p>

<h3 id="toc_1.3.4">内核事件抽象</h3>
<ul>
<li>
内核层的uevent事件被抽象成NetlinkEvent类，该类主要用来解析uevent文件中的add、remove、change等事件信息。
</li>
</ul>

<p>
<a href="pic/netlinkevent.png"><img src="pic/netlinkevent.png" /></a>
</p>

<h1 id="toc_2">要点解析</h1>
<h2 id="toc_2.1">接收framework指令</h2>
<ul>
<li>
CommandListener在初始化时会注册VolumeCommand的实现子类，用来处理framework层的指令。
</li>
</ul>

<h3 id="toc_2.1.1">CommandListener::CommandListener</h3>
<pre class="brush:c++">
CommandListener::CommandListener() :
                 FrameworkListener("vold") {
    registerCmd(new DumpCmd());
    registerCmd(new VolumeCmd());
    registerCmd(new AsecCmd());
    registerCmd(new ObbCmd());
    registerCmd(new ShareCmd());
    registerCmd(new StorageCmd());
    registerCmd(new XwarpCmd());
}
</pre>

<ul>
<li>
main()方法调用cl-&gt;startListener()开启线程监听来自framework层的指令。
</li>
</ul>

<h3 id="toc_2.1.2">SocketListener::startListener</h3>
<pre class="brush:c++">
int SocketListener::startListener() {
    if (pthread_create(&amp;mThread, NULL, SocketListener::threadStart, this)) {
        return -1;
    }

    return 0;
}
</pre>

<ul>
<li>
SocketListener::threadStart()调用基类SocketListener::runListener()进入处理循环。
</li>
</ul>

<pre class="brush:c++">
void *SocketListener::threadStart(void *obj) {
    SocketListener *me = reinterpret_cast&lt;SocketListener *&gt;(obj);

    me-&gt;runListener();
    pthread_exit(NULL);
    return NULL;
}
</pre>

<ul>
<li>
runListener()方法会调用FrameworkListener::onDataAvailable()方法处理数据。
</li>
</ul>

<h3 id="toc_2.1.3">SocketListener::runListener</h3>
<pre class="brush:c++">
void SocketListener::runListener() {
    ......
    while(1) {
        ...... 
        do {
            for (it = mClients-&gt;begin(); it != mClients-&gt;end(); ++it) {
                if (FD_ISSET(fd, &amp;read_fds)) {
                    // 调用FrameworkListener::onDataAvailable()
                    if (!onDataAvailable(*it)) {
                        ...... 
                    }
                    ......
                }
            }
        } while (0);
    }
}
</pre>

<ul>
<li>
如果数据合法，则会调用dispatchCommand()方法处理这个命令。
</li>
</ul>

<h3 id="toc_2.1.4">FrameworkListener::onDataAvailable</h3>
<pre class="brush:c++">
bool FrameworkListener::onDataAvailable(SocketClient *c) {
    ......
    if ((len = read(c-&gt;getSocket(), buffer, sizeof(buffer) -1)) &lt; 0) {
        return false;
    } else if (!len)
        return false;

    ......
    for (i = 0; i &lt; len; i++) {
        if (buffer[i] == '\0') {
            dispatchCommand(c, buffer + offset);
            offset = i + 1;
        }
    }
    return true;
}
</pre>

<h3 id="toc_2.1.5">FrameworkListener::dispatchCommand</h3>
<ul>
<li>
dispatchCommand()会依次查找并执行符合条件Command对象，并调用其实现的runCommand方法，具体见CommandListener构造方法中注册的命令：
</li>
<ul>
<li>
DumpCmd：打印挂载点信息。
</li>
<li>
<code>VolumeCmd</code>：配置文件中的分区的处理。
</li>
<li>
AsecCmd：Asec分区的处理。
</li>
<li>
ObbCmd：Obb分区的处理。
</li>
<li>
ShareCmd：UMS模式的处理。
</li>
<li>
StorageCmd：列出相关进程的信息。
</li>
<li>
XwrapCmd：Xwrap模式的处理。
</li>
</ul>
</ul>

<pre class="brush:c++">
void FrameworkListener::dispatchCommand(SocketClient *cli, char *data) {
    ......    
    for (i = mCommands-&gt;begin(); i != mCommands-&gt;end(); ++i) {
        ......
        if (!strcmp(argv[0], c-&gt;getCommand())) {
            if (c-&gt;runCommand(cli, argc, argv)) {
            }
            goto out;
        }
    }
    ......
}
</pre>

<h3 id="toc_2.1.6">CommandListener::VolumeCmd::runCommand</h3>
<ul>
<li>
以VolumeCmd为例，该类的runCommand方法会解析来自Framework的消息，该方法有三个参数：
</li>
<ul>
<li>
cli：表示与Framework通信的socket对象。
</li>
<li>
argc：表示从Framework传递来的命令参数的个数。
</li>
<li>
argv：表示命令行的字符串参数。需要注意的是第一个字符串表示Command标识。比如VolumeCmd，该字符串为字符串"Volume"，即该命令对象的名称，用来区分不同的命令。第二个字符串则表示命令，如“mount”。其他字符串则表示用于命令的参数。
</li>
<li>
一条完整的命令示例：volume mount sdcard
</li>
</ul>
<li>
这些命令会通过VolumeManager调用<code>Volume基类的方法</code>进行设备的挂载和卸载等操作。
</li>
</ul>

<pre class="brush:c++">
int CommandListener::VolumeCmd::runCommand(SocketClient *cli,
                                           int argc, char **argv) {
    dumpArgs(argc, argv, -1);

    if (argc &lt; 2) {
        cli-&gt;sendMsg(ResponseCode::CommandSyntaxError, "Missing Argument", false);
        return 0;
    }

    VolumeManager *vm = VolumeManager::Instance();
    int rc = 0;

    if (!strcmp(argv[1], "list")) {
        return vm-&gt;listVolumes(cli);
    } else if (!strcmp(argv[1], "mount")) {
        if (argc != 3) {
            cli-&gt;sendMsg(ResponseCode::CommandSyntaxError, "Usage: volume mount &lt;path&gt;", false);
            return 0;
        }
        rc = vm-&gt;mountVolume(argv[2]);
    } else if (!strcmp(argv[1], "unmount")) {
        if (argc &lt; 3 || argc &gt; 4 || (argc == 4 &amp;&amp; strcmp(argv[3], "force"))) {
            cli-&gt;sendMsg(ResponseCode::CommandSyntaxError, "Usage: volume unmount &lt;path&gt; [force]", false);
            return 0;
        }

        bool force = false;
        if (argc &gt;= 4 &amp;&amp; !strcmp(argv[3], "force")) {
            force = true;
        }
        rc = vm-&gt;unmountVolume(argv[2], force);
    } else {
        cli-&gt;sendMsg(ResponseCode::CommandSyntaxError, "Unknown volume cmd", false);
    }

    if (!rc) {
        cli-&gt;sendMsg(ResponseCode::CommandOkay, "volume operation succeeded", false);
    } else {
        int erno = errno;
        rc = ResponseCode::convertFromErrno();
        cli-&gt;sendMsg(rc, "volume operation failed", true);
    }

    return 0;
}
</pre>

<h2 id="toc_2.2">接收和上报内核事件</h2>
<ul>
<li>
main()方法调用NetlinkManager::start()启动内核事件的监听线程。
</li>
<li>
该方法首先初始化PF_NETLINK的socket，之后调用NetlinkHandler::start()进入监听循环。
</li>
</ul>

<h3 id="toc_2.2.1">NetlinkManager::start</h3>
<pre class="brush:c++">
int NetlinkManager::start() {
    ......
    if ((mSock = socket(PF_NETLINK,
                        SOCK_DGRAM,NETLINK_KOBJECT_UEVENT)) &lt; 0) {
        return -1;
    }

    if (setsockopt(mSock, SOL_SOCKET, SO_RCVBUFFORCE, &amp;sz, sizeof(sz)) &lt; 0) {
        return -1;
    }

    if (setsockopt(mSock, SOL_SOCKET, SO_PASSCRED, &amp;on, sizeof(on)) &lt; 0) {
        return -1;
    }

    if (bind(mSock, (struct sockaddr *) &amp;nladdr, sizeof(nladdr)) &lt; 0) {
        return -1;
    }

    mHandler = new NetlinkHandler(mSock);
    if (mHandler-&gt;start()) {
        return -1;
    }
    return 0;
}
</pre>

<ul>
<li>
随后NetlinkHandler::start()会调用基类的SocketListener::startListener()方法。这步的流程与CommandListener工作流程一样。
</li>
</ul>

<h3 id="toc_2.2.2">NetlinkHandler::start</h3>
<pre class="brush:c++">
int NetlinkHandler::start() {
    // 这里调用基类SocketListener::startListener()
    return this-&gt;startListener();
}
</pre>

<ul>
<li>
由于不同的子类，最终runListener()方法会调用NetlinkListener::onDataAvailable()方法处理数据。
</li>
<li>
通过NetlinkEvent::decode()解析来自内核层的事件信息，如add、remove、change等。
</li>
<li>
如果解析正确，便会通过onEvent()方法处理事件。该方法由NetlinkHandler类实现。
</li>
</ul>

<h3 id="toc_2.2.3">NetlinkListener::onDataAvailable</h3>
<pre class="brush:c++">
bool NetlinkListener::onDataAvailable(SocketClient *cli)
{
    ......
    NetlinkEvent *evt = new NetlinkEvent();
    if (!evt-&gt;decode(mBuffer, count)) {
        goto out;
    }

    onEvent(evt);
out:
    delete evt;
    return true;
}
</pre>

<h3 id="toc_2.2.4">NetlinkEvent::decode</h3>
<ul>
<li>
内核上报的事件由字符串构成，示例如下：
</li>
</ul>

<pre class="brush:c">
add@/devices/platform/msm_sdcc.2/mmc_host/mmc1/mmc1:c9f2/block/mmcblk0
ACTION=add
DEVPATH=/devices/platform/msm_sdcc.2/mmc_host/mmc1/mmc1:c9f2/block/mmcblk0
SUBSYSTEM=block
MAJOR=179
MINOR=0
DEVNAME=mmcblk0
DEVTYPE=disk
NPARTS=3
SEQNUM=1357
</pre>

<ul>
<li>
上面的字符串由NetlinkEvent::decode方法解析，并封装成NetlinkEvent结构。
</li>
</ul>

<pre class="brush:c++">
bool NetlinkEvent::decode(char *buffer, int size) {
    ......
    while (s &lt; end) {
        if (first) {
            ......
        } else {
            if (!strncmp(s, "ACTION=", strlen("ACTION="))) {
                char *a = s + strlen("ACTION=");
                if (!strcmp(a, "add"))
                    mAction = NlActionAdd;
                else if (!strcmp(a, "remove"))
                    mAction = NlActionRemove;
                else if (!strcmp(a, "change"))
                    mAction = NlActionChange;
            } else if (!strncmp(s, "SEQNUM=", strlen("SEQNUM=")))
                mSeq = atoi(s + strlen("SEQNUM="));
            else if (!strncmp(s, "SUBSYSTEM=", strlen("SUBSYSTEM=")))
                mSubsystem = strdup(s + strlen("SUBSYSTEM="));
            else
                mParams[param_idx++] = strdup(s);
        }
        s+= strlen(s) + 1;
    }
    return true;
}
</pre>

<h3 id="toc_2.2.5">NetlinkHandler::onEvent</h3>
<pre class="brush:c++">
void NetlinkHandler::onEvent(NetlinkEvent *evt) {
    VolumeManager *vm = VolumeManager::Instance();
    const char *subsys = evt-&gt;getSubsystem();

    if (!subsys) {
        return;
    }

    if (!strcmp(subsys, "block")) {
        vm-&gt;handleBlockEvent(evt);
    } else if (!strcmp(subsys, "switch")) {
        vm-&gt;handleSwitchEvent(evt);
    } else if (!strcmp(subsys, "usb_composite")) {
        vm-&gt;handleUsbCompositeEvent(evt);
    } else if (!strcmp(subsys, "battery")) {
    } else if (!strcmp(subsys, "power_supply")) {
    }
}
</pre>

<ul>
<li>
onEvent()方法会根据不同的事件类型，调用不同的VolumeManager::handle*方法。
</li>
</ul>

<h3 id="toc_2.2.6">VolumeManager::handleBlockEvent</h3>
<ul>
<li>
在VolumeManager::handleBlockEvent()方法中VolumeManager会遍历Volume对象列表，找到对应的子类DirectVolume对象，并调用其handle*方法。
</li>
</ul>

<pre class="brush:c++">
void VolumeManager::handleBlockEvent(NetlinkEvent *evt) {
    ......
    for (it = mVolumes-&gt;begin(); it != mVolumes-&gt;end(); ++it) {
        if (!(*it)-&gt;handleBlockEvent(evt)) {
            hit = true;
            break;
        }
    }
    ...... 
}
</pre>

<h3 id="toc_2.2.7">VolumeManager::handleSwitchEvent</h3>
<ul>
<li>
该方法检测当前USB的状态，例如连接到PC上时，则会通知PC端UMS模式可用。
</li>
</ul>

<pre class="brush:c++">
void VolumeManager::handleSwitchEvent(NetlinkEvent *evt) {
    ......
    if (!strcmp(name, "usb_configuration")) {
        mUsbConnected = !strcmp(state, "1");
        bool newAvailable = massStorageAvailable();
        if (newAvailable != oldAvailable) {
            notifyUmsAvailable(newAvailable);
        }
	} else if (!strcmp(name, "sim_card_socket")) {
        mSIMCardConnected = !strncmp(state, "closed", 6);
        bool simcard_newAvailable = SIMCardAvailable();
        if (simcard_newAvailable != simcard_oldAvailable) {
            notifySIMCardAvailable(simcard_newAvailable);
        }
    } else {
    }
}
</pre>

<h3 id="toc_2.2.8">VolumeManager::handleUsbCompositeEvent</h3>
<pre class="brush:c++">
void VolumeManager::handleUsbCompositeEvent(NetlinkEvent *evt) {
    const char *function = evt-&gt;findParam("FUNCTION");
    const char *enabled = evt-&gt;findParam("ENABLED");

    if (!function || !enabled) {
        return;
    }

    if (!strcmp(function, "usb_mass_storage")) {
        bool oldAvailable = massStorageAvailable();
        mUsbMassStorageEnabled = !strcmp(enabled, "1");
        bool newAvailable = massStorageAvailable();
        if (newAvailable != oldAvailable) {
            notifyUmsAvailable(newAvailable);
        }
    }
}
</pre>

<h3 id="toc_2.2.9">VolumeManager::notifyUmsAvailable</h3>
<pre class="brush:c++">
void VolumeManager::notifyUmsAvailable(bool available) {
    char msg[255];
    snprintf(msg, sizeof(msg), "Share method ums now %s",
             (available ? "available" : "unavailable"));
    getBroadcaster()-&gt;sendBroadcast(ResponseCode::ShareAvailabilityChange,
                                    msg, false);
}
</pre>

<h3 id="toc_2.2.10">VolumeManager::notifySIMCardAvailable</h3>
<pre class="brush:c++">
void VolumeManager::notifySIMCardAvailable(bool available) {
    char msg[255];
    snprintf(msg, sizeof(msg), "Share method ums now %s",
             (available ? "available" : "unavailable"));
    getBroadcaster()-&gt;sendBroadcast(ResponseCode::SIMCardStatChange,
                                    msg, false);
}
</pre>

<h3 id="toc_2.2.11">DirectVolume::handleBlockEvent</h3>
<ul>
<li>
当Vold接收到插入磁盘的内核消息时，首先要在/dev/vold目录下创建该磁盘的设备节点。
</li>
<li>
上报磁盘插入和移除的内核消息主要在DirectVolume类中处理。
</li>
</ul>

<pre class="brush:c++">
int DirectVolume::handleBlockEvent(NetlinkEvent *evt) {
    ......
    for (it = mPaths-&gt;begin(); it != mPaths-&gt;end(); ++it) {
        if (!strncmp(dp, *it, strlen(*it))) {
            int action = evt-&gt;getAction();
            const char *devtype = evt-&gt;findParam("DEVTYPE");

            if (action == NetlinkEvent::NlActionAdd) {
                int major = atoi(evt-&gt;findParam("MAJOR"));
                int minor = atoi(evt-&gt;findParam("MINOR"));
                char nodepath[255];

                // 动态创建磁盘的设备节点
                if (createDeviceNode(nodepath, major, minor)) {
                }
                if (!strcmp(devtype, "disk")) {
                    // 添加设备的处理
                    handleDiskAdded(dp, evt);
                } else {
                    // 添加分区的处理
                    handlePartitionAdded(dp, evt);
                }
            } else if (action == NetlinkEvent::NlActionRemove) {
                if (!strcmp(devtype, "disk")) {
                    // 移除设备的处理
                    handleDiskRemoved(dp, evt);
                } else {
                    // 移除分区的处理
                    handlePartitionRemoved(dp, evt);
                }
            } else if (action == NetlinkEvent::NlActionChange) {
                if (!strcmp(devtype, "disk")) {
                    // 设备变更的处理
                    handleDiskChanged(dp, evt);
                } else {
                    // 分区变更的处理
                    handlePartitionChanged(dp, evt);
                }
            } else {
            }
            ......
        }
    }
    ......
}
</pre>

<h2 id="toc_2.3">如何向Framework发送消息</h2>
<ul>
<li>
在main方法中，VolumeManager和NetlinkManager都通过setBroadcaster方法加入了CommandListener对象(继承自SocketListener)，而所有与客户端交互的SocketClient对象便由SocketListener来维护。
</li>
<li>
向Framework层上报消息的方法是通过getBroadcaster方法取得SocketListener对象，再使用sendBroadcast发送消息。
</li>
<li>
向Framework层上报消息的处理主要由VolumeManager和DirectVolume两个类完成。
</li>
</ul>

<h3 id="toc_2.3.1">SocketListener::sendBroadcast</h3>
<pre class="brush:c++">
// code：消息代码
// msg：字符串信息
// addError：是否加入错误
void SocketListener::sendBroadcast(int code, const char *msg, bool addErrno) {
    pthread_mutex_lock(&amp;mClientsLock);
    SocketClientCollection::iterator i;

    for (i = mClients-&gt;begin(); i != mClients-&gt;end(); ++i) {
        if ((*i)-&gt;sendMsg(code, msg, addErrno)) {
        }
    }
    pthread_mutex_unlock(&amp;mClientsLock);
}

// 调用示例如下
// getBroadcaster()-&gt;sendBroadcast(ResponseCode::ShareAvailabilityChange, msg, false);
</pre>

<h3 id="toc_2.3.2">ResponseCode</h3>
<ul>
<li>
sendBroadcast方法的第一个参数指定了消息的类型，该类型的定义如下。
</li>
</ul>

<pre class="brush:c++">
class ResponseCode {
public:
    // 100 series - Requestion action was initiated; expect another reply
    // before proceeding with a new command.
    static const int ActionInitiated            = 100;

    static const int VolumeListResult           = 110;
    static const int AsecListResult             = 111;
    static const int StorageUsersListResult     = 112;

    // 200 series - Requested action has been successfully completed
    static const int CommandOkay                = 200;
    static const int ShareStatusResult          = 210;
    static const int AsecPathResult             = 211;
    static const int ShareEnabledResult         = 212;
    static const int XwarpStatusResult          = 213;

    // 400 series - The command was accepted but the requested action
    // did not take place.
    static const int OperationFailed            = 400;
    static const int OpFailedNoMedia            = 401;
    static const int OpFailedMediaBlank         = 402;
    static const int OpFailedMediaCorrupt       = 403;
    static const int OpFailedVolNotMounted      = 404;
    static const int OpFailedStorageBusy        = 405;
    static const int OpFailedStorageNotFound    = 406;

    // 500 series - The command was not accepted and the requested
    // action did not take place.
    static const int CommandSyntaxError = 500;
    static const int CommandParameterError = 501;

    // 600 series - Unsolicited broadcasts
    static const int UnsolicitedInformational   = 600;
    static const int VolumeStateChange          = 605;
    static const int VolumeMountFailedBlank     = 610;
    static const int VolumeMountFailedDamaged   = 611;
    static const int VolumeMountFailedNoMedia   = 612;

    static const int ShareAvailabilityChange    = 620;

    static const int VolumeDiskInserted         = 630;
    static const int VolumeDiskRemoved          = 631;
    static const int VolumeBadRemoval           = 632;

    static int convertFromErrno();
};
</pre>

<h3 id="toc_2.3.3">上报消息的通信协议</h3>
<h4 id="toc_2.3.3.1">磁盘操作的通信协议</h4>

<table>
<tr>
<th>字符串消息</th>
<th>协议代码</th>
<th>描述</th>
<th>实现方法</th>
</tr>
<tr>
<td>Share method ums now &lt;available / unavailable&gt;</td>
<td>ResponseCode::ShareAvailabilityChange</td>
<td>通知Host端U盘模式是否可用</td>
<td>VolumeManager::notifyUmsAvailable</td>
</tr>
<tr>
<td>Volume &lt;label&gt; &lt;mount point&gt; disk inserted (&lt;major&gt;:&lt;minor&gt;)</td>
<td>ResponseCode::VolumeDiskInserted</td>
<td>通知Framework加入新的磁盘</td>
<td>DirectVolume::handleDiskAdded</td>
</tr>
<tr>
<td>Volume &lt;label&gt; &lt;mount point&gt; disk inserted (&lt;major&gt;:&lt;minor&gt;)</td>
<td>ResponseCode::VolumeDiskInserted</td>
<td>通知Framework加入新的分区</td>
<td>DirectVolume::handlePartitionAdded</td>
</tr>
<tr>
<td>Volume &lt;label&gt; &lt;mount point&gt; disk removed (&lt;major&gt;:&lt;minor&gt;)</td>
<td>ResponseCode::VolumeDiskRemoved</td>
<td>通知Framework移除磁盘</td>
<td>DirectVolume::handleDiskRemoved</td>
</tr>
<tr>
<td>Volume &lt;label&gt; &lt;mount point&gt; disk removed (&lt;major&gt;:&lt;minor&gt;)</td>
<td>ResponseCode::VolumeDiskRemoved</td>
<td>通知Framework移除分区</td>
<td>DirectVolume::handlePartitionRemoved</td>
</tr>
<tr>
<td>Volume &lt;label&gt; &lt;mount point&gt; disk changed (&lt;major&gt;:&lt;minor&gt;)</td>
<td>&nbsp;</td>
<td>通知Framework磁盘状态变化</td>
<td>DirectVolume::handleDiskChanged</td>
</tr>
<tr>
<td>Volume &lt;label&gt; &lt;mount point&gt; disk changed (&lt;major&gt;:&lt;minor&gt;)</td>
<td>&nbsp;</td>
<td>通知Framework分区状态变化</td>
<td>DirectVolume::handlePartitionChanged</td>
</tr>
</table>

<h4 id="toc_2.3.3.2">状态变更的通信协议</h4>
<ul>
<li>
在Vold处理磁盘操作的过程中，会不断的和Framework层同步当前的状态。该行为由通过setState方法处理。
</li>
</ul>

<pre class="brush:c++">
void Volume::setState(int state) {
    char msg[255];
    int oldState = mState;

    if (oldState == state) {
        return;
    }

    mState = state;

    snprintf(msg, sizeof(msg),
             "Volume %s %s state changed from %d (%s) to %d (%s)", getLabel(),
             getMountpoint(), oldState, stateToStr(oldState), mState,
             stateToStr(mState));

    mVm-&gt;getBroadcaster()-&gt;sendBroadcast(ResponseCode::VolumeStateChange,
                                         msg, false);
}
</pre>

<ul>
<li>
整形的协议代码被stateToStr方法格式化成字符串。
</li>
</ul>
    
<pre class="brush:c++">
static const char *stateToStr(int state) {
    if (state == Volume::State_Init)
        return "Initializing";
    else if (state == Volume::State_NoMedia)
        return "No-Media";
    else if (state == Volume::State_Idle)
        return "Idle-Unmounted";
    else if (state == Volume::State_Pending)
        return "Pending";
    else if (state == Volume::State_Mounted)
        return "Mounted";
    else if (state == Volume::State_Unmounting)
        return "Unmounting";
    else if (state == Volume::State_Checking)
        return "Checking";
    else if (state == Volume::State_Formatting)
        return "Formatting";
    else if (state == Volume::State_Shared)
        return "Shared-Unmounted";
    else if (state == Volume::State_SharedMnt)
        return "Shared-Mounted";
    else
        return "Unknown-Error";
}
</pre>
<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

<!--<script type="text/javascript">-->
<!--var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");-->
<!--document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));-->
<!--</script>-->
<!--<script type="text/javascript">-->
<!--try {-->
<!--var pageTracker = _gat._getTracker("UA-15922433-1");-->
<!--pageTracker._trackPageview();-->
<!--} catch(err) {}-->
<!--</script>-->

</body>
</html>
