<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Event处理参考代码2_3</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
	<link type="text/css" rel="stylesheet" href="css_style/style_zenki.css"/>

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>


<h1 id="toc_1">Event处理参考代码2_3</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">Event处理参考代码2_3</a></li>
<ul>
<li><a href="#toc_1.1">WindowManagerService.java</a></li>
<ul>
<li><a href="#toc_1.1.1">WindowManagerService</a></li>
<li><a href="#toc_1.1.2">WindowManagerService.InputMonitor.interceptKeyBeforeQueueing</a></li>
</ul>
<li><a href="#toc_1.2">InputManager.java</a></li>
<ul>
<li><a href="#toc_1.2.1">InputManager</a></li>
<li><a href="#toc_1.2.2">InputManager.Callbacks</a></li>
</ul>
<li><a href="#toc_1.3">com_android_server_InputManager.cpp</a></li>
<ul>
<li><a href="#toc_1.3.1">NativeInputManager</a></li>
<li><a href="#toc_1.3.2">NativeInputManager::NativeInputManager</a></li>
<li><a href="#toc_1.3.3">NativeInputManager::registerInputChannel</a></li>
</ul>
<li><a href="#toc_1.4">android_view_InputChannel.cpp</a></li>
<ul>
<li><a href="#toc_1.4.1">android_view_InputChannel_nativeOpenInputChannelPair</a></li>
</ul>
<li><a href="#toc_1.5">InputTransport.cpp</a></li>
<ul>
<li><a href="#toc_1.5.1">InputChannel::openInputChannelPair</a></li>
</ul>
<li><a href="#toc_1.6">android_view_InputQueue.cpp</a></li>
<ul>
<li><a href="#toc_1.6.1">NativeInputQueue::handleReceiveCallback</a></li>
</ul>
<li><a href="#toc_1.7">InputManager.cpp</a></li>
<ul>
<li><a href="#toc_1.7.1">InputManager::InputManager</a></li>
<li><a href="#toc_1.7.2">InputManager::start</a></li>
<li><a href="#toc_1.7.3">InputManager::stop</a></li>
</ul>
<li><a href="#toc_1.8">InputReader.h</a></li>
<ul>
<li><a href="#toc_1.8.1">InputReader</a></li>
</ul>
<li><a href="#toc_1.9">InputReader.cpp</a></li>
<ul>
<li><a href="#toc_1.9.1">InputReader::loopOnce</a></li>
<li><a href="#toc_1.9.2">InputReader::process</a></li>
<li><a href="#toc_1.9.3">InputReader::consumeEvent</a></li>
<li><a href="#toc_1.9.4">InputDevice::process</a></li>
</ul>
<li><a href="#toc_1.10">KeyboardInputMapper.cpp</a></li>
<ul>
<li><a href="#toc_1.10.1">KeyboardInputMapper::processKey</a></li>
</ul>
<li><a href="#toc_1.11">InputDispatcher.cpp</a></li>
<ul>
<li><a href="#toc_1.11.1">InputDispatcher::registerInputChannel</a></li>
<li><a href="#toc_1.11.2">InputDispatcher::notifyKey</a></li>
</ul>
<li><a href="#toc_1.12">InputTransport.cpp</a></li>
<ul>
<li><a href="#toc_1.12.1">InputChannel::openInputChannelPair</a></li>
</ul>
<li><a href="#toc_1.13">PhoneWindowManager.java</a></li>
<ul>
<li><a href="#toc_1.13.1">updateSettings</a></li>
<li><a href="#toc_1.13.2">interceptKeyBeforeQueueing</a></li>
</ul>
<li><a href="#toc_1.14">Looper.h</a></li>
<ul>
<li><a href="#toc_1.14.1">Looper</a></li>
</ul>
<li><a href="#toc_1.15">Looper.cpp</a></li>
<ul>
<li><a href="#toc_1.15.1">Looper::Looper</a></li>
<li><a href="#toc_1.15.2">Looper::pollOnce</a></li>
<li><a href="#toc_1.15.3">Looper::pollInner</a></li>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">WindowManagerService.java</h2>
<h3 id="toc_1.1.1">WindowManagerService</h3>
<pre class="brush:java">
private WindowManagerService(Context context, PowerManagerService pm,
            boolean haveInputMethods) {
    ......
    final WindowManagerPolicy mPolicy = PolicyManager.makeNewWindowManager();

    ......
    mInputManager = new InputManager(context, this);

    ......
    mInputManager.start();
}
</pre>

<h3 id="toc_1.1.2">WindowManagerService.InputMonitor.interceptKeyBeforeQueueing</h3>
<pre class="brush:java">
public int interceptKeyBeforeQueueing(long whenNanos, int action, int flags,
                int keyCode, int scanCode, int policyFlags, boolean isScreenOn) {
    return mPolicy.interceptKeyBeforeQueueing(whenNanos, action, flags,
            keyCode, scanCode, policyFlags, isScreenOn);
}
</pre>

<h2 id="toc_1.2">InputManager.java</h2>
<h3 id="toc_1.2.1">InputManager</h3>
<pre class="brush:java">
// 包裹了C++层的InputManager并提供Callbacks回调
public class InputManager {
    ...... 
    private static native void nativeInit(Callbacks callbacks);
    private static native void nativeStart();
    private static native void nativeSetDisplaySize(int displayId, int width, int height);
    private static native void nativeSetDisplayOrientation(int displayId, int rotation);
    
    private static native int nativeGetScanCodeState(int deviceId, int sourceMask,
            int scanCode);
    private static native int nativeGetKeyCodeState(int deviceId, int sourceMask,
            int keyCode);
    private static native int nativeGetSwitchState(int deviceId, int sourceMask,
            int sw);
    ......

    private class Callbacks {
       ...... 
    }
 
</pre>

<h3 id="toc_1.2.2">InputManager.Callbacks</h3>
<pre class="brush:java">
private class Callbacks {
    ......

    @SuppressWarnings("unused")
    public int interceptKeyBeforeQueueing(long whenNanos, int action, int flags,
            int keyCode, int scanCode, int policyFlags, boolean isScreenOn) {
        return mWindowManagerService.mInputMonitor.interceptKeyBeforeQueueing(
                whenNanos, action, flags, keyCode, scanCode, policyFlags, isScreenOn);
    }
}
</pre>


<h2 id="toc_1.3">com_android_server_InputManager.cpp</h2>
<h3 id="toc_1.3.1">NativeInputManager</h3>
<pre class="brush:c++">
class NativeInputManager : public virtual RefBase,
    public virtual InputReaderPolicyInterface,
    public virtual InputDispatcherPolicyInterface {
    ......
    
public:
    ......
    virtual status_t start();
    virtual status_t stop();

    virtual sp&lt;InputReaderInterface&gt; getReader();
    virtual sp&lt;InputDispatcherInterface&gt; getDispatcher();

private:
    sp&lt;InputReaderInterface&gt; mReader;
    sp&lt;InputReaderThread&gt; mReaderThread;

    sp&lt;InputDispatcherInterface&gt; mDispatcher;
    sp&lt;InputDispatcherThread&gt; mDispatcherThread;
}
</pre>

<h3 id="toc_1.3.2">NativeInputManager::NativeInputManager</h3>
<pre class="brush:c++">
NativeInputManager::NativeInputManager(jobject callbacksObj) :
    mFilterTouchEvents(-1), mFilterJumpyTouchEvents(-1), mVirtualKeyQuietTime(-1),
    mMaxEventsPerSecond(-1),
    mDisplayWidth(-1), mDisplayHeight(-1), mDisplayOrientation(ROTATION_0) {
    
    // 设置回调
    mCallbacksObj = env-&gt;NewGlobalRef(callbacksObj);
    // 初始化EventHub
    sp&lt;EventHub&gt; eventHub = new EventHub();
    // 初始化InputManager
    mInputManager = new InputManager(eventHub, this, this);
}
</pre>

<h3 id="toc_1.3.3">NativeInputManager::registerInputChannel</h3>
<pre class="brush:c++">
status_t NativeInputManager::registerInputChannel(JNIEnv* env,
        const sp&lt;InputChannel&gt;&amp; inputChannel, jobject inputChannelObj, bool monitor) {
    ......
    status = mInputManager-&gt;getDispatcher()-&gt;registerInputChannel(inputChannel, monitor);
    if (! status) {
        return OK;
    }
    ......
}
</pre>

<h2 id="toc_1.4">android_view_InputChannel.cpp</h2>
<h3 id="toc_1.4.1">android_view_InputChannel_nativeOpenInputChannelPair</h3>
<pre class="brush:c++">
static jobjectArray android_view_InputChannel_nativeOpenInputChannelPair(JNIEnv* env,
        jclass clazz, jstring nameObj) {
    ......
    sp&lt;InputChannel&gt; serverChannel;
    sp&lt;InputChannel&gt; clientChannel;
    status_t result = InputChannel::openInputChannelPair(name, serverChannel, clientChannel);

    ......
    // TODO more robust error checking
    jobject serverChannelObj = android_view_InputChannel_createInputChannel(env,
            new NativeInputChannel(serverChannel));
    jobject clientChannelObj = android_view_InputChannel_createInputChannel(env,
            new NativeInputChannel(clientChannel));
    ......
    return channelPair;
}
</pre>

<h2 id="toc_1.5">InputTransport.cpp</h2>
<h3 id="toc_1.5.1">InputChannel::openInputChannelPair</h3>
<pre class="brush:c++">
status_t InputChannel::openInputChannelPair(const String8&amp; name,
        sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel) {
    ......
    int serverAshmemFd = ashmem_create_region(name.string(), DEFAULT_MESSAGE_BUFFER_SIZE);
    if (serverAshmemFd &lt; 0) {
        ......
    } else {
        result = ashmem_set_prot_region(serverAshmemFd, PROT_READ | PROT_WRITE);
        if (result &lt; 0) {
            ......
        } else {
            int clientAshmemFd;
            clientAshmemFd = dup(serverAshmemFd);
            if (clientAshmemFd &lt; 0) {
                ......
            } else {
                int forward[2];
                if (pipe(forward)) {
                    ......
                } else {
                    int reverse[2];
                    if (pipe(reverse)) {
                        ......
                    } else {
                        String8 serverChannelName = name;
                        serverChannelName.append(" (server)");
                        outServerChannel = new InputChannel(serverChannelName,
                                serverAshmemFd, reverse[0], forward[1]);

                        String8 clientChannelName = name;
                        clientChannelName.append(" (client)");
                        outClientChannel = new InputChannel(clientChannelName,
                                clientAshmemFd, forward[0], reverse[1]);
                        return OK;
                    }
                    ::close(forward[0]);
                    ::close(forward[1]);
                }
                ::close(clientAshmemFd);
            }
        }
        ::close(serverAshmemFd);
    }
    
    ......
    return result;
}
</pre>

<h2 id="toc_1.6">android_view_InputQueue.cpp</h2>
<pre class="brush:c++">
status_t NativeInputQueue::registerInputChannel(JNIEnv* env, jobject inputChannelObj,
        jobject inputHandlerObj, jobject messageQueueObj) {
    sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env,
            inputChannelObj);
    ......

    sp&lt;Looper&gt; looper = android_os_MessageQueue_getLooper(env, messageQueueObj);

    { // acquire lock
        AutoMutex _l(mLock);

        ......
        sp&lt;Connection&gt; connection = new Connection(connectionId, inputChannel, looper);
        status_t result = connection-&gt;inputConsumer.initialize();
        ......

        connection-&gt;inputHandlerObjGlobal = env-&gt;NewGlobalRef(inputHandlerObj);
        
        .....
        looper-&gt;addFd(receiveFd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this);
    } // release lock
    
    ......
    return OK;
}
</pre>

<h3 id="toc_1.6.1">NativeInputQueue::handleReceiveCallback</h3>
<pre class="brush:c++">
int NativeInputQueue::handleReceiveCallback(int receiveFd, int events, void* data) {
    ......
    { // acquire lock
        AutoMutex _l(q-&gt;mLock);

        ssize_t connectionIndex = q-&gt;mConnectionsByReceiveFd.indexOfKey(receiveFd);
        ......

        connection = q-&gt;mConnectionsByReceiveFd.valueAt(connectionIndex);
        ......

        status_t status = connection-&gt;inputConsumer.receiveDispatchSignal();
        ......

        status = connection-&gt;inputConsumer.consume(&amp; connection-&gt;inputEventFactory, &amp; inputEvent);
        ......

        finishedToken = generateFinishedToken(receiveFd, connection-&gt;id, connection-&gt;messageSeqNum);
        ......

        inputHandlerObjLocal = env-&gt;NewLocalRef(connection-&gt;inputHandlerObjGlobal);
    } // release lock

    ......
    switch (inputEventType) {
    case AINPUT_EVENT_TYPE_KEY:
        inputEventObj = android_view_KeyEvent_fromNative(env,
                static_cast&lt;KeyEvent*&gt;(inputEvent));
        // 调用java层的dispatchKeyEvent方法
        dispatchMethodId = gInputQueueClassInfo.dispatchKeyEvent;
        break;

    case AINPUT_EVENT_TYPE_MOTION:
        inputEventObj = android_view_MotionEvent_fromNative(env,
                static_cast&lt;MotionEvent*&gt;(inputEvent));
        // 调用java层的dispatchMotionEvent方法
        dispatchMethodId = gInputQueueClassInfo.dispatchMotionEvent;
        break;

    default:
        assert(false); // InputConsumer should prevent this from ever happening
        inputEventObj = NULL;
    }

    ......
    env-&gt;CallStaticVoidMethod(gInputQueueClassInfo.clazz,
            dispatchMethodId, inputHandlerObjLocal, inputEventObj,
            jlong(finishedToken));

    ......
    return 1;
}
</pre>

<h2 id="toc_1.7">InputManager.cpp</h2>
<h3 id="toc_1.7.1">InputManager::InputManager</h3>
<pre class="brush:c++">
InputManager::InputManager(
        const sp&lt;EventHubInterface&gt;&amp; eventHub,
        const sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,
        const sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) {
    mDispatcher = new InputDispatcher(dispatcherPolicy);
    mReader = new InputReader(eventHub, readerPolicy, mDispatcher);
    initialize();
}
</pre>

<h3 id="toc_1.7.2">InputManager::start</h3>
<pre class="brush:c++">
status_t InputManager::start() {
    status_t result = mDispatcherThread-&gt;run("InputDispatcher", PRIORITY_URGENT_DISPLAY);
    ......
    result = mReaderThread-&gt;run("InputReader", PRIORITY_URGENT_DISPLAY);
    ......

    return OK;
}
</pre>

<h3 id="toc_1.7.3">InputManager::stop</h3>
<pre class="brush:c++">
status_t InputManager::stop() {
    status_t result = mReaderThread-&gt;requestExitAndWait();
    ......
    result = mDispatcherThread-&gt;requestExitAndWait();
    ......

    return OK;
}
</pre>

<h2 id="toc_1.8">InputReader.h</h2>
<h3 id="toc_1.8.1">InputReader</h3>
<pre class="brush:c++">
class InputReader : public InputReaderInterface, protected InputReaderContext {
public:
    InputReader(const sp&lt;EventHubInterface&gt;&amp; eventHub,
            const sp&lt;InputReaderPolicyInterface&gt;&amp; policy,
            const sp&lt;InputDispatcherInterface&gt;&amp; dispatcher);
            
    ......
    virtual void loopOnce();
    
private:
    sp&lt;EventHubInterface&gt; mEventHub;
    sp&lt;InputReaderPolicyInterface&gt; mPolicy;
    sp&lt;InputDispatcherInterface&gt; mDispatcher;
    ......
}
</pre>

<h2 id="toc_1.9">InputReader.cpp</h2>
<h3 id="toc_1.9.1">InputReader::loopOnce</h3>
<pre class="brush:c++">
void InputReader::loopOnce() {
    RawEvent rawEvent;
    mEventHub-&gt;getEvent(&amp; rawEvent);

#if DEBUG_RAW_EVENTS
    LOGD("Input event: device=0x%x type=0x%x scancode=%d keycode=%d value=%d",
            rawEvent.deviceId, rawEvent.type, rawEvent.scanCode, rawEvent.keyCode,
            rawEvent.value);
#endif

    process(&amp; rawEvent);
}
</pre>

<h3 id="toc_1.9.2">InputReader::process</h3>
<pre class="brush:c++">
void InputReader::process(const RawEvent* rawEvent) {
    switch (rawEvent-&gt;type) {
    case EventHubInterface::DEVICE_ADDED:
        addDevice(rawEvent-&gt;deviceId);
        break;

    case EventHubInterface::DEVICE_REMOVED:
        removeDevice(rawEvent-&gt;deviceId);
        break;

    case EventHubInterface::FINISHED_DEVICE_SCAN:
        handleConfigurationChanged(rawEvent-&gt;when);
        break;

    default:
        consumeEvent(rawEvent);
        break;
    }
}
</pre>

<h3 id="toc_1.9.3">InputReader::consumeEvent</h3>
<pre class="brush:c++">
void InputReader::consumeEvent(const RawEvent* rawEvent) {
    int32_t deviceId = rawEvent-&gt;deviceId;
    { // acquire device registry reader lock
        RWLock::AutoRLock _rl(mDeviceRegistryLock);

        ssize_t deviceIndex = mDevices.indexOfKey(deviceId);
        if (deviceIndex &lt; 0) {
            return;
        }

        InputDevice* device = mDevices.valueAt(deviceIndex);
        if (device-&gt;isIgnored()) {
            return;
        }

        device-&gt;process(rawEvent);
    } // release device registry reader lock
}
</pre>

<h3 id="toc_1.9.4">InputDevice::process</h3>
<pre class="brush:c++">
void InputDevice::process(const RawEvent* rawEvent) {
    size_t numMappers = mMappers.size();
    for (size_t i = 0; i &lt; numMappers; i++) {
        InputMapper* mapper = mMappers[i];
        mapper-&gt;process(rawEvent);
    }
}
</pre>

<h2 id="toc_1.10">KeyboardInputMapper.cpp</h2>
<h3 id="toc_1.10.1">KeyboardInputMapper::processKey</h3>
<pre class="brush:c++">
void KeyboardInputMapper::processKey(nsecs_t when, bool down, int32_t keyCode,
        int32_t scanCode, uint32_t policyFlags) {
    int32_t newMetaState;
    nsecs_t downTime;
    bool metaStateChanged = false;

    { // acquire lock
        AutoMutex _l(mLock);

        if (down) {
            // Rotate key codes according to orientation if needed.
            // Note: getDisplayInfo is non-reentrant so we can continue holding the lock.
            ......
            if (! getPolicy()-&gt;getDisplayInfo(mAssociatedDisplayId, NULL, NULL, &amp; orientation)) {
                return;
            }

            // Add key down.KeyboardInputMapper::processKey
            ssize_t keyDownIndex = findKeyDownLocked(scanCode);
            if (keyDownIndex &gt;= 0) {
                // key repeat, be sure to use same keycode as before in case of rotation
                keyCode = mLocked.keyDowns.itemAt(keyDownIndex).keyCode;
            } else {
                // key down
                ......
            }
        } else {
            // Remove key down.
        }
        
        ......
    } // release lock

    // 通过InputDispatcher分发事件
    getDispatcher()-&gt;notifyKey(when, getDeviceId(), AINPUT_SOURCE_KEYBOARD, policyFlags,
            down ? AKEY_EVENT_ACTION_DOWN : AKEY_EVENT_ACTION_UP,
            AKEY_EVENT_FLAG_FROM_SYSTEM, keyCode, scanCode, newMetaState, downTime);
}
</pre>

<h2 id="toc_1.11">InputDispatcher.cpp</h2>
<h3 id="toc_1.11.1">InputDispatcher::registerInputChannel</h3>
<pre class="brush:c++">
status_t InputDispatcher::registerInputChannel(const sp&lt;InputChannel&gt;&amp; inputChannel, bool monitor) {
    { // acquire lock
        AutoMutex _l(mLock);

        sp&lt;Connection&gt; connection = new Connection(inputChannel);
        status_t status = connection-&gt;initialize();
        ......

        int32_t receiveFd = inputChannel-&gt;getReceivePipeFd();
        mConnectionsByReceiveFd.add(receiveFd, connection);

        if (monitor) {
            mMonitoringChannels.push(inputChannel);
        }

        mLooper-&gt;addFd(receiveFd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this);

        runCommandsLockedInterruptible();
    } // release lock
    return OK;
}
</pre>

<h3 id="toc_1.11.2">InputDispatcher::notifyKey</h3>
<pre class="brush:c++">
void InputDispatcher::notifyKey(nsecs_t eventTime, int32_t deviceId, int32_t source,
        uint32_t policyFlags, int32_t action, int32_t flags,
        int32_t keyCode, int32_t scanCode, int32_t metaState, nsecs_t downTime) {
    // 检验Key是否合法
    if (! validateKeyEvent(action)) {
        return;
    }

    // 系统预处理
    policyFlags |= POLICY_FLAG_TRUSTED;
    mPolicy-&gt;interceptKeyBeforeQueueing(eventTime, deviceId, action, /*byref*/ flags,
            keyCode, scanCode, /*byref*/ policyFlags);

    // 加入事件队列
    bool needWake;
    { // acquire lock
        AutoMutex _l(mLock);

        int32_t repeatCount = 0;
        KeyEntry* newEntry = mAllocator.obtainKeyEntry(eventTime,
                deviceId, source, policyFlags, action, flags, keyCode, scanCode,
                metaState, repeatCount, downTime);

        needWake = enqueueInboundEventLocked(newEntry);
    } // release lock

    // 唤醒线程处理
    if (needWake) {
        mLooper-&gt;wake();
    }
}
</pre>

<h2 id="toc_1.12">InputTransport.cpp</h2>
<h3 id="toc_1.12.1">InputChannel::openInputChannelPair</h3>
<pre class="brush:c++">
status_t InputChannel::openInputChannelPair(const String8&amp; name,
        sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel) {
    status_t result;

    int serverAshmemFd = ashmem_create_region(name.string(), DEFAULT_MESSAGE_BUFFER_SIZE);
    if (serverAshmemFd &lt; 0) {
        result = -errno;
    } else {
        result = ashmem_set_prot_region(serverAshmemFd, PROT_READ | PROT_WRITE);
        if (result &lt; 0) {
            ......
        } else {
            // Dup the file descriptor because the server and client input channel objects that
            // are returned may have different lifetimes but they share the same shared memory region.
            int clientAshmemFd;
            clientAshmemFd = dup(serverAshmemFd);
            if (clientAshmemFd &lt; 0) {
                result = -errno;
            } else {
                int forward[2];
                if (pipe(forward)) {
                    result = -errno;
                } else {
                    int reverse[2];
                    if (pipe(reverse)) {
                        result = -errno;
                    } else {
                        String8 serverChannelName = name;
                        serverChannelName.append(" (server)");
                        outServerChannel = new InputChannel(serverChannelName,
                                serverAshmemFd, reverse[0], forward[1]);

                        String8 clientChannelName = name;
                        clientChannelName.append(" (client)");
                        outClientChannel = new InputChannel(clientChannelName,
                                clientAshmemFd, forward[0], reverse[1]);
                        return OK;
                    }
                    ::close(forward[0]);
                    ::close(forward[1]);
                }
                ::close(clientAshmemFd);
            }
        }
        ::close(serverAshmemFd);
    }

    outServerChannel.clear();
    outClientChannel.clear();
    return result;
}
</pre>

<h2 id="toc_1.13">PhoneWindowManager.java</h2>
<h3 id="toc_1.13.1">updateSettings</h3>
<pre class="brush:java">
public void updateSettings() {
    if (mPointerLocationInputChannel == null) {
        try {
            mPointerLocationInputChannel =
                mWindowManager.monitorInput("PointerLocationView");
            InputQueue.registerInputChannel(mPointerLocationInputChannel,
                    mPointerLocationInputHandler, mHandler.getLooper().getQueue());
        } catch (RemoteException ex) {
        }
    }
}
</pre>

<h3 id="toc_1.13.2">interceptKeyBeforeQueueing</h3>
<pre class="brush:java">
public int interceptKeyBeforeQueueing(long whenNanos, int action, int flags,
            int keyCode, int scanCode, int policyFlags, boolean isScreenOn) {
    ......
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (isScreenOn ?
                                    mKeyguardMediator.isShowingAndNotHidden() :
                                    mKeyguardMediator.isShowing());

    ......
    if (down &amp;&amp; (policyFlags &amp; WindowManagerPolicy.FLAG_VIRTUAL) != 0) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }

    // Basic policy based on screen state and keyguard.
    // FIXME: This policy isn't quite correct.  We shouldn't care whether the screen
    //        is on or off, really.  We should care about whether the device is in an
    //        interactive state or is in suspend pretending to be "off".
    //        The primary screen might be turned off due to proximity sensor or
    //        because we are presenting media on an auxiliary screen or remotely controlling
    //        the device some other way (which is why we have an exemption here for injected
    //        events).
    int result;
    if (isScreenOn || isInjected) {
        // When the screen is on or if the key is injected pass the key to the application.
        ......
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        ......
    }

    // Handle special keys.
    switch (keyCode) {
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP: {
            ......
            break;
        }

        case KeyEvent.KEYCODE_ENDCALL: {
            ......
            break;
        }

        case KeyEvent.KEYCODE_POWER: {
            ......
            break;
        }

        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD: {
            ......
            break;
        }

        case KeyEvent.KEYCODE_CALL: {
            ......
            break;
        }
    }
    return result;
}
</pre>

<h2 id="toc_1.14">Looper.h</h2>
<h3 id="toc_1.14.1">Looper</h3>
<pre class="brush:c++">
class Looper : public ALooper, public RefBase {
    ......
    void wake();
    int addFd(int fd, int ident, int events, ALooper_callbackFunc callback, void* data);
    int removeFd(int fd);

private:
    struct Request {
        int fd;
        int ident;
        ALooper_callbackFunc callback;
        void* data;
    };

    struct Response {
        int events;
        Request request;
    };
    
    ......
}
</pre>

<h2 id="toc_1.15">Looper.cpp</h2>
<h3 id="toc_1.15.1">Looper::Looper</h3>
<pre class="brush:c++">
Looper::Looper(bool allowNonCallbacks) :
        mAllowNonCallbacks(allowNonCallbacks),
        mResponseIndex(0) {
    int wakeFds[2];
    int result = pipe(wakeFds);

    mWakeReadPipeFd = wakeFds[0];
    mWakeWritePipeFd = wakeFds[1];
    ......
    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);
    ......
    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);

#ifdef LOOPER_USES_EPOLL
    // Allocate the epoll instance and register the wake pipe.
    mEpollFd = epoll_create(EPOLL_SIZE_HINT);

    struct epoll_event eventItem;
    memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union
    eventItem.events = EPOLLIN;
    eventItem.data.fd = mWakeReadPipeFd;
    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);
#else
    ......
#endif
}
</pre>

<h3 id="toc_1.15.2">Looper::pollOnce</h3>
<pre class="brush:c++">
int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {
    int result = 0;
    for (;;) {
        ......
        result = pollInner(timeoutMillis);
    }
}
</pre>

<h3 id="toc_1.15.3">Looper::pollInner</h3>
<pre class="brush:c++">
int Looper::pollInner(int timeoutMillis) {
    ......
    // epoll模式监听事件
#ifdef LOOPER_USES_EPOLL
    struct epoll_event eventItems[EPOLL_MAX_EVENTS];
    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);
    bool acquiredLock = false;
#else
    ......
#endif

    if (eventCount &lt; 0) {
        if (errno == EINTR) {
            goto Done;
        }

        result = ALOOPER_POLL_ERROR;
        goto Done;
    }

    if (eventCount == 0) {
        result = ALOOPER_POLL_TIMEOUT;
        goto Done;
    }

    // push相应的应答对象
#ifdef LOOPER_USES_EPOLL
    for (int i = 0; i &lt; eventCount; i++) {
        int fd = eventItems[i].data.fd;
        uint32_t epollEvents = eventItems[i].events;
        if (fd == mWakeReadPipeFd) {
            if (epollEvents &amp; EPOLLIN) {
                awoken();
            } else {
            }
        } else {
            if (! acquiredLock) {
                mLock.lock();
                acquiredLock = true;
            }

            ssize_t requestIndex = mRequests.indexOfKey(fd);
            if (requestIndex &gt;= 0) {
                int events = 0;
                if (epollEvents &amp; EPOLLIN) events |= ALOOPER_EVENT_INPUT;
                if (epollEvents &amp; EPOLLOUT) events |= ALOOPER_EVENT_OUTPUT;
                if (epollEvents &amp; EPOLLERR) events |= ALOOPER_EVENT_ERROR;
                if (epollEvents &amp; EPOLLHUP) events |= ALOOPER_EVENT_HANGUP;
                pushResponse(events, mRequests.valueAt(requestIndex));
            } else {
            }
        }
    }
    if (acquiredLock) {
        mLock.unlock();
    }
Done: ;
#else
    ......
#endif
    ......
    // 循环调用注册的callback方法
    for (size_t i = 0; i &lt; mResponses.size(); i++) {
        const Response&amp; response = mResponses.itemAt(i);
        if (response.request.callback) {
            int callbackResult = response.request.callback(
                    response.request.fd, response.events, response.request.data);
            if (callbackResult == 0) {
                removeFd(response.request.fd);
            }

            result = ALOOPER_POLL_CALLBACK;
        }
    }
    return result;
}
</pre>
<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

<!--<script type="text/javascript">-->
<!--var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");-->
<!--document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));-->
<!--</script>-->
<!--<script type="text/javascript">-->
<!--try {-->
<!--var pageTracker = _gat._getTracker("UA-15922433-1");-->
<!--pageTracker._trackPageview();-->
<!--} catch(err) {}-->
<!--</script>-->

</body>
</html>
