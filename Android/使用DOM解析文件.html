<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>使用DOM解析文件</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <link rel="Stylesheet" type="text/css" href="../css_style/style_zenki.css">

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>

<!-- wrap the vimwiki html -->

<h1 id="toc_1">DOM解析XML</h1>

<h2 id="toc_1.1">相关类</h2>
<pre class="brush:java">
import java.io.InputStream;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.InputSource;
</pre>

<h2 id="toc_1.2">基本处理流程</h2>
<ul>
<li>
通过DocumentBuilderFactory.newInstance()生成<code>DocumentBuilderFactory</code>对象工厂，工厂根据系统环境决定使用哪个解析器。

<li>
DocumentBuilderFactory对象使用newDocumentBuilder()方法生成<code>DocumentBuilder</code>DOM解析器。

<li>
DocumentBuilder对象通过parse方法生成<code>Document</code>DOM树模型，之后所有操作都和该模型相关。

<li>
通过Document对象的getElementsByTagName方法获取<code>NodeList</code>节点列表对象，并通过其item方法获取<code>Node</code>抽象节点对象。

<li>
Node对象<code>Element</code>通过<code>getFirstChild().getNodeValue()</code>方法获取节点的值。

</ul>

<h2 id="toc_1.3">DOM对象列表</h2>

<dl>
<dt>Document </dt>
<dd>Document对象代表了整个XML的文档，所有其它的Node，都以一定的顺序包含在 Document对象之内，排列成一个树形的结构，程序员可以通过遍历这颗树来得到XML文档的所有的内容，这也是对XML文档操作的起点。</dd>
<table>
<tr>
<th>
方法
</th>
<th>
描述
</th>
</tr>
<tr>
<td>
createAttribute(String)
</td>
<td>
用给定的属性名创建一个Attr对象
</td>
</tr>
<tr>
<td>
createElement(String)
</td>
<td>
用给定的标签名创建一个Element对象，代表XML文档中的一个标签
</td>
</tr>
<tr>
<td>
createTextNode(String)
</td>
<td>
用给定的字符串创建一个Text对象，Text对象代表了标签或者属性中所包含的纯文本字符串
</td>
</tr>
<tr>
<td>
getElementsByTagName(String)
</td>
<td>
返回一个NodeList对象，它包含了所有给定标签名字的标签
</td>
</tr>
<tr>
<td>
getDocumentElement()
</td>
<td>
返回一个代表这个DOM树的根节点的Element对象，也就是代表XML文档根元素的那个对象
</td>
</tr>
</table>
</dl>

<dl>
<dt>Node </dt>
<dd>Node对象是DOM结构中最为基本的对象，代表了文档树中的一个抽象的节点。在实际使用的时候，很少会真正的用到Node这个对象，而是用到诸如Element、Attr、Text等Node对象的子对象来操作文档。</dd>
<table>
<tr>
<th>
方法
</th>
<th>
描述
</th>
</tr>
<tr>
<td>
appendChild(Node node)
</td>
<td>
为这个节点添加一个子节点，并放在所有子节点的最后，如果这个子节点已经存在，则先把它删掉再添加进去
</td>
</tr>
<tr>
<td>
getFirstChild()
</td>
<td>
如果节点存在子节点，则返回第一个子节点
</td>
</tr>
<tr>
<td>
getNextSibling()
</td>
<td>
返回在DOM树中这个节点的下一个兄弟节点
</td>
</tr>
<tr>
<td>
getNodeName()
</td>
<td>
根据节点的类型返回节点的名称
</td>
</tr>
<tr>
<td>
getNodeType()
</td>
<td>
返回节点的类型
</td>
</tr>
<tr>
<td>
getNodeValue()
</td>
<td>
返回节点的值
</td>
</tr>
<tr>
<td>
hasChildNodes()
</td>
<td>
判断是不是存在有子节点
</td>
</tr>
<tr>
<td>
hasAttributes()
</td>
<td>
判断这个节点是否存在有属性
</td>
</tr>
<tr>
<td>
getOwnerDocument()
</td>
<td>
返回节点所处的Document对象
</td>
</tr>
<tr>
<td>
insertBefore(Node new，Node ref)
</td>
<td>
在给定的一个子对象前再插入一个子对象
</td>
</tr>
<tr>
<td>
removeChild(Node node)
</td>
<td>
删除给定的子节点对象
</td>
</tr>
<tr>
<td>
replaceChild(Node new，Node old)
</td>
<td>
用一个新的Node对象代替给定的子节点对象
</td>
</tr>
</table>
</dl>

<dl>
<dt>NodeList </dt>
<dd>顾名思义，就是代表了一个包含了一个或者多个Node的列表。可以简单的把它看成一个Node的数组，我们可以通过方法来获得列表中的元素。</dd>
<table>
<tr>
<th>
方法
</th>
<th>
描述
</th>
</tr>
<tr>
<td>
GetLength()
</td>
<td>
返回列表的长度
</td>
</tr>
<tr>
<td>
Item(int)
</td>
<td>
返回指定位置的Node对象
</td>
</tr>
</table>
</dl>

<dl>
<dt>Element </dt>
<dd>代表的是XML文档中的标签元素，继承于Node，亦是Node的最主要的子对象。</dd>
<table>
<tr>
<th>
方法
</th>
<th>
描述
</th>
</tr>
<tr>
<td>
getElementsByTagName(String)
</td>
<td>
返回一个NodeList对象，它包含了在这个标签中其下的子孙节点中具有给定标签名字的标签
</td>
</tr>
<tr>
<td>
getTagName()
</td>
<td>
返回一个代表这个标签名字的字符串
</td>
</tr>
<tr>
<td>
getAttribute(String)
</td>
<td>
返回标签中给定属性名称的属性的值
</td>
</tr>
<tr>
<td>
getAttributeNode(String)
</td>
<td>
返回一个代表给定属性名称的Attr对象
</td>
</tr>
</table>
</dl>

<dl>
<dt>Attr </dt>
<dd>代表了某个标签中的属性。Attr继承于Node，但是因为Attr实际上是包含在Element中的，它并不能被看作是Element的子对象，因而在DOM中Attr并不是DOM树的一部分，所以Node中的 getparentNode()，getpreviousSibling()和getnextSibling()返回的都将是null。也就是说，Attr其实是被看作包含它的Element对象的一部分，它并不作为DOM树中单独的一个节点出现。这一点在使用的时候要同其它的Node子对象相区别。</dd>
</dl>

<h2 id="toc_1.4">示例代码</h2>

<p>
例程源码(XML) --- person.xml
</p>
<pre class="brush:xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persons&gt;
    &lt;person id="1"&gt;
        &lt;name&gt;Jerry&lt;/name&gt;
        &lt;age&gt;23&lt;/age&gt;
    &lt;/person&gt;
    
    &lt;person id="3"&gt;
        &lt;name&gt;Lily&lt;/name&gt;
        &lt;age&gt;17&lt;/age&gt;
    &lt;/person&gt;
&lt;/persons&gt;
</pre>

<p>
例程源码(JAVA) --- Person类
</p>
<pre class="brush:java">
package cn.partner4java.xml.bean;

public class Person {
    private int id;
    private String name;
    private short age;
    
    public int getId() {
        return id;
    }
    
    public void setId(int id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public short getAge() {
        return age;
    }
    
    public void setAge(short age) {
        this.age = age;
    }
}
</pre>

<p>
例程源码(JAVA) --- 解析代码
</p>
<pre class="brush:java">
/**
 * 使用Dom解析xml文件
 *
 */
public class DomXMLReader {

    public static List&lt;Person&gt; readXML(InputStream inStream) {
        List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;();
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        try {
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document dom = builder.parse(inStream);
            dom.normalize();
            Element root = dom.getDocumentElement();
            NodeList items = root.getElementsByTagName("person");//查找所有person节点
            
            for (int i = 0; i &lt; items.getLength(); i++) {
                Person person = new Person();
                //得到第一个person节点
                Element personNode = (Element) items.item(i);
                //获取person节点的id属性值
                person.setId(new Integer(personNode.getAttribute("id")));
                
                //获取person节点下的所有子节点(标签之间的空白节点和name/age元素)
                NodeList childsNodes = personNode.getChildNodes();
                for (int j = 0; j &lt; childsNodes.getLength(); j++) {
                    Node node = (Node) childsNodes.item(j);             
                    //判断是否为元素类型
                    if(node.getNodeType() == Node.ELEMENT_NODE){                       
                        Element childNode = (Element) node;
                        //判断是否name元素
                        if ("name".equals(childNode.getNodeName())) {
                            //获取name元素下Text节点,然后从Text节点获取数据                       
                            person.setName(childNode.getFirstChild().getNodeValue());
                        } 
                        else if (“age”.equals(childNode.getNodeName())) {
                            person.setAge(new Short(childNode.getFirstChild().getNodeValue()));
                        }
                    }
                }
                persons.add(person);
            }
            
            inStream.close();
        } 
        catch (Exception e) {
            e.printStackTrace();
        }
        
        return persons;
    }
}
</pre>

<h2 id="toc_1.5">乱码问题</h2>
<ul>
<li>
DocumentBuilder类的parse()方法接收InputSource作为参数，InputSource类可以通过setEncoding()方法设置编码，如setEncoding("GB2312")

</ul>


<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

</body>
</html>
