<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Binder服务和客户端实现层</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <link rel="Stylesheet" type="text/css" href="../css_style/style_zenki.css">

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>

<!-- wrap the vimwiki html -->

<h1 id="toc_1">Binder服务和客户端实现层</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">Binder服务和客户端实现层</a>
<ul>
<li><a href="#toc_1.1">Service本质结构</a>
<li><a href="#toc_1.2">Java层的实现</a>
<ul>
<li><a href="#toc_1.2.1">利用aidl实现Binder</a>
</ul>
<li><a href="#toc_1.3">Native层的实现</a>
<ul>
<li><a href="#toc_1.3.1">1.声明接口</a>
<li><a href="#toc_1.3.2">2.定义本地服务基类</a>
<li><a href="#toc_1.3.3">3.实现代理服务的Proxy</a>
<li><a href="#toc_1.3.4">4.实现本地服务的基类</a>
<li><a href="#toc_1.3.5">5.完成本地服务的功能</a>
</ul>
<li><a href="#toc_1.4">Java层和C++层相互调用</a>
</ul>
</ul>
</div>

<h2 id="toc_1.1">Service本质结构</h2>
<p>
 <img src="http:pic/service.png" />
</p>
 
<h2 id="toc_1.2">Java层的实现</h2>
<h3 id="toc_1.2.1">利用aidl实现Binder</h3>
<ul>
<li>
Java层的本地Service实现（<code>进程内部访问</code>）请参见<a href="本地Service.html">本地Service</a>。

<li>
Java层的远程Service实现（<code>进程间访问</code>）请参见<a href="远程Service.html">远程Service</a>。

<li>
aidl原理与实现可参考<a href="Binder核心框架层_Java.html">Binder核心框架层_Java</a>。

</ul>

<h2 id="toc_1.3">Native层的实现</h2>
<ul>
<li>
Native层的服务可按照以下步骤实现(以SurfaceFlinger为例)：

</ul>

<h3 id="toc_1.3.1">1.声明接口</h3>
<ul>
<li>
定义一个接口类，该类必须继承自<code>IInterface</code>。

<li>
将所有接口的方法声明成纯虚函数（C++中接口的声明方法）。

<li>
注意<code>DECLARE_META_INTERFACE</code>宏定义，可参考<a href="IBinder接口.html">IBinder接口</a>。
<pre class="brush:c++">
// ISurfaceComposer.h
class ISurfaceComposer : public IInterface
{
public:
    // 声明接口
    DECLARE_META_INTERFACE(SurfaceComposer);

    // ......
    
    // 声明纯虚函数，作为C++的接口
    virtual status_t captureScreen(DisplayID dpy,
            sp&lt;IMemoryHeap&gt;* heap,
            uint32_t* width, uint32_t* height, PixelFormat* format,
            uint32_t reqWidth, uint32_t reqHeight) = 0;
};
</pre>

</ul>

<h3 id="toc_1.3.2">2.定义本地服务基类</h3>
<ul>
<li>
通过<code>BnInterface</code>模板定义一个本地服务的基类。

<li>
定义一个枚举类型，来描述每个方法对应的编号。

<li>
定义一个onTransact方法，当服务被调用时，<code>即先通过该方法筛选编号，再调用对应的方法</code>。
<pre class="brush:c++">
// ISurfaceComposer.h
class BnSurfaceComposer : public BnInterface&lt;ISurfaceComposer&gt;
{
public:
    enum {
        // 这里定义的对应于每个方法的编号，
        // 以IBinder::FIRST_CALL_TRANSACTION开始
        BOOT_FINISHED = IBinder::FIRST_CALL_TRANSACTION,
        CREATE_CONNECTION,
        CREATE_CLIENT_CONNECTION,
        GET_CBLK,
        OPEN_GLOBAL_TRANSACTION,
        CLOSE_GLOBAL_TRANSACTION,
        SET_ORIENTATION,
        FREEZE_DISPLAY,
        UNFREEZE_DISPLAY,
        SIGNAL,
        CAPTURE_SCREEN,
        TURN_ELECTRON_BEAM_OFF,
        TURN_ELECTRON_BEAM_ON,
    };

    virtual status_t    onTransact( uint32_t code,
                                    const Parcel&amp; data,
                                    Parcel* reply,
                                    uint32_t flags = 0);
};
</pre>

</ul>

<h3 id="toc_1.3.3">3.实现代理服务的Proxy</h3>
<ul>
<li>
通过<code>BpInterface</code>模板定义一个代理类，并实现代理类的方法。

<li>
Proxy需要实现每个同名的接口方法，该方法通过Binder机制调用远程的方法，从而起到代理作用。

<li>
注意调用远程方法时，实际传递的是方法的编号，因此需要注意<code>编号和方法的对应关系</code>。

<li>
注意<code>IMPLEMENT_META_INTERFACE</code>宏定义，可参考<a href="IBinder接口.html">IBinder接口</a>。

<li>
Binder工作机制可参考<a href="Binder核心框架层_C.html">Binder核心框架层_C</a>。
<pre class="brush:c++">
// ISurfaceComposer.cpp
class BpSurfaceComposer : public BpInterface&lt;ISurfaceComposer&gt;
{
public:
    BpSurfaceComposer(const sp&lt;IBinder&gt;&amp; impl)
        : BpInterface&lt;ISurfaceComposer&gt;(impl)
    {
    }
    
    // ...... 
	
    virtual status_t captureScreen(DisplayID dpy,
            sp&lt;IMemoryHeap&gt;* heap,
            uint32_t* width, uint32_t* height, PixelFormat* format,
            uint32_t reqWidth, uint32_t reqHeight)
    {
        Parcel data, reply;
        // 写入ISurfaceComposer::getInterfaceDescriptor()，
        // 即IMPLEMENT_META_INTERFACE宏所注册的接口名称，
        // 从而向ServiceManager申请访问权限，
        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());
        data.writeInt32(dpy);
        data.writeInt32(reqWidth);
        data.writeInt32(reqHeight);
	    // 这里是通过remote()和远程对象通信，
        // 调用方法是通过传递编号来实现，如BnSurfaceComposer::CAPTURE_SCREEN。
        remote()-&gt;transact(BnSurfaceComposer::CAPTURE_SCREEN, data, &amp;reply);
        *heap = interface_cast&lt;IMemoryHeap&gt;(reply.readStrongBinder());
        *width = reply.readInt32();
        *height = reply.readInt32();
        *format = reply.readInt32();
        // 返回结果
        return reply.readInt32();
    }
};

// 对应于DECLARE_META_INTERFACE
IMPLEMENT_META_INTERFACE(SurfaceComposer, "android.ui.ISurfaceComposer");
</pre>

</ul>

<h3 id="toc_1.3.4">4.实现本地服务的基类</h3>
<ul>
<li>
本地服务的基类主要实现<code>onTransact</code>方法，参考头文件的定义。

<li>
基类为本地服务实现了复杂的逻辑，包括数据传输等。因此子类不需要关心如何与ServiceManager通信、如何包装数据，只要实现具体的方法供基类调用即可。
<pre class="brush:c++">
// ISurfaceComposer.cpp
status_t BnSurfaceComposer::onTransact(
    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)
{
    // 根据编号筛选
    switch(code) {
        // ......
        // 这里的CAPTURE_SCREEN == FIRST_CALL_TRANSACTION + 10
        case CAPTURE_SCREEN: {
            // 这里的CHECK_INTERFACE是为了检查代理端传递过来的
            // 接口描述是否符合本地的接口描述。
            CHECK_INTERFACE(ISurfaceComposer, data, reply);
            DisplayID dpy = data.readInt32();
            uint32_t reqWidth = data.readInt32();
            uint32_t reqHeight = data.readInt32();
            sp&lt;IMemoryHeap&gt; heap;
            uint32_t w, h;
            PixelFormat f;
            // 这里调用的captureScreen方法是子类的具体实现
            status_t res = captureScreen(dpy, &amp;heap, &amp;w, &amp;h, &amp;f,
                    reqWidth, reqHeight);
            reply-&gt;writeStrongBinder(heap-&gt;asBinder());
            reply-&gt;writeInt32(w);
            reply-&gt;writeInt32(h);
            reply-&gt;writeInt32(f);
            reply-&gt;writeInt32(res);
        } break;
        default:
            return BBinder::onTransact(code, data, reply, flags);
    }
    return NO_ERROR;
}
</pre>

</ul>

<h3 id="toc_1.3.5">5.完成本地服务的功能</h3>
<ul>
<li>
所有的前期准备工作做好后，最终需要实现一个继承于<code>BnSurfaceComposer</code>的子类，该子类完成接口中定义具体功能实现。

<li>
因此在Android系统中，SurfaceFlinger是图形显示系统的最终实现类。
<pre class="brush:c++">
// SurfaceFlinger.h
class SurfaceFlinger :
        public BinderService&lt;SurfaceFlinger&gt;,
        public BnSurfaceComposer,
        protected Thread
{
public:
    static char const* getServiceName() { return "SurfaceFlinger"; }

            SurfaceFlinger();
    virtual ~SurfaceFlinger();
    void    init();

    virtual status_t onTransact(
    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags);

    // ISurfaceComposer interface
    // ......
    virtual status_t    captureScreen(DisplayID dpy,
                              sp&lt;IMemoryHeap&gt;* heap,
                              uint32_t* width,
                              uint32_t* height,
                              PixelFormat* format,
                              uint32_t reqWidth,
                              uint32_t reqHeight);
    // ......
}

// SurfaceFlinger.cpp
// 具体实现captureScreen功能
status_t SurfaceFlinger::captureScreen(DisplayID dpy,
        sp&lt;IMemoryHeap&gt;* heap,
        uint32_t* width, uint32_t* height, PixelFormat* format,
        uint32_t sw, uint32_t sh)
{
    // ......
    sp&lt;MessageBase&gt; msg = new MessageCaptureScreen(this,
            dpy, heap, width, height, format, sw, sh);
    status_t res = postMessageSync(msg);
    if (res == NO_ERROR) {
        res = static_cast&lt;MessageCaptureScreen*&gt;( msg.get() )-&gt;getResult();
    }
    return res;
}
</pre>

</ul>

<h2 id="toc_1.4">Java层和C++层相互调用</h2>
<ul>
<li>
前面提到的两种方式是在Java层调用Java层的Service，在C++层调用C++层的Service。因为彼此都可以找到自己的Proxy类定义，难度并不大。如何在Java层和C++层相互调用呢？

<li>
参考<a href="Binder核心框架层_Java.html">Binder核心框架层_Java</a>中IMyService.Stub的代码，可以手工实现在Java层和C++层的相互调用。

<li>
下面以Framework层调用C++层的SurfaceFlinger为例：
<pre class="brush:java">
try {
    // 传递服务名称给ServiceManager，并返回IBinder对象。
    IBinder surfaceFlinger = ServiceManager.getService("SurfaceFlinger");
    if (surfaceFlinger != null) {
        // 准备好传输数据和返回数据的Parcel对象，注意使用obtain方法
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        // 写入InterfaceToken，该字符串是C++层实现的接口名称，
        // 注意不要将Service名称和接口名称搞混淆。
        data.writeInterfaceToken("android.ui.ISurfaceComposer");
        data.writeString("/sdcard/screenshot.png");
        // 调用transact方法，这里需要关注的是方法的编号，
        // 例如当前调用的编号CAPTURE_SCREEN == FIRST_CALL_TRANSACTION + 10
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION + 10,
                                data, reply, 0);
        // 回收Parcel
        data.recycle();
        reply.recycle();
    }
} catch (RemoteException ex) {
    // ......
}
</pre>

</ul>


<footer>
    <a href="http://zenki2001cn.github.com/Wiki" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="zenki2001cn@163.com" id="back-email">Email</a>
</footer>

</article>
</div>

</body>
</html>
