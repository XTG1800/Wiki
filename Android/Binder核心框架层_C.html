<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Binder核心框架层_C</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
	<link type="text/css" rel="stylesheet" href="css_style/style_zenki.css"/>

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>


<h1 id="toc_1">Binder核心框架层(C/C++)</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">Binder核心框架层(C/C++)</a></li>
<ul>
<li><a href="#toc_1.1">相关文件</a></li>
<li><a href="#toc_1.2">主要类定义</a></li>
<li><a href="#toc_1.3">基本概念</a></li>
<ul>
<li><a href="#toc_1.3.1">引用计数</a></li>
<li><a href="#toc_1.3.2">什么是Binder</a></li>
<li><a href="#toc_1.3.3">传输介质Parcel</a></li>
<li><a href="#toc_1.3.4">权限管理</a></li>
</ul>
<li><a href="#toc_1.4">要点总结</a></li>
</ul>
</ul>
</div>

<h2 id="toc_1.1">相关文件</h2>
<pre class="brush:text">
frameworks/base/include/utils/*
frameworks/base/libs/utils/*
frameworks/base/include/binder/*
frameworks/base/libs/binder/*
</pre>

<h2 id="toc_1.2">主要类定义</h2>
<p>
<img src="pic/Binder_core.jpg" />
</p>

<ul>
<li>
<strong>RefBase.h</strong> 引用计数，定义类RefBase、模板sp(强引用计数指针)和wp(弱引用计数指针)。
</li>
<li>
<strong>Parcel.h</strong> 在IPC中传输的数据容器，定义类Parcel。
</li>
<li>
<strong>IBinder.h</strong> Binder对象的抽象接口，定义类IBinder。
</li>
<li>
<strong>Binder.h</strong> Binder核心组件，定义服务器端基类BBinder和BpRefBase。
</li>
<li>
<strong>BpBinder.h</strong> Binder核心组件，定义客户端基类BpBinder。
</li>
<li>
<strong>IInterface.h</strong> 为Binder的接口定义通用类。定义类IInterface、类模板BnInterface、类模板BpInterface。
</li>
<li>
<strong>ProcessState.h</strong> 表示进程状态的类，定义类ProcessState。
</li>
<li>
<strong>IPCThreadState.h</strong> 表示IPC线程的类，定义类IPCThreadState。
</li>
</ul>

<h2 id="toc_1.3">基本概念</h2>
<ul>
<li>
这部分主要阐述C++层的Binder机制，因为Java层的类最终通过JNI接口调用C++层的实现。
</li>
<li>
<strong>Native——本地:</strong> 如BnABC，这是一个需要被继承和实现的类，通常是Server端的实现。
</li>
<li>
<strong>Proxy——代理:</strong> 例如BpABC，这是一个在接口框架中被实现的类，通常不被暴露出来，对于使用者来说是透明的。
</li>
<li>
<strong>服务端:</strong> 对应于BnABC，具体服务的提供者，通常是一个独立进程。
</li>
<li>
<strong>客户端:</strong> 对应于BpABC，服务的请求者。例如客户端查询到某个Binder对象，在使用的时候实际上被转换成BpABC，而BpABC则通过Binder驱动调用远程的相应方法。
</li>
</ul>

<h3 id="toc_1.3.1">引用计数</h3>
<pre class="brush:text">
    从驱动层协议和Binder的模型，我们知道Binder在客户端、驱动、服务端之间传递，必须有一种机制标识
Binder被哪些对象使用，什么时候销毁，就像Java对象，要维护一个对象的引用计数，在某种情况下自动销毁
该对象。Android如何实现引用计数，首先要了解Binder的基类，以及它的工作原理。
</pre>

<ul>
<li>
<a href="sp和wp.html">sp和wp</a>
</li>
</ul>

<h3 id="toc_1.3.2">什么是Binder</h3>
<pre class="brush:text">
    这个问题不是真正意义上的Binder定义，而是指在代码实现中怎样定义Binder。Binder的本质是代理模式，
因此需要提供一个基本的代理端和服务端实现。Android首先定义了IBinder这个接口，它包含了基本的通信方法，
例如传输数据、判断Binder连接等等。从这个接口派生出两个子类：BpBinder和BBinder。这两个类分别完成代理
端和服务端需要实现的基本功能。
</pre>

<ul>
<li>
<a href="IBinder接口.html">IBinder接口</a>
</li>
</ul>

<h3 id="toc_1.3.3">传输介质Parcel</h3>
<pre class="brush:text">
    Binder在传输过程使用的可序列化对象称之为Parcel。它能够将一个类的对象实例保存在内存中，并在跨进程
后能够还原成该类的对象实例，如同在同一个进程中一样。我们要讨论的重点是它能够充当Binder传输介质的角色，
必须具备哪些特性？
</pre>

<ul>
<li>
<a href="Parcel传输介质.html">Parcel传输介质</a>
</li>
</ul>

<h3 id="toc_1.3.4">权限管理</h3>
<pre class="brush:text">
    权限管理也是作为Service加入到Android系统中，它同样通过Binder来实现。由于大多数情况下系统服务需要对
客户端进行权限验证，因此我将它划分到核心框架层中。
</pre>

<ul>
<li>
<a href="IPermissionController权限管理.html">IPermissionController权限管理</a>
</li>
</ul>

<h2 id="toc_1.4">要点总结</h2>
<ul>
<li>
了解以上概念，我们大概知道什么是RefBase，IBinder继承于RefBase是为了维护它在客户端的引用计数。
</li>
<li>
sp和wp用来管理引用计数，它提供了增加和减少引用计数的方法。并知道强引用和弱引用的差别。
</li>
<li>
Binder使用了代理模式，BBinder代表服务端，BpBinder代表代理端。两者完成了IBinder与驱动交互的过程。
</li>
<li>
定义一个服务的同时，就定义了一个接口IInterface。BnInterface是实现服务端的基类，BpInterface是实现代理端的基类，它们都具备Binder通信的功能。
</li>
<li>
了解Parcel的实现，它如何序列化一个对象并将之还原。它可以作为Binder的传输介质是因为它自身具有Binder通信的功能。
</li>
</ul>
<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

<!--<script type="text/javascript">-->
<!--var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");-->
<!--document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));-->
<!--</script>-->
<!--<script type="text/javascript">-->
<!--try {-->
<!--var pageTracker = _gat._getTracker("UA-15922433-1");-->
<!--pageTracker._trackPageview();-->
<!--} catch(err) {}-->
<!--</script>-->

</body>
</html>
