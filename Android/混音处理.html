<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>混音处理</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <link rel="Stylesheet" type="text/css" href="../css_style/style_zenki.css">

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>

<!-- wrap the vimwiki html -->

<h1 id="toc_1">混音处理</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">混音处理</a>
<ul>
<li><a href="#toc_1.1">混音初始化</a>
<ul>
<li><a href="#toc_1.1.1">AudioMixer::AudioMixer</a>
<li><a href="#toc_1.1.2">struct state_t</a>
</ul>
<li><a href="#toc_1.2">加载音频缓冲区</a>
<ul>
<li><a href="#toc_1.2.1">AudioMixer::setBufferProvider</a>
</ul>
<li><a href="#toc_1.3">混音方法的选择</a>
<ul>
<li><a href="#toc_1.3.1">AudioMixer::enable</a>
<li><a href="#toc_1.3.2">AudioMixer::invalidateState</a>
<li><a href="#toc_1.3.3">AudioMixer::process__validate</a>
</ul>
<li><a href="#toc_1.4">混音函数的执行</a>
<ul>
<li><a href="#toc_1.4.1">AudioMixer::process</a>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">混音初始化</h2>
<ul>
<li>
混音处理用到AudioMixer类。当MixerThread线程初始化时，会创建AudioMixer对象。

<li>
stat_t数据结构用来保存需要的信息，其中<code>hook</code>成员对应数据处理的方法指针。默认包含以下几种处理方式：

<ul>
<li>
AudioMixer::process__nop：什么也不做。

<li>
AudioMixer::process__genericNoResampling：普通无需重采样。

<li>
AudioMixer::process__genericResampling：普通需重采样。

<li>
AudioMixer::process__OneTrack16BitsStereoNoResampling：一路音频流，双声双道，PCM16格式，无需重采样。

<li>
AudioMixer::process__TwoTracks16BitsStereoNoResampling：两路音频流，双声道，PCM16格式，无需重采样。

<li>
AudioMixer::process__validate：根据Track的格式信息动态选择其他的处理函数。

</ul>
<li>
当所有参数设置好后，真正的混音操作是在处理线程中调用<code>AudioMixer::process</code>。

</ul>

<p>
<img src="http:pic/thread_track.png" />
</p>

<h3 id="toc_1.1.1">AudioMixer::AudioMixer</h3>
<pre class="brush:c++">
AudioMixer::AudioMixer(size_t frameCount, uint32_t sampleRate)
    : mActiveTrack(0), mTrackNames(0), mSampleRate(sampleRate)
{
    mState.enabledTracks= 0;
    mState.needsChanged = 0;
    mState.frameCount   = frameCount;   // 该值等于音频输出对象的缓冲大小
    mState.outputTemp   = 0;
    mState.resampleTemp = 0;
    mState.hook         = process__nop; // 设置数据处理hook，初始值为无任何操作
    track_t* t = mState.tracks;         // track_t是和Track相对应的结构
    
    // 支持32路混音
    for (int i=0 ; i&lt;32 ; i++) {
        t-&gt;needs = 0;
        t-&gt;volume[0] = UNITY_GAIN;
        t-&gt;volume[1] = UNITY_GAIN;
        t-&gt;volumeInc[0] = 0;
        t-&gt;volumeInc[1] = 0;
        t-&gt;auxLevel = 0;
        t-&gt;auxInc = 0;
        t-&gt;channelCount = 2;
        t-&gt;enabled = 0;
        t-&gt;format = 16;
        t-&gt;buffer.raw = 0;
        t-&gt;bufferProvider = 0;          // 一路Track的数据提供者
        t-&gt;hook = 0;                    // 每一个Track也有一个hook函数
        t-&gt;resampler = 0;
        t-&gt;sampleRate = mSampleRate;
        t-&gt;in = 0;
        t-&gt;mainBuffer = NULL;
        t-&gt;auxBuffer = NULL;
        t++;
    }
}
</pre>

<h3 id="toc_1.1.2">struct state_t</h3>
<pre class="brush:c++">
typedef void (*mix_t)(state_t* state);
typedef void (*hook_t)(track_t* t, int32_t* output, size_t numOutFrames, int32_t* temp, int32_t* aux);

struct state_t {
    uint32_t        enabledTracks;
    uint32_t        needsChanged;
    size_t          frameCount;
    mix_t           hook;
    int32_t         *outputTemp;
    int32_t         *resampleTemp;
    int32_t         reserved[2];
    track_t         tracks[32]; __attribute__((aligned(32)));
};
</pre>

<h2 id="toc_1.2">加载音频缓冲区</h2>
<ul>
<li>
setBufferProvider方法将AudioBufferProvider类型作为参数（即Track的基类），加入到当前的state_t状态变量中。

</ul>

<h3 id="toc_1.2.1">AudioMixer::setBufferProvider</h3>
<pre class="brush:c++">
status_t AudioMixer::setBufferProvider(AudioBufferProvider* buffer)
{
    mState.tracks[ mActiveTrack ].bufferProvider = buffer;
    return NO_ERROR;
}
</pre>

<h2 id="toc_1.3">混音方法的选择</h2>
<ul>
<li>
enable方法用来开启混音功能，它根据一个整形标识，决定采用哪种混音方法。

<li>
这里需要注意一个技巧，即混音方法的选择本身也是通过一个process方法来处理。

<ul>
<li>
enable会调用invalidateState方法，并将hook设置成process__validate。

<li>
再调用process__validate来动态选择混音处理的方法。

</ul>
</ul>

<h3 id="toc_1.3.1">AudioMixer::enable</h3>
<pre class="brush:c++">
status_t AudioMixer::enable(int name)
{
    switch (name) {
        case MIXING: {
            if (mState.tracks[ mActiveTrack ].enabled != 1) {
                mState.tracks[ mActiveTrack ].enabled = 1;
                // 调用状态变更的方法
                invalidateState(1&lt;&lt;mActiveTrack);
            }
        } break;
        default:
            return NAME_NOT_FOUND;
    }
    return NO_ERROR;
}
</pre>

<h3 id="toc_1.3.2">AudioMixer::invalidateState</h3>
<pre class="brush:c++">
void AudioMixer::invalidateState(uint32_t mask)
{
    if (mask) {
        mState.needsChanged |= mask;
        // 将hook设置为process__validate
        mState.hook = process__validate;
    }
}
</pre>

<h3 id="toc_1.3.3">AudioMixer::process__validate</h3>
<pre class="brush:c++">
void AudioMixer::process__validate(state_t* state)
{
    ......
    state-&gt;hook = process__nop;
    if (countActiveTracks) {
        if (resampling) {
            ...... 
            // 如果需要重采样，则选择process__genericResampling
            state-&gt;hook = process__genericResampling;
        } else {
            ...... 
            state-&gt;hook = process__genericNoResampling;
            if (all16BitsStereoNoResample &amp;&amp; !volumeRamp) {
                if (countActiveTracks == 1) {
                    state-&gt;hook = process__OneTrack16BitsStereoNoResampling;
                }
            }
        }
    }

    if (countActiveTracks) {
        ...... 
        if (allMuted) {
            state-&gt;hook = process__nop;
        } else if (all16BitsStereoNoResample) {
            if (countActiveTracks == 1) {
                // 只有一个Track，则选择process__OneTrack16BitsStereoNoResampling
                state-&gt;hook = process__OneTrack16BitsStereoNoResampling;
            }
        }
    }
}
</pre>

<h2 id="toc_1.4">混音函数的执行</h2>
<h3 id="toc_1.4.1">AudioMixer::process</h3>
<pre class="brush:c++">
void AudioMixer::process()
{
    // hook是mix_t类型的函数指针，指向了上面列出的process*方法。
    // 参数为state_t类型的结构对象
    mState.hook(&amp;mState);
}
</pre>


<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

</body>
</html>
