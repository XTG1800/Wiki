<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>WifiService分析</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
	<link type="text/css" rel="stylesheet" href="css_style/style_zenki.css"/>

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>


<h1 id="toc_1">WifiService分析</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">WifiService分析</a></li>
<ul>
<li><a href="#toc_1.1">相关文件</a></li>
<li><a href="#toc_1.2">WifiService初始化</a></li>
<li><a href="#toc_1.3">WIFI状态机</a></li>
<li><a href="#toc_1.4">处理飞行模式</a></li>
<ul>
<li><a href="#toc_1.4.1">updateWifiState</a></li>
</ul>
<li><a href="#toc_1.5">处理网络、WIFI状态变化和扫描结果通知</a></li>
<li><a href="#toc_1.6">处理待机状态、充电状态及其他</a></li>
</ul>
</ul>
</div>

<h2 id="toc_1.1">相关文件</h2>
<pre class="brush:text">
framework/base/services/java/com/android/server/WifiService.java
</pre>

<h2 id="toc_1.2">WifiService初始化</h2>
<ul>
<li>
WifiService的初始化主要完成以下功能：
</li>
<ul>
<li>
通过SystemProperties获取wifi的接口名称。如默认为wifi.interface: wlan0。
</li>
<li>
初始化WifiStateMachine，该类用于跟踪Wifi的状态。
</li>
<li>
获取电池状态的Service，处理Wifi是否休眠时电池使用的特殊情况。
</li>
<li>
注册了两个BroadcastReceiver：
</li>
<ul>
<li>
处理飞行模式的消息。
</li>
<li>
处理网络状态变化。
</li>
<li>
处理Wifi状态变化。
</li>
<li>
处理扫描结果通知。
</li>
</ul>
<li>
通过AsyncServiceHandler处理客户端的异步请求。
</li>
<li>
通过WifiStateMachineHandler处理Wifi状态的请求。
</li>
<li>
设置Wifi连接的超时通知机制。
</li>
</ul>
</ul>

<pre class="brush:java">
WifiService(Context context) {
    mContext = context;

    // 获取Wifi接口
    mInterfaceName =  SystemProperties.get("wifi.interface", "wlan0");

    mWifiStateMachine = new WifiStateMachine(mContext, mInterfaceName);
    mWifiStateMachine.enableRssiPolling(true);
    mBatteryStats = BatteryStatsService.getService();

    mAlarmManager = (AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE);
    Intent idleIntent = new Intent(ACTION_DEVICE_IDLE, null);
    mIdleIntent = PendingIntent.getBroadcast(mContext, IDLE_REQUEST, idleIntent, 0);

    // ...... 
    // 异步消息的处理机制
    HandlerThread wifiThread = new HandlerThread("WifiService");
    wifiThread.start();
    mAsyncServiceHandler = new AsyncServiceHandler(wifiThread.getLooper());
    mWifiStateMachineHandler = new WifiStateMachineHandler(wifiThread.getLooper());

    // 连接超时设置
    NOTIFICATION_REPEAT_DELAY_MS = Settings.Secure.getInt(context.getContentResolver(),
            Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY, 900) * 1000l;
    mNotificationEnabledSettingObserver = new NotificationEnabledSettingObserver(new Handler());
    mNotificationEnabledSettingObserver.register();

    mBackgroundScanSupported = mContext.getResources().getBoolean(
            com.android.internal.R.bool.config_wifi_background_scan_support);
}
</pre>

<h2 id="toc_1.3">WIFI状态机</h2>
<ul>
<li>
WifiService实现的大部分功能是通过调用WifiStateMachine类的接口完成。
</li>
<li>
<a href="WIFI状态机.html">WIFI状态机</a>的实现。
</li>
</ul>

<h2 id="toc_1.4">处理飞行模式</h2>
<ul>
<li>
飞行模式的处理是通过注册一个BroadcastReceiver，当接收到Intent.ACTION_AIRPLANE_MODE_CHANGED后，查询数据库信息来判断是否处于飞行模式。
</li>
</ul>

<pre class="brush:java">
WifiService(Context context) {
    // ......
    mContext.registerReceiver(
        new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                mAirplaneModeOn.set(isAirplaneModeOn());
                if (!mAirplaneModeOn.get() &amp;&amp; (testAndClearWifiSavedState() ||
                    mPersistWifiState.get() == WIFI_ENABLED_AIRPLANE_OVERRIDE)) {
                        persistWifiState(true);
                }
                // 更新Wifi状态
                updateWifiState();
            }
        },
        new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
}
</pre>

<h3 id="toc_1.4.1">updateWifiState</h3>
<ul>
<li>
该方法用来更新Wifi状态，主要是通过调用状态机的相关方法与底层交互。
</li>
</ul>

<pre class="brush:java">
private void updateWifiState() {
    boolean lockHeld = mLocks.hasLocks();
    int strongestLockMode = WifiManager.WIFI_MODE_FULL;
    boolean wifiShouldBeStarted;

    if (mEmergencyCallbackMode) {
        wifiShouldBeStarted = false;
    } else {
        wifiShouldBeStarted = !mDeviceIdle || lockHeld;
    }

    if (lockHeld) {
        strongestLockMode = mLocks.getStrongestLockMode();
    }
    // If device is not idle, lockmode cannot be scan only
    if (!mDeviceIdle &amp;&amp; strongestLockMode == WifiManager.WIFI_MODE_SCAN_ONLY) {
        strongestLockMode = WifiManager.WIFI_MODE_FULL;
    }

    // Disable tethering when airplane mode is enabled 
    if (mAirplaneModeOn.get()) {
        mWifiStateMachine.setWifiApEnabled(null, false);
    }

    if (shouldWifiBeEnabled()) {
        if (wifiShouldBeStarted) {
            reportStartWorkSource();
            mWifiStateMachine.setWifiEnabled(true);
            mWifiStateMachine.setScanOnlyMode(
                    strongestLockMode == WifiManager.WIFI_MODE_SCAN_ONLY);
            mWifiStateMachine.setDriverStart(true, mEmergencyCallbackMode);
            mWifiStateMachine.setHighPerfModeEnabled(strongestLockMode
                    == WifiManager.WIFI_MODE_FULL_HIGH_PERF);
        } else {
            mWifiStateMachine.setDriverStart(false, mEmergencyCallbackMode);
        }
    } else {
        mWifiStateMachine.setWifiEnabled(false);
    }
}
</pre>

<h2 id="toc_1.5">处理网络、WIFI状态变化和扫描结果通知</h2>
<ul>
<li>
通过BroadcastReceiver实现网络、Wifi状态的切换及扫描完成的结果通知。注意三个WifiManager类定义的Action。
</li>
</ul>

<pre class="brush:java">
WifiService(Context context) {
    // ......
    IntentFilter filter = new IntentFilter();
    filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
    filter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
    filter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);

    mContext.registerReceiver(
        new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                if (intent.getAction().equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {
                    int wifiState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE,
                            WifiManager.WIFI_STATE_DISABLED);

                    mWifiEnabled = (wifiState == WifiManager.WIFI_STATE_ENABLED);

                    // reset &amp; clear notification on any wifi state change
                    resetNotification();
                } else if (intent.getAction().equals(
                        WifiManager.NETWORK_STATE_CHANGED_ACTION)) {
                    mNetworkInfo = (NetworkInfo) intent.getParcelableExtra(
                            WifiManager.EXTRA_NETWORK_INFO);
                    // reset &amp; clear notification on a network connect &amp; disconnect
                    switch(mNetworkInfo.getDetailedState()) {
                        case CONNECTED:
                        case DISCONNECTED:
                            evaluateTrafficStatsPolling();
                            resetNotification();
                            break;
                    }
                } else if (intent.getAction().equals(
                        WifiManager.SCAN_RESULTS_AVAILABLE_ACTION)) {
                    checkAndSetNotification();
                }
            }
        }, filter);
}
</pre>

<h2 id="toc_1.6">处理待机状态、充电状态及其他</h2>
<ul>
<li>
WifiService内部又注册了一个BroadcastReceiver来处理接收屏幕点亮、屏幕关闭、电池充电等状态，并在这些状态下处理WIFI的特殊行为。
</li>
</ul>

<pre class="brush:java">
private void registerForBroadcasts() {
    IntentFilter intentFilter = new IntentFilter();
    intentFilter.addAction(Intent.ACTION_SCREEN_ON);
    intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
    intentFilter.addAction(Intent.ACTION_BATTERY_CHANGED);
    intentFilter.addAction(ACTION_DEVICE_IDLE);
    intentFilter.addAction(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED);
    intentFilter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
    mContext.registerReceiver(mReceiver, intentFilter);
}
</pre>

<ul>
<li>
构造的BroadcastReceiver内部成员对象。
</li>
</ul>

<pre class="brush:java">
private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
        // ......
        if (action.equals(Intent.ACTION_SCREEN_ON)) {
            // ......
            evaluateTrafficStatsPolling();
            // ......
            setDeviceIdleAndUpdateWifi(false);
        } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
            // ......
            evaluateTrafficStatsPolling();
            if (mBackgroundScanSupported) {
                mWifiStateMachine.enableBackgroundScanCommand(true);
            }
            // ...... 
        } else if (action.equals(ACTION_DEVICE_IDLE)) {
            setDeviceIdleAndUpdateWifi(true);
        } else if (action.equals(Intent.ACTION_BATTERY_CHANGED)) {
            // ......
            if (mScreenOff &amp;&amp; shouldWifiStayAwake(stayAwakeConditions, mPluggedType) &amp;&amp;
                    !shouldWifiStayAwake(stayAwakeConditions, pluggedType)) {
                long triggerTime = System.currentTimeMillis() + idleMillis;
                mAlarmManager.set(AlarmManager.RTC_WAKEUP, triggerTime, mIdleIntent);
            }
        } else if (action.equals(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED)) {
            int state = intent.getIntExtra(BluetoothAdapter.EXTRA_CONNECTION_STATE,
                    BluetoothAdapter.STATE_DISCONNECTED);
            mWifiStateMachine.sendBluetoothAdapterStateChange(state);
        } else if (action.equals(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED)) {
            mEmergencyCallbackMode = intent.getBooleanExtra("phoneinECMState", false);
            updateWifiState();
        }
    }
}
</pre>
<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

<!--<script type="text/javascript">-->
<!--var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");-->
<!--document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));-->
<!--</script>-->
<!--<script type="text/javascript">-->
<!--try {-->
<!--var pageTracker = _gat._getTracker("UA-15922433-1");-->
<!--pageTracker._trackPageview();-->
<!--} catch(err) {}-->
<!--</script>-->

</body>
</html>
