<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>通过Zygote产生真正的进程</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
	<link type="text/css" rel="stylesheet" href="css_style/style_zenki.css"/>

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>


<h1 id="toc_1">通过Zygote产生真正的进程</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">通过Zygote产生真正的进程</a></li>
<ul>
<li><a href="#toc_1.1">流程分析</a></li>
<li><a href="#toc_1.2">参考代码</a></li>
<ul>
<li><a href="#toc_1.2.1">ActivityManagerService类</a></li>
<ul>
<li><a href="#toc_1.2.1.1">方法：startProcessLocked</a></li>
</ul>
<li><a href="#toc_1.2.2">Process类</a></li>
<ul>
<li><a href="#toc_1.2.2.1">方法：start</a></li>
<li><a href="#toc_1.2.2.2">方法：startViaZygote</a></li>
<li><a href="#toc_1.2.2.3">方法：zygoteSendArgsAndGetPid</a></li>
</ul>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">流程分析</h2>
<ul>
<li>
两个IPC之后，目标转移到<code>ActivityManagerService</code>类
</li>
<li>
ActivityManagerService调用startActivity()方法，该方法调用<code>startProcessLocked()</code>方法，并通过<code>Process.start()</code>与Zygote交互
</li>
<li>
Process.start()调用了<code>android.app.ActivityThread</code>类作为参数
</li>
</ul>

<h2 id="toc_1.2">参考代码</h2>
<h3 id="toc_1.2.1">ActivityManagerService类</h3>
<pre class="brush:java">
public final class ActivityManagerService extends ActivityManagerNative implements Watchdog.Monitor 
</pre>

<h4 id="toc_1.2.1.1">方法：startProcessLocked</h4>
<pre class="brush:java">
private final void startProcessLocked(ProcessRecord app,
            String hostingType, String hostingNameStr) {
        
    ......

    // 调用Process类的start方法，返回一个PID
    int pid = Process.start("android.app.ActivityThread", mSimpleProcessManagement ? app.processName : null, uid, uid,
                             gids, debugFlags, null);
    ......
} 
</pre>

<h3 id="toc_1.2.2">Process类</h3>
<ul>
<li>
<code>start()</code>方法为隐藏方法，framework没有对开发者开放，该方法启动Activity有两种模式，一个是进程模式，一个是线程模式
</li>
<li>
首先通过调用JNI接口读取/proc/下进程信息，返回是否支持进程。如果是，则通过与zygote通信并由它产生进程，否则以线程模式运行
</li>
<li>
当以进程模式运行时，start()调用<code>startViaZygote()</code>方法，继而调用<code>zygoteSendArgsAndGetPid()</code>方法与Zygote进行通信，Zygote通过fork()调用产生子进程
</li>
</ul>

<h4 id="toc_1.2.2.1">方法：start</h4>
<pre class="brush:java">
// 启动入口方法
public static final int start(final String processClass,
                                  final String niceName,
                                  int uid, int gid, int[] gids,
                                  int debugFlags,
                                  String[] zygoteArgs) {
    // 以进程模式运行
    if (supportsProcesses()) {
        try {
            return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, zygoteArgs);
        } catch (ZygoteStartFailedEx ex) {
        }
    } else {
        // 以线程模式运行
        Runnable runnable = new Runnable() {
                    public void run() {
                        Process.invokeStaticMain(processClass);
                    }
        };
        
        // Thread constructors must not be called with null names (see spec). 
        if (niceName != null) {
            new Thread(runnable, niceName).start();
        } else {
            new Thread(runnable).start();
        }
        
        return 0;
    }
}
</pre>

<h4 id="toc_1.2.2.2">方法：startViaZygote</h4>
<pre class="brush:java">
// 启动Zygote
private static int startViaZygote(final String processClass,
                                  final String niceName,
                                  final int uid, final int gid,
                                  final int[] gids,
                                  int debugFlags,
                                  String[] extraArgs)
                                  throws ZygoteStartFailedEx {
    int pid;

    synchronized(Process.class) {
        .....
        pid = zygoteSendArgsAndGetPid(argsForZygote);
    }
}
</pre>

<h4 id="toc_1.2.2.3">方法：zygoteSendArgsAndGetPid</h4>
<pre class="brush:java">
// socket通信阶段
private static int zygoteSendArgsAndGetPid(ArrayList&lt;String&gt; args)
            throws ZygoteStartFailedEx {

    int pid;

    // 检查是否需要建立socket连接
    openZygoteSocketIfNeeded();

    try {
        /**
         * 该注释详细描述了Zygote的通信规则
         * See com.android.internal.os.ZygoteInit.readArgumentList()
         * Presently the wire format to the zygote process is:
         * a) a count of arguments (argc, in essence)
         * b) a number of newline-separated argument strings equal to count
         *
         * After the zygote process reads these it will write the pid of
         * the child or -1 on failure.
         */

        sZygoteWriter.write(Integer.toString(args.size()));
        sZygoteWriter.newLine();

        int sz = args.size();
        for (int i = 0; i &lt; sz; i++) {
            String arg = args.get(i);
            if (arg.indexOf('\n') &gt;= 0) {
                throw new ZygoteStartFailedEx(
                        "embedded newlines not allowed");
            }
            sZygoteWriter.write(arg);
            sZygoteWriter.newLine();
        }

        sZygoteWriter.flush();

        // Should there be a timeout on this?
        pid = sZygoteInputStream.readInt();

        ......
    } catch (IOException ex) {
        ......
    }

    return pid;
}
</pre>
<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

<!--<script type="text/javascript">-->
<!--var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");-->
<!--document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));-->
<!--</script>-->
<!--<script type="text/javascript">-->
<!--try {-->
<!--var pageTracker = _gat._getTracker("UA-15922433-1");-->
<!--pageTracker._trackPageview();-->
<!--} catch(err) {}-->
<!--</script>-->

</body>
</html>
