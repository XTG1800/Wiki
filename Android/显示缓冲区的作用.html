<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>显示缓冲区的作用</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
	<link type="text/css" rel="stylesheet" href="css_style/style_zenki.css"/>

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>


<h1 id="toc_1">显示缓冲区的作用</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">显示缓冲区的作用</a></li>
<ul>
<li><a href="#toc_1.1">概述</a></li>
<li><a href="#toc_1.2">锁定显示缓冲区</a></li>
<ul>
<li><a href="#toc_1.2.1">lockCanvas(Surface.java)</a></li>
<li><a href="#toc_1.2.2">Surface_lockCanvas(JNI)</a></li>
<li><a href="#toc_1.2.3">Surface::lock(C++)</a></li>
<li><a href="#toc_1.2.4">Surface::dequeueBuffer(C++层)</a></li>
</ul>
<li><a href="#toc_1.3">释放显示缓冲区</a></li>
<ul>
<li><a href="#toc_1.3.1">unlockCanvasAndPost(Java层)</a></li>
<li><a href="#toc_1.3.2">Surface_unlockCanvasAndPost(JNI)</a></li>
<li><a href="#toc_1.3.3">Surface::unlockAndPost(C++层)</a></li>
<li><a href="#toc_1.3.4">Surface::queueBuffer(C++层)</a></li>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">概述</h2>
<pre class="brush:text">
    C++层的Surface实际是通过SurfaceHandle将Java层的Surface对象转换而来。该对象会锁定绘图
缓冲区以供绘图者进行绘图，之后解锁缓冲区再投递给SurfaceFlinger显示输出。
</pre>

<h2 id="toc_1.2">锁定显示缓冲区</h2>
<ul>
<li>
虽然在SurfaceFlinger在创建Layer时已经为每个Layer申请了两个缓冲区，但是此时在JAVA层并看不到这两个缓冲区，JAVA层要想在Surface上进行画图操作，必须要先把其中的一个缓冲区绑定到Canvas中，然后所有对该Canvas的画图操作最后都会画到该缓冲区内。
</li>
<ul>
<li>
Surface(java层)会先调用lockCanvas()来得到要进行画图操作的Canvas，lockCanvas会进一步调用native层的 Surface_lockCanvas，native代码利用Java层传入的SurfaceControl对象，通过getSurface()取得native层的 Surface对象，接着调用该Surface对象的lock()方法。
</li>
<li>
lock()返回了该Surface的信息，其中包括了可用缓冲区的首地址vaddr，该vaddr在Android的2D图形库Skia中，创建了一个bitmap，然后通过Skia库中Canvas的 API：Canvas.setBitmapDevice(bitmap)，把该bitmap绑定到Canvas中。
</li>
<li>
最后把这个Canvas返回给Java 层，这样JAVA层就可以在该Canvas上进行画图操作，而这些画图操作最终都会画在以vaddr为首地址的缓冲区中。
</li>
</ul>
</ul>

<p>
<a href="pic/lock_surface.png"><img src="pic/lock_surface.png" /></a>
</p>

<h3 id="toc_1.2.1">lockCanvas(Surface.java)</h3>
<pre class="brush:java">
public Canvas lockCanvas(Rect dirty) throws OutOfResourcesException, IllegalArgumentException
{
    /* the dirty rectangle may be expanded to the surface's size, if
     * for instance it has been resized or if the bits were lost, since
     * the last call.
     */
    return lockCanvasNative(dirty);
}
</pre>

<h3 id="toc_1.2.2">Surface_lockCanvas(JNI)</h3>
<pre class="brush:c++">
static jobject Surface_lockCanvas(JNIEnv* env, jobject clazz, jobject dirtyRect)
{
    // 通过SurfaceControl.getSurface()获取Surface对象
    const sp&lt;Surface&gt;&amp; surface(getSurface(env, clazz));
    ......
    
    // 锁定缓冲区
    Surface::SurfaceInfo info;
    status_t err = surface-&gt;lock(&amp;info, &amp;dirtyRegion);
    ...... 

    // 获取Java层的Canvas
    jobject canvas = env-&gt;GetObjectField(clazz, so.canvas);
    env-&gt;SetIntField(canvas, co.surfaceFormat, info.format);

    // SKia图形库对象
    SkCanvas* nativeCanvas = (SkCanvas*)env-&gt;GetIntField(canvas, no.native_canvas);
    SkBitmap bitmap;
    ...... 
    nativeCanvas-&gt;setBitmapDevice(bitmap);
    ...... 

    nativeCanvas-&gt;clipRegion(clipReg);
    int saveCount = nativeCanvas-&gt;save();
    env-&gt;SetIntField(clazz, so.saveCount, saveCount);
    ...... 
    
    // 返回Java层的Canvas对象
    return canvas;
}
</pre>

<h3 id="toc_1.2.3">Surface::lock(C++)</h3>
<pre class="brush:c++">
status_t Surface::lock(SurfaceInfo* other, Region* dirtyIn, bool blocking) 
{
    ......
    android_native_buffer_t* out;
    // 分配新的内存空间并将其加入缓冲队列，返回给out
    status_t err = dequeueBuffer(&amp;out);
    if (err == NO_ERROR) {
        // 从刚才得到的buffer创建GraphicBuffer对象，
        // 该对象是用来更新显示的缓冲区，叫做背景缓冲区。
        // 重画动作在背景缓冲区进行。
        sp&lt;GraphicBuffer&gt; backBuffer(GraphicBuffer::getSelf(out));
        // 锁定这片内存
        err = lockBuffer(backBuffer.get());
        if (err == NO_ERROR) {
            const Rect bounds(backBuffer-&gt;width, backBuffer-&gt;height);
            const Region boundsRegion(bounds);
            Region scratch(boundsRegion);
            // newDirtyRegion是需要重画的区域
            Region&amp; newDirtyRegion(dirtyIn ? *dirtyIn : scratch);
            newDirtyRegion &amp;= boundsRegion;

            // 已经显示出来的frontBuffer叫做前景缓冲区
            // 判断是否需要拷贝frontBuffer到backBuffer
            const sp&lt;GraphicBuffer&gt;&amp; frontBuffer(mPostedBuffer);
            const bool canCopyBack = (frontBuffer != 0 &amp;&amp;
                    backBuffer-&gt;width  == frontBuffer-&gt;width &amp;&amp;
                    backBuffer-&gt;height == frontBuffer-&gt;height &amp;&amp;
                    backBuffer-&gt;format == frontBuffer-&gt;format &amp;&amp;
                    !(mFlags &amp; ISurfaceComposer::eDestroyBackbuffer));

            mDirtyRegion = newDirtyRegion;

            // 如果需要做拷贝动作，则将frontBuffer中非newDirtyRegion区域
            // 拷贝到backBuffer中
            if (canCopyBack) {
                const Region copyback(mOldDirtyRegion.subtract(newDirtyRegion));
                if (!copyback.isEmpty())
                    copyBlt(backBuffer, frontBuffer, copyback);
            } else {
                // 如果不需要拷贝，则重画整个区域
                newDirtyRegion = boundsRegion;
            }

            mOldDirtyRegion = newDirtyRegion;

            // 锁定将要画图的缓冲区，并返回一个地址给调用者
            void* vaddr;
            status_t res = backBuffer-&gt;lock(
                    GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,
                    newDirtyRegion.bounds(), &amp;vaddr);
            
            // 返回给SurfaceInfo参数other
            mLockedBuffer = backBuffer;
            other-&gt;w      = backBuffer-&gt;width;
            other-&gt;h      = backBuffer-&gt;height;
            other-&gt;s      = backBuffer-&gt;stride;
            other-&gt;usage  = backBuffer-&gt;usage;
            other-&gt;format = backBuffer-&gt;format;
            other-&gt;bits   = vaddr;
        }
    }
    mApiLock.unlock();
    return err;
}
</pre>

<h3 id="toc_1.2.4">Surface::dequeueBuffer(C++层)</h3>
<pre class="brush:c++">
int Surface::dequeueBuffer(android_native_buffer_t** buffer)
{
    ......
    // 与Server端同步
    ssize_t bufIdx = mSharedBufferClient-&gt;dequeue();

    if (bufIdx &lt; 0) {
        return bufIdx;
    }

    // grow the buffer array if needed
    const size_t size = mBuffers.size();
    const size_t needed = bufIdx+1;
    if (size &lt; needed) {
        mBuffers.insertAt(size, needed-size);
    }

    uint32_t w, h, format, usage;
    if (needNewBuffer(bufIdx, &amp;w, &amp;h, &amp;format, &amp;usage)) {
        err = getBufferLocked(bufIdx, w, h, format, usage);
        if (err == NO_ERROR) {
            // reset the width/height with the what we get from the buffer
            const sp&lt;GraphicBuffer&gt;&amp; backBuffer(mBuffers[bufIdx]);
            mWidth  = uint32_t(backBuffer-&gt;width);
            mHeight = uint32_t(backBuffer-&gt;height);
        }
    }

    // if we still don't have a buffer here, we probably ran out of memory
    const sp&lt;GraphicBuffer&gt;&amp; backBuffer(mBuffers[bufIdx]);
    if (!err &amp;&amp; backBuffer==0) {
        err = NO_MEMORY;
    }

    if (err == NO_ERROR) {
        mDirtyRegion.set(backBuffer-&gt;width, backBuffer-&gt;height);
        *buffer = backBuffer.get();
    } else {
        mSharedBufferClient-&gt;undoDequeue(bufIdx);
    }

    return err;
}
</pre>

<h2 id="toc_1.3">释放显示缓冲区</h2>
<ul>
<li>
画图完成后，要想把Surface的内容显示到屏幕上，需要把Canvas中绑定的缓冲区释放，并且把该缓冲区从变成可投递(因为默认只有两个 buffer，所以实际上就是变成了frontBuffer)，SurfaceFlinger的工作线程会在适当的刷新时刻，把系统中所有的 frontBuffer混合在一起，然后通过OpenGL刷新到屏幕上。
</li>
<ul>
<li>
Java层Surface调用unlockCanvasAndPost
</li>
<li>
native代码：Surface_unlockCanvasAndPost
</li>
<li>
native代码利用Java层传入的SurfaceControl对象，通过getSurface()取得C++层的Surface对象
</li>
<li>
绑定一个空的bitmap到Canvas中
</li>
<li>
调用Surface(C++层)的unlockAndPost方法
</li>
<ul>
<li>
调用GraphicBuffer的unlock()，解锁缓冲区
</li>
<li>
在queueBuffer()调用了SharedBufferClient的queue()，把该缓冲区更新为可投递状态
</li>
</ul>
</ul>
<li>
SurfaceFlinger的渲染线程looper在条件信号上等待事件触发，如果需要更新，则会通过Framebuffer驱动做更新动作。
</li>
</ul>

<p>
<a href="pic/free_surface.png"><img src="pic/free_surface.png" /></a>
</p>

<h3 id="toc_1.3.1">unlockCanvasAndPost(Java层)</h3>
<pre class="brush:java">
public native void unlockCanvasAndPost(Canvas canvas);
</pre>

<h3 id="toc_1.3.2">Surface_unlockCanvasAndPost(JNI)</h3>
<pre class="brush:c++">
static void Surface_unlockCanvasAndPost(
        JNIEnv* env, jobject clazz, jobject argCanvas)
{
    jobject canvas = env-&gt;GetObjectField(clazz, so.canvas);
    ...... 
    
    const sp&lt;Surface&gt;&amp; surface(getSurface(env, clazz));
    if (!Surface::isValid(surface))
        return;

    // 从Java层获取Canvas对象并转换成SkCanvas
    SkCanvas* nativeCanvas = (SkCanvas*)env-&gt;GetIntField(canvas, no.native_canvas);
    int saveCount = env-&gt;GetIntField(clazz, so.saveCount);
    nativeCanvas-&gt;restoreToCount(saveCount);
    nativeCanvas-&gt;setBitmapDevice(SkBitmap());
    env-&gt;SetIntField(clazz, so.saveCount, 0);

    // 解锁缓冲区并通过投递动作更新状态
    status_t err = surface-&gt;unlockAndPost();
    if (err &lt; 0) {
    }
}
</pre>

<h3 id="toc_1.3.3">Surface::unlockAndPost(C++层)</h3>
<pre class="brush:c++">
status_t Surface::unlockAndPost() 
{
    if (mLockedBuffer == 0) {
        return INVALID_OPERATION;
    }

    status_t err = mLockedBuffer-&gt;unlock();
    
    err = queueBuffer(mLockedBuffer.get());

    mPostedBuffer = mLockedBuffer;
    mLockedBuffer = 0;
    return err;
}
</pre>

<h3 id="toc_1.3.4">Surface::queueBuffer(C++层)</h3>
<pre class="brush:c++">
int Surface::queueBuffer(android_native_buffer_t* buffer)
{
    status_t err = validate();
    if (err != NO_ERROR)
        return err;

    if (mSwapRectangle.isValid()) {
        mDirtyRegion.set(mSwapRectangle);
    }
    
    int32_t bufIdx = getBufferIndex(GraphicBuffer::getSelf(buffer));

    ......
    mSharedBufferClient-&gt;setTransform(bufIdx, mNextBufferTransform);
    mSharedBufferClient-&gt;setCrop(bufIdx, mNextBufferCrop);
    mSharedBufferClient-&gt;setDirtyRegion(bufIdx, mDirtyRegion);
    // 更新缓冲区
    err = mSharedBufferClient-&gt;queue(bufIdx);

    if (err == NO_ERROR) {
        // 通过Binder调用SurfaceFlinger.signal方法
        mClient.signalServer();
    }
    return err;
}
</pre>
<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

<!--<script type="text/javascript">-->
<!--var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");-->
<!--document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));-->
<!--</script>-->
<!--<script type="text/javascript">-->
<!--try {-->
<!--var pageTracker = _gat._getTracker("UA-15922433-1");-->
<!--pageTracker._trackPageview();-->
<!--} catch(err) {}-->
<!--</script>-->

</body>
</html>
