<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>驱动适配层</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <link rel="Stylesheet" type="text/css" href="../css_style/style_zenki.css">

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>

<!-- wrap the vimwiki html -->

<h1 id="toc_1">驱动适配层</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">驱动适配层</a>
<ul>
<li><a href="#toc_1.1">相关文件</a>
<li><a href="#toc_1.2">适配层模型</a>
<li><a href="#toc_1.3">mediaserver的范例</a>
<ul>
<li><a href="#toc_1.3.1">Binder初始化阶段</a>
<li><a href="#toc_1.3.2">向Binder驱动注册服务</a>
<li><a href="#toc_1.3.3">Binder消息处理阶段</a>
</ul>
<li><a href="#toc_1.4">要点总结</a>
<li><a href="#toc_1.5">mediaserver.cpp</a>
<ul>
<li><a href="#toc_1.5.1">main</a>
</ul>
<li><a href="#toc_1.6">CameraService.cpp</a>
<ul>
<li><a href="#toc_1.6.1">CameraService::instantiate</a>
</ul>
<li><a href="#toc_1.7">ProcessState.cpp</a>
<ul>
<li><a href="#toc_1.7.1">ProcessState::ProcessState</a>
<li><a href="#toc_1.7.2">ProcessState::self</a>
<li><a href="#toc_1.7.3">open_driver</a>
<li><a href="#toc_1.7.4">startThreadPool</a>
<li><a href="#toc_1.7.5">spawnPooledThread</a>
<li><a href="#toc_1.7.6">getContextObject 方法1</a>
<li><a href="#toc_1.7.7">getContextObject 方法2</a>
<li><a href="#toc_1.7.8">getStrongProxyForHandle</a>
<li><a href="#toc_1.7.9">ProcessState::getWeakProxyForHandle</a>
</ul>
<li><a href="#toc_1.8">PoolThread类</a>
<li><a href="#toc_1.9">IServiceManager.cpp</a>
<ul>
<li><a href="#toc_1.9.1">defaultServiceManager</a>
</ul>
<li><a href="#toc_1.10">IPCThreadState.cpp</a>
<ul>
<li><a href="#toc_1.10.1">IPCThreadState::IPCThreadState</a>
<li><a href="#toc_1.10.2">IPCThreadState::self</a>
<li><a href="#toc_1.10.3">joinThreadPool</a>
<li><a href="#toc_1.10.4">talkWithDriver</a>
<li><a href="#toc_1.10.5">transact</a>
<li><a href="#toc_1.10.6">writeTransactionData</a>
<li><a href="#toc_1.10.7">waitForResponse</a>
<li><a href="#toc_1.10.8">executeCommand</a>
<li><a href="#toc_1.10.9">incStrongHandle</a>
<li><a href="#toc_1.10.10">decStrongHandle</a>
<li><a href="#toc_1.10.11">incWeakHandle</a>
<li><a href="#toc_1.10.12">decWeakHandle</a>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">相关文件</h2>
<pre class="brush:text">
frameworks/base/include/utils/IPCThreadState.h
frameworks/base/libs/utils/IPCThreadState.cpp
frameworks/base/include/utils/ProcessState.h
frameworks/base/include/utils/ProcessState.cpp
frameworks/base/media/mediaserver/main_mediaserver.cpp
</pre>

<h2 id="toc_1.2">适配层模型</h2>
<p>
<img src="http:pic/IPCThreadState.jpg" />
</p>

<p>
<strong>适配层本质上实现了如何与驱动通信的方法，ProcessState用来打开Binder，所有数据传递操作放在IPCThreadState处理。</strong>
</p>

<h2 id="toc_1.3">mediaserver的范例</h2>
<ul>
<li>
我们以mediaserver的源码作为例子，讲述适配层在Binder通信中的作用，首先从mediaserver.cpp的main方法开始。

</ul>

<h3 id="toc_1.3.1">Binder初始化阶段</h3>

<ol>
<li>
ProcessState::self()用来初始化ProcessState的单例对象，其构造方法会调用<code>open_driver()</code>方法负责打开Binder即<code>/dev/binder</code>设备，映射1M的内存，为进程间通信做准备。

<li>
接下来<code>defaultServiceManager()</code>会获取ServiceManager的Binder引用，为以后在ServiceManager中注册服务做准备。(参见<a href="守护进程的驱动者.html">守护进程的驱动者</a>)

</ol>

<h3 id="toc_1.3.2">向Binder驱动注册服务</h3>

<ol>
<li>
为每个服务做初始化，分别是调用各自的<code>::instantiate()</code>，可参考CameraService.cpp的实现。

<li>
在初始化过程中会向Binder服务注册各自服务的Binder对象，调用<code>addService()</code>。使用IServiceManager来实现，参见<a href="守护进程的驱动者.html">守护进程的驱动者</a>

</ol>

<h3 id="toc_1.3.3">Binder消息处理阶段</h3>

<ol>
<li>
通过<code>ProcessState::startThreadPool()</code>方法和<code>ProcessState::spawnPooledThread(bool isMain)</code>方法开启线程。

<li>
<code>IPCThreadState.joinThreadPool()</code>方法建立消息处理循环，它会调用PoolThread的threadLoop()方法为线程执行的入口方法。

<li>
当client呼叫<code>BpBinder</code>的IBinder的<code>transact()</code>方法，该transact()则呼叫<code>IPCThreadState</code>的<code>transact()</code>方法。

<li>
transact()会调用<code>talkWithDriver()</code>，该方法会用到ProcessState初始化时打开的文件描述符和Binder驱动交互，该方法有两个职责：

<ul>
<li>
接收来自驱动的请求(即代理端请求)。发送和接收的数据都被写入binder_write_read数据结构，最终通过<code>ioctl()</code>方法调用与驱动交互。

<li>
必要时发送结果给驱动(回复代理端请求);

</ul>
<li>
处理请求的方法是<code>executeCommand()</code>，BR_TRANSACTION响应会读取请求数据，将Binder地址换成BBinder，并调用它的<code>transact()</code>方法处理请求，同时BBinder的继承类会调用它的<code>onTransact()</code>方法。当处理请求后会将结果写入reply并返回。

<li>
回到executeCommand()方法，如果当前处于同步模式，则会调用<code>sendReply()</code>方法，它先将结果打包进binder_transaction_data，再调用<code>waitForResponse()</code>提交给驱动。

<li>
线程不断循环重复以上数据交换的流程直到退出循环。

</ol>

<h2 id="toc_1.4">要点总结</h2>
<ul>
<li>
ProcessState是对进程的抽象类，该类保证了在一个进程中对于设备节点/dev/binder只会被打开一次，它使用单例模式，对象通过ProcessState::self()获取。

<li>
IPCThreadState是对处理线程的抽象类，该类保证了与驱动交互的行为只会在一个线程中被执行，它使用单例模式，对象通过IPCThreadState::self()获取。该类会使用ProcessState对象来取得驱动设备描述符。

<li>
IPCThreadState的实现遵循了Binder协议，它将传输数据封装成binder_transaction_data结构。请求和应答都使用Parcel作为传输介质。(参见<a href="Parcel传输介质.html">Parcel传输介质</a>)

</ul>

<h2 id="toc_1.5">mediaserver.cpp</h2>
<h3 id="toc_1.5.1">main</h3>
<pre class="brush:c++">
int main(int argc, char** argv)
{
    sp&lt;ProcessState&gt; proc(ProcessState::self());
    sp&lt;IServiceManager&gt; sm = defaultServiceManager();
    AudioFlinger::instantiate();
    MediaPlayerService::instantiate();
    CameraService::instantiate();
    AudioPolicyService::instantiate();
    ProcessState::self()-&gt;startThreadPool();
    IPCThreadState::self()-&gt;joinThreadPool();
}
</pre>

<h2 id="toc_1.6">CameraService.cpp</h2>
<h3 id="toc_1.6.1">CameraService::instantiate</h3>
<pre class="brush:c++">
void CameraService::instantiate() {
    defaultServiceManager()-&gt;addService(
            String16("media.camera"), new CameraService());
}
</pre>

<h2 id="toc_1.7">ProcessState.cpp</h2>
<h3 id="toc_1.7.1">ProcessState::ProcessState</h3>
<ul>
<li>
该构造方法做打开驱动的初始化，并映射内存，初始化时调用<code>open_driver</code>方法。

</ul>

<pre class="brush:c++">
ProcessState::ProcessState()
    : mDriverFD(open_driver())
    , mVMStart(MAP_FAILED)
    , mManagesContexts(false)
    , mBinderContextCheckFunc(NULL)
    , mBinderContextUserData(NULL)
    , mThreadPoolStarted(false)
    , mThreadPoolSeq(1)
{
    if (mDriverFD &gt;= 0) {
        // XXX Ideally, there should be a specific define for whether we
        // have mmap (or whether we could possibly have the kernel module
        // availabla).
#if !defined(HAVE_WIN32_IPC)
        // mmap the binder, providing a chunk of virtual address space to receive transactions.
        mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);
        if (mVMStart == MAP_FAILED) {
            // *sigh*
            close(mDriverFD);
            mDriverFD = -1;
        }
#else
        mDriverFD = -1;
#endif
    }
    if (mDriverFD &lt; 0) {
        // Need to run without the driver, starting our own thread pool.
    }
}
</pre>

<h3 id="toc_1.7.2">ProcessState::self</h3>
<ul>
<li>
单例模式的类，用来构造ProcessState对象。

</ul>

<pre class="brush:c++">
sp&lt;ProcessState&gt; ProcessState::self()
{
    if (gProcess != NULL) return gProcess;
    
    AutoMutex _l(gProcessMutex);
    if (gProcess == NULL) gProcess = new ProcessState;
    return gProcess;
}
</pre>

<h3 id="toc_1.7.3">open_driver</h3>
<ul>
<li>
打开驱动设备，返回描述符。

</ul>
 
<pre class="brush:c++">
// 全局变量gSingleProcess初始为false
static int open_driver()
{
    if (gSingleProcess) {
        return -1;
    }

    int fd = open("/dev/binder", O_RDWR);
    if (fd &gt;= 0) {
        ...... 
    } else {
    }
    return fd;
}
</pre>

<h3 id="toc_1.7.4">startThreadPool</h3>
<pre class="brush:c++">
void ProcessState::startThreadPool()
{
    AutoMutex _l(mLock);
    if (!mThreadPoolStarted) {
        mThreadPoolStarted = true;
        spawnPooledThread(true);
    }
}
</pre>

<h3 id="toc_1.7.5">spawnPooledThread</h3>
<pre class="brush:c++">
void ProcessState::spawnPooledThread(bool isMain)
{
    if (mThreadPoolStarted) {
        int32_t s = android_atomic_add(1, &amp;mThreadPoolSeq);
        char buf[32];
        sprintf(buf, "Binder Thread #%d", s);
        sp&lt;Thread&gt; t = new PoolThread(isMain);
        t-&gt;run(buf);
    }
}
</pre>

<h3 id="toc_1.7.6">getContextObject 方法1</h3>
<pre class="brush:c++">
sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; caller)
{
    if (supportsProcesses()) {
        // 根据0句柄查找ServiceManager
        return getStrongProxyForHandle(0);
    } else {
        return getContextObject(String16("default"), caller);
    }
}
</pre>

<h3 id="toc_1.7.7">getContextObject 方法2</h3>
<pre class="brush:c++">
sp&lt;IBinder&gt; ProcessState::getContextObject(const String16&amp; name, const sp&lt;IBinder&gt;&amp; caller)
{
    mLock.lock();
    sp&lt;IBinder&gt; object(
        mContexts.indexOfKey(name) &gt;= 0 ? mContexts.valueFor(name) : NULL);
    mLock.unlock();
    
    if (object != NULL) return object;

    // Don't attempt to retrieve contexts if we manage them
    if (mManagesContexts) {
        return NULL;
    }
    
    // 取得IPC通信渠道
    IPCThreadState* ipc = IPCThreadState::self();
    {
        // 封装Binder的请求数据
        Parcel data, reply;
        data.writeString16(name);
        data.writeStrongBinder(caller);
        // 向0号引用的ServiceManager发送请求
        status_t result = ipc-&gt;transact(0 /*magic*/, 0, data, &amp;reply, 0);
        if (result == NO_ERROR) {
            object = reply.readStrongBinder();
        }
    }
    
    ipc-&gt;flushCommands();
    
    if (object != NULL) setContextObject(object, name);
    return object;
}
</pre>

<h3 id="toc_1.7.8">getStrongProxyForHandle</h3>
<pre class="brush:c++">
sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)
{
    sp&lt;IBinder&gt; result;

    AutoMutex _l(mLock);

    handle_entry* e = lookupHandleLocked(handle);

    if (e != NULL) {
        // We need to create a new BpBinder if there isn't currently one, OR we
        // are unable to acquire a weak reference on this current one.  See comment
        // in getWeakProxyForHandle() for more info about this.
        IBinder* b = e-&gt;binder;
        if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) {
            b = new BpBinder(handle); 
            e-&gt;binder = b;
            if (b) e-&gt;refs = b-&gt;getWeakRefs();
            result = b;
        } else {
            // This little bit of nastyness is to allow us to add a primary
            // reference to the remote proxy when this team doesn't have one
            // but another team is sending the handle to us.
            result.force_set(b);
            e-&gt;refs-&gt;decWeak(this);
        }
    }

    return result;
}
</pre>

<h3 id="toc_1.7.9">ProcessState::getWeakProxyForHandle</h3>
<pre class="brush:c++">
wp&lt;IBinder&gt; ProcessState::getWeakProxyForHandle(int32_t handle)
{
    wp&lt;IBinder&gt; result;

    AutoMutex _l(mLock);

    handle_entry* e = lookupHandleLocked(handle);

    if (e != NULL) {        
        // We need to create a new BpBinder if there isn't currently one, OR we
        // are unable to acquire a weak reference on this current one.  The
        // attemptIncWeak() is safe because we know the BpBinder destructor will always
        // call expungeHandle(), which acquires the same lock we are holding now.
        // We need to do this because there is a race condition between someone
        // releasing a reference on this BpBinder, and a new reference on its handle
        // arriving from the driver.
        IBinder* b = e-&gt;binder;
        if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) {
            b = new BpBinder(handle);
            result = b;
            e-&gt;binder = b;
            if (b) e-&gt;refs = b-&gt;getWeakRefs();
        } else {
            result = b;
            e-&gt;refs-&gt;decWeak(this);
        }
    }

    return result;
}
</pre>

<h2 id="toc_1.8">PoolThread类</h2>
<pre class="brush:c++">
class PoolThread : public Thread
{
public:
    PoolThread(bool isMain)
        : mIsMain(isMain)
    {
    }
    
protected:
    virtual bool threadLoop()
    {
        // 通知驱动进入Loop模式，线程的入口函数
        IPCThreadState::self()-&gt;joinThreadPool(mIsMain);
        return false;
    }
    
    const bool mIsMain;
};
</pre>

<h2 id="toc_1.9">IServiceManager.cpp</h2>
<h3 id="toc_1.9.1">defaultServiceManager</h3>
<ul>
<li>
该方法返回ServiceManager的Binder引用。

</ul>

<pre class="brush:c++">
if (gDefaultServiceManager != NULL) return gDefaultServiceManager;
    
    {
        AutoMutex _l(gDefaultServiceManagerLock);
        if (gDefaultServiceManager == NULL) {
            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(
                ProcessState::self()-&gt;getContextObject(NULL));
        }
    }
    
    return gDefaultServiceManager;
</pre>

<h2 id="toc_1.10">IPCThreadState.cpp</h2>
<h3 id="toc_1.10.1">IPCThreadState::IPCThreadState</h3>
<pre class="brush:c++">
IPCThreadState::IPCThreadState()
    : mProcess(ProcessState::self())
{
    pthread_setspecific(gTLS, this);
        clearCaller();
    // 初始化接收和返回数据的Parcel对象
    mIn.setDataCapacity(256);
    mOut.setDataCapacity(256);
}
</pre>

<h3 id="toc_1.10.2">IPCThreadState::self</h3>
<pre class="brush:c++">
IPCThreadState* IPCThreadState::self()
{
    if (gHaveTLS) {
restart:
        const pthread_key_t k = gTLS;
        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k);
        if (st) return st;
        // 创建IPCThreadState对象
        return new IPCThreadState;
    }
    
    if (gShutdown) return NULL;
    
    pthread_mutex_lock(&amp;gTLSMutex);
    if (!gHaveTLS) {
        if (pthread_key_create(&amp;gTLS, threadDestructor) != 0) {
            pthread_mutex_unlock(&amp;gTLSMutex);
            return NULL;
        }
        gHaveTLS = true;
    }
    pthread_mutex_unlock(&amp;gTLSMutex);
    goto restart;
}
</pre>

<h3 id="toc_1.10.3">joinThreadPool</h3>
<pre class="brush:c++">
void IPCThreadState::joinThreadPool(bool isMain)
{
    // 通知驱动进入BC_ENTER_LOOPER模式
    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);
    
    // 进入消息接收循环
    status_t result;
    do {
        int32_t cmd;
        
        // When we've cleared the incoming command queue, process any pending derefs
        if (mIn.dataPosition() &gt;= mIn.dataSize()) {
            size_t numPending = mPendingWeakDerefs.size();
            if (numPending &gt; 0) {
                for (size_t i = 0; i &lt; numPending; i++) {
                    RefBase::weakref_type* refs = mPendingWeakDerefs[i];
                    refs-&gt;decWeak(mProcess.get());
                }
                mPendingWeakDerefs.clear();
            }

            numPending = mPendingStrongDerefs.size();
            if (numPending &gt; 0) {
                for (size_t i = 0; i &lt; numPending; i++) {
                    BBinder* obj = mPendingStrongDerefs[i];
                    obj-&gt;decStrong(mProcess.get());
                }
                mPendingStrongDerefs.clear();
            }
        }

        // 与Binder驱动进行交互
        result = talkWithDriver();
        if (result &gt;= NO_ERROR) {
            size_t IN = mIn.dataAvail();
            if (IN &lt; sizeof(int32_t)) continue;
            cmd = mIn.readInt32();

            // 根据驱动的返回结果做出相应的动作
            result = executeCommand(cmd);
        }
        
        // After executing the command, ensure that the thread is returned to the
        // default cgroup and priority before rejoining the pool.  This is a failsafe
        // in case the command implementation failed to properly restore the thread's
        // scheduling parameters upon completion.
        int my_id;
#ifdef HAVE_GETTID
        my_id = gettid();
#else
        my_id = getpid();
#endif
        if (!set_sched_policy(my_id, SP_FOREGROUND)) {
            // success; reset the priority as well
            setpriority(PRIO_PROCESS, my_id, ANDROID_PRIORITY_NORMAL);
        }

        // Let this thread exit the thread pool if it is no longer
        // needed and it is not the main process thread.
        if(result == TIMED_OUT &amp;&amp; !isMain) {
            break;
        }
    } while (result != -ECONNREFUSED &amp;&amp; result != -EBADF);

    
    mOut.writeInt32(BC_EXIT_LOOPER);
    talkWithDriver(false);
}
</pre>

<h3 id="toc_1.10.4">talkWithDriver</h3>
<ul>
<li>
该方法将mIn、mOut数据写入binder_write_read结构，并通过ioctl与驱动交互。参见<a href="Binder通信协议.html">Binder通信协议</a>。

</ul>

<pre class="brush:c++">
status_t IPCThreadState::talkWithDriver(bool doReceive)
{
    // Binder驱动ioctl需要binder_write_read结构作为参数
    binder_write_read bwr;
    
    // 从mIn.dataSize判断是否需要读驱动的数据
    const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize();
    
    // We don't want to write anything if we are still reading
    // from data left in the input buffer and the caller
    // has requested to read the next data.
    const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0;
    
    bwr.write_size = outAvail;
    bwr.write_buffer = (long unsigned int)mOut.data();

    // This is what we'll read.
    if (doReceive &amp;&amp; needRead) {
        bwr.read_size = mIn.dataCapacity();
        bwr.read_buffer = (long unsigned int)mIn.data();
    } else {
        bwr.read_size = 0;
    }
    
    // Return immediately if there is nothing to do.
    if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR;
    
    bwr.write_consumed = 0;
    bwr.read_consumed = 0;
    status_t err;
    do {
#if defined(HAVE_ANDROID_OS)
        // 将BINDER_WRITE_READ结构数据写入驱动
        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)
            err = NO_ERROR;
        else
            err = -errno;
#else
        err = INVALID_OPERATION;
#endif
    } while (err == -EINTR);
    
    if (err &gt;= NO_ERROR) {
        if (bwr.write_consumed &gt; 0) {
            if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize())
                mOut.remove(0, bwr.write_consumed);
            else
                mOut.setDataSize(0);
        }
        if (bwr.read_consumed &gt; 0) {
            mIn.setDataSize(bwr.read_consumed);
            mIn.setDataPosition(0);
        }
        
        return NO_ERROR;
    }
    
    return err;
}
</pre>

<h3 id="toc_1.10.5">transact</h3>
<ul>
<li>
该方法首先将数据封装成binder_transaction_data结构，再判断异步或同步数据处理。

</ul>

<pre class="brush:c++">
status_t IPCThreadState::transact(int32_t handle,
                                  uint32_t code, const Parcel&amp; data,
                                  Parcel* reply, uint32_t flags)
{
    status_t err = data.errorCheck();

    flags |= TF_ACCEPT_FDS;

    if (err == NO_ERROR) {
        // 将数据封装成binder_transaction_data数据包结构
        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);
    }
    
    if (err != NO_ERROR) {
        if (reply) reply-&gt;setError(err);
        return (mLastError = err);
    }
    
    // TF_ONE_WAY表示异步处理
    if ((flags &amp; TF_ONE_WAY) == 0) {
        // 同步模式，则等待驱动应答
        if (reply) {
            err = waitForResponse(reply);
        } else {
            Parcel fakeReply;
            err = waitForResponse(&amp;fakeReply);
        }
    } else {
        // 异步模式，则传递NULL作为参数
        err = waitForResponse(NULL, NULL);
    }
    
    return err;
}
</pre>

<h3 id="toc_1.10.6">writeTransactionData</h3>
<ul>
<li>
首先将数据封装进binder_transaction_data结构中，再将该结构的数据写入mOut，下次与驱动交互时再将该数据写入驱动。

</ul>

<pre class="brush:c++">
status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,
    int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)
{
    binder_transaction_data tr;

    tr.target.handle = handle;
    tr.code = code;
    tr.flags = binderFlags;
    
    const status_t err = data.errorCheck();
    if (err == NO_ERROR) {
        tr.data_size = data.ipcDataSize();
        tr.data.ptr.buffer = data.ipcData();
        tr.offsets_size = data.ipcObjectsCount()*sizeof(size_t);
        tr.data.ptr.offsets = data.ipcObjects();
    } else if (statusBuffer) {
        tr.flags |= TF_STATUS_CODE;
        *statusBuffer = err;
        tr.data_size = sizeof(status_t);
        tr.data.ptr.buffer = statusBuffer;
        tr.offsets_size = 0;
        tr.data.ptr.offsets = NULL;
    } else {
        return (mLastError = err);
    }
    
    mOut.writeInt32(cmd);
    mOut.write(&amp;tr, sizeof(tr));
    
    return NO_ERROR;
}
</pre>

<h3 id="toc_1.10.7">waitForResponse</h3>
<pre class="brush:c++">
status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)
{
    int32_t cmd;
    int32_t err;

    while (1) {
        // 调用了talkWithDriver()与驱动交互
        if ((err=talkWithDriver()) &lt; NO_ERROR) break;
        err = mIn.errorCheck();
        if (err &lt; NO_ERROR) break;
        if (mIn.dataAvail() == 0) continue;
        
        cmd = mIn.readInt32();
        
        switch (cmd) {
        case BR_TRANSACTION_COMPLETE:
            if (!reply &amp;&amp; !acquireResult) goto finish;
            break;
        
        case BR_DEAD_REPLY:
            err = DEAD_OBJECT;
            goto finish;

        case BR_FAILED_REPLY:
            err = FAILED_TRANSACTION;
            goto finish;
        
        case BR_ACQUIRE_RESULT:
            {
                const int32_t result = mIn.readInt32();
                if (!acquireResult) continue;
                *acquireResult = result ? NO_ERROR : INVALID_OPERATION;
            }
            goto finish;
        
        case BR_REPLY:
            {
                binder_transaction_data tr;
                err = mIn.read(&amp;tr, sizeof(tr));
                if (err != NO_ERROR) goto finish;

                if (reply) {
                    if ((tr.flags &amp; TF_STATUS_CODE) == 0) {
                        reply-&gt;ipcSetDataReference(
                            reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                            tr.data_size,
                            reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                            tr.offsets_size/sizeof(size_t),
                            freeBuffer, this);
                    } else {
                        err = *static_cast&lt;const status_t*&gt;(tr.data.ptr.buffer);
                        freeBuffer(NULL,
                            reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                            tr.data_size,
                            reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                            tr.offsets_size/sizeof(size_t), this);
                    }
                } else {
                    freeBuffer(NULL,
                        reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                        tr.data_size,
                        reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                        tr.offsets_size/sizeof(size_t), this);
                    continue;
                }
            }
            goto finish;

        default:
            err = executeCommand(cmd);
            if (err != NO_ERROR) goto finish;
            break;
        }
    }

finish:
    if (err != NO_ERROR) {
        if (acquireResult) *acquireResult = err;
        if (reply) reply-&gt;setError(err);
        mLastError = err;
    }
    
    return err;
}
</pre>

<h3 id="toc_1.10.8">executeCommand</h3>
<ul>
<li>
该方法执行具体的Binder相关命令操作。

<li>
重点看BR_TRANSACTION部分，该类将读出的Binder数据转换成<code>BBinder</code>，并调用它的transact()方法。最终将调用BBinder的继承类Bn*Service的<code>onTransact()</code>方法。

</ul>

<pre class="brush:c++">
status_t IPCThreadState::executeCommand(int32_t cmd)
{
    BBinder* obj;
    RefBase::weakref_type* refs;
    status_t result = NO_ERROR;
    
    switch (cmd) {
    case BR_ERROR:
        result = mIn.readInt32();
        break;
        
    case BR_OK:
        break;
        
    case BR_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readInt32();
        obj = (BBinder*)mIn.readInt32();
        obj-&gt;incStrong(mProcess.get());
        
        mOut.writeInt32(BC_ACQUIRE_DONE);
        mOut.writeInt32((int32_t)refs);
        mOut.writeInt32((int32_t)obj);
        break;
        
    case BR_RELEASE:
        refs = (RefBase::weakref_type*)mIn.readInt32();
        obj = (BBinder*)mIn.readInt32();
        
        mPendingStrongDerefs.push(obj);
        break;
        
    case BR_INCREFS:
        refs = (RefBase::weakref_type*)mIn.readInt32();
        obj = (BBinder*)mIn.readInt32();
        refs-&gt;incWeak(mProcess.get());
        mOut.writeInt32(BC_INCREFS_DONE);
        mOut.writeInt32((int32_t)refs);
        mOut.writeInt32((int32_t)obj);
        break;
        
    case BR_DECREFS:
        refs = (RefBase::weakref_type*)mIn.readInt32();
        obj = (BBinder*)mIn.readInt32();
        mPendingWeakDerefs.push(refs);
        break;
        
    case BR_ATTEMPT_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readInt32();
        obj = (BBinder*)mIn.readInt32();
         
        {
            const bool success = refs-&gt;attemptIncStrong(mProcess.get());
            
            mOut.writeInt32(BC_ACQUIRE_RESULT);
            mOut.writeInt32((int32_t)success);
        }
        break;
    
    case BR_TRANSACTION:
        {
            binder_transaction_data tr;
            result = mIn.read(&amp;tr, sizeof(tr));
            if (result != NO_ERROR) break;
            
            Parcel buffer;
            buffer.ipcSetDataReference(
                reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                tr.data_size,
                reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                tr.offsets_size/sizeof(size_t), freeBuffer, this);
            
            const pid_t origPid = mCallingPid;
            const uid_t origUid = mCallingUid;
            
            mCallingPid = tr.sender_pid;
            mCallingUid = tr.sender_euid;
            
            Parcel reply;
            if (tr.target.ptr) {
                // 将Binder的数据转换成BBinder，并调用它的transact方法，Bn*类即是继承于BBinder
                sp&lt;BBinder&gt; b((BBinder*)tr.cookie);
                const status_t error = b-&gt;transact(tr.code, buffer, &amp;reply, 0);
                if (error &lt; NO_ERROR) reply.setError(error);
                
            } else {
                const status_t error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, 0);
                if (error &lt; NO_ERROR) reply.setError(error);
            }
            
            // 如果是同步模式，则返回结果
            if ((tr.flags &amp; TF_ONE_WAY) == 0) {
                sendReply(reply, 0);
            } else {
            }
            
            mCallingPid = origPid;
            mCallingUid = origUid;
        }
        break;
    
    case BR_DEAD_BINDER:
        {
            BpBinder *proxy = (BpBinder*)mIn.readInt32();
            proxy-&gt;sendObituary();
            mOut.writeInt32(BC_DEAD_BINDER_DONE);
            mOut.writeInt32((int32_t)proxy);
        } break;
        
    case BR_CLEAR_DEATH_NOTIFICATION_DONE:
        {
            BpBinder *proxy = (BpBinder*)mIn.readInt32();
            proxy-&gt;getWeakRefs()-&gt;decWeak(proxy);
        } break;
        
    case BR_FINISHED:
        result = TIMED_OUT;
        break;
        
    case BR_NOOP:
        break;
        
    case BR_SPAWN_LOOPER:
        mProcess-&gt;spawnPooledThread(false);
        break;
        
    default:
        printf("*** BAD COMMAND %d received from Binder driver\n", cmd);
        result = UNKNOWN_ERROR;
        break;
    }

    if (result != NO_ERROR) {
        mLastError = result;
    }
    
    return result;
}
</pre>

<h3 id="toc_1.10.9">incStrongHandle</h3>
<pre class="brush:c++">
void IPCThreadState::incStrongHandle(int32_t handle)
{
    mOut.writeInt32(BC_ACQUIRE);
    mOut.writeInt32(handle);
}
</pre>

<h3 id="toc_1.10.10">decStrongHandle</h3>
<pre class="brush:c++">
void IPCThreadState::decStrongHandle(int32_t handle)
{
    mOut.writeInt32(BC_RELEASE);
    mOut.writeInt32(handle);
}
</pre>

<h3 id="toc_1.10.11">incWeakHandle</h3>
<pre class="brush:c++">
void IPCThreadState::incWeakHandle(int32_t handle)
{
    mOut.writeInt32(BC_INCREFS);
    mOut.writeInt32(handle);
}
</pre>

<h3 id="toc_1.10.12">decWeakHandle</h3>
<pre class="brush:c++">
void IPCThreadState::decWeakHandle(int32_t handle)
{
    mOut.writeInt32(BC_DECREFS);
    mOut.writeInt32(handle);
}
</pre>


<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

</body>
</html>
