<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>init进程参考代码</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
	<link type="text/css" rel="stylesheet" href="css_style/style_zenki.css"/>

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>


<h1 id="toc_1">init进程参考代码</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">init进程参考代码</a></li>
<ul>
<li><a href="#toc_1.1">init.c</a></li>
<ul>
<li><a href="#toc_1.1.1">main</a></li>
<li><a href="#toc_1.1.2">import_kernel_cmdline</a></li>
<li><a href="#toc_1.1.3">import_kernel_nv</a></li>
</ul>
<li><a href="#toc_1.2">util.c</a></li>
<ul>
<li><a href="#toc_1.2.1">open_devnull_stdio</a></li>
<li><a href="#toc_1.2.2">log_init</a></li>
<li><a href="#toc_1.2.3">get_hardware_name</a></li>
</ul>
<li><a href="#toc_1.3">init_parser.c</a></li>
<ul>
<li><a href="#toc_1.3.1">struct parse_state</a></li>
<li><a href="#toc_1.3.2">init_parse_config_file</a></li>
<li><a href="#toc_1.3.3">parse_config</a></li>
<li><a href="#toc_1.3.4">parse_new_section</a></li>
<li><a href="#toc_1.3.5">parse_line_service</a></li>
<li><a href="#toc_1.3.6">parse_line_action</a></li>
</ul>
<li><a href="#toc_1.4">devices.c</a></li>
<ul>
<li><a href="#toc_1.4.1">device_init</a></li>
<li><a href="#toc_1.4.2">do_coldboot</a></li>
<li><a href="#toc_1.4.3">coldboot</a></li>
</ul>
<li><a href="#toc_1.5">property_service.c</a></li>
<ul>
<li><a href="#toc_1.5.1">property_init</a></li>
<li><a href="#toc_1.5.2">start_property_service</a></li>
<li><a href="#toc_1.5.3">handle_property_set_fd</a></li>
</ul>
<li><a href="#toc_1.6">parser.c</a></li>
<ul>
<li><a href="#toc_1.6.1">drain_action_queue</a></li>
<li><a href="#toc_1.6.2">action_for_each_trigger</a></li>
<li><a href="#toc_1.6.3">action_remove_queue_head</a></li>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">init.c</h2>
<h3 id="toc_1.1.1">main</h3>
<pre class="brush:c++">
int main(int argc, char **argv)
{
    int fd_count = 0;
    struct pollfd ufds[4];
    char *tmpdev;
    char* debuggable;
    char tmp[32];
    int property_set_fd_init = 0;
    int signal_fd_init = 0;
    int keychord_fd_init = 0;

    if (!strcmp(basename(argv[0]), "ueventd"))
        return ueventd_main(argc, argv);

    /* clear the umask */
    umask(0);

        /* Get the basic filesystem setup we need put
         * together in the initramdisk on / and then we'll
         * let the rc file figure out the rest.
         */
    mkdir("/dev", 0755);
    mkdir("/proc", 0755);
    mkdir("/sys", 0755);

    mount("tmpfs", "/dev", "tmpfs", 0, "mode=0755");
    mkdir("/dev/pts", 0755);
    mkdir("/dev/socket", 0755);
    mount("devpts", "/dev/pts", "devpts", 0, NULL);
    mount("proc", "/proc", "proc", 0, NULL);
    mount("sysfs", "/sys", "sysfs", 0, NULL);

        /* We must have some place other than / to create the
         * device nodes for kmsg and null, otherwise we won't
         * be able to remount / read-only later on.
         * Now that tmpfs is mounted on /dev, we can actually
         * talk to the outside world.
         */
    open_devnull_stdio();
    log_init();
    
    INFO("reading config file\n");
    init_parse_config_file("/init.rc");

    /* pull the kernel commandline and ramdisk properties file in */
    import_kernel_cmdline(0);

    get_hardware_name(hardware, &amp;revision);
    snprintf(tmp, sizeof(tmp), "/init.%s.rc", hardware);
    init_parse_config_file(tmp);

    action_for_each_trigger("early-init", action_add_queue_tail);

    queue_builtin_action(wait_for_coldboot_done_action, "wait_for_coldboot_done");
    queue_builtin_action(property_init_action, "property_init");
    queue_builtin_action(keychord_init_action, "keychord_init");
    queue_builtin_action(console_init_action, "console_init");
    queue_builtin_action(set_init_properties_action, "set_init_properties");

        /* execute all the boot actions to get us started */
    action_for_each_trigger("init", action_add_queue_tail);
    action_for_each_trigger("early-fs", action_add_queue_tail);
    action_for_each_trigger("fs", action_add_queue_tail);
    action_for_each_trigger("post-fs", action_add_queue_tail);

    queue_builtin_action(property_service_init_action, "property_service_init");
    queue_builtin_action(signal_init_action, "signal_init");
    queue_builtin_action(check_startup_action, "check_startup");

    /* execute all the boot actions to get us started */
    action_for_each_trigger("early-boot", action_add_queue_tail);
    action_for_each_trigger("boot", action_add_queue_tail);

        /* run all property triggers based on current state of the properties */
    queue_builtin_action(queue_property_triggers_action, "queue_propety_triggers");


#if BOOTCHART
    queue_builtin_action(bootchart_init_action, "bootchart_init");
#endif

    for(;;) {
        int nr, i, timeout = -1;

        execute_one_command();
        restart_processes();

        if (!property_set_fd_init &amp;&amp; get_property_set_fd() &gt; 0) {
            ufds[fd_count].fd = get_property_set_fd();
            ufds[fd_count].events = POLLIN;
            ufds[fd_count].revents = 0;
            fd_count++;
            property_set_fd_init = 1;
        }
        if (!signal_fd_init &amp;&amp; get_signal_fd() &gt; 0) {
            ufds[fd_count].fd = get_signal_fd();
            ufds[fd_count].events = POLLIN;
            ufds[fd_count].revents = 0;
            fd_count++;
            signal_fd_init = 1;
        }
        if (!keychord_fd_init &amp;&amp; get_keychord_fd() &gt; 0) {
            ufds[fd_count].fd = get_keychord_fd();
            ufds[fd_count].events = POLLIN;
            ufds[fd_count].revents = 0;
            fd_count++;
            keychord_fd_init = 1;
        }

        if (process_needs_restart) {
            timeout = (process_needs_restart - gettime()) * 1000;
            if (timeout &lt; 0)
                timeout = 0;
        }

        if (!action_queue_empty() || cur_action)
            timeout = 0;

#if BOOTCHART
        if (bootchart_count &gt; 0) {
            if (timeout &lt; 0 || timeout &gt; BOOTCHART_POLLING_MS)
                timeout = BOOTCHART_POLLING_MS;
            if (bootchart_step() &lt; 0 || --bootchart_count == 0) {
                bootchart_finish();
                bootchart_count = 0;
            }
        }
#endif

        nr = poll(ufds, fd_count, timeout);
        if (nr &lt;= 0)
            continue;

        for (i = 0; i &lt; fd_count; i++) {
            if (ufds[i].revents == POLLIN) {
                if (ufds[i].fd == get_property_set_fd())
                    handle_property_set_fd();
                else if (ufds[i].fd == get_keychord_fd())
                    handle_keychord();
                else if (ufds[i].fd == get_signal_fd())
                    handle_signal();
            }
        }
    }

    return 0;
}
</pre>

<h3 id="toc_1.1.2">import_kernel_cmdline</h3>
<pre class="brush:c++">
static void import_kernel_cmdline(int in_qemu)
{
    char cmdline[1024];
    char *ptr;
    int fd;

    fd = open("/proc/cmdline", O_RDONLY);
    if (fd &gt;= 0) {
        int n = read(fd, cmdline, 1023);
        if (n &lt; 0) n = 0;

        /* get rid of trailing newline, it happens */
        if (n &gt; 0 &amp;&amp; cmdline[n-1] == '\n') n--;

        cmdline[n] = 0;
        close(fd);
    } else {
        cmdline[0] = 0;
    }

    ptr = cmdline;
    while (ptr &amp;&amp; *ptr) {
        char *x = strchr(ptr, ' ');
        if (x != 0) *x++ = 0;
        import_kernel_nv(ptr, in_qemu);
        ptr = x;
    }

        /* don't expose the raw commandline to nonpriv processes */
    chmod("/proc/cmdline", 0440);
}
</pre>

<h3 id="toc_1.1.3">import_kernel_nv</h3>
<pre class="brush:c++">
static void import_kernel_nv(char *name, int in_qemu)
{
    char *value = strchr(name, '=');

    if (value == 0) return;
    *value++ = 0;
    if (*name == 0) return;

    if (!in_qemu)
    {
        /* on a real device, white-list the kernel options */
        if (!strcmp(name,"qemu")) {
            strlcpy(qemu, value, sizeof(qemu));
        } else if (!strcmp(name,"androidboot.console")) {
            strlcpy(console, value, sizeof(console));
        } else if (!strcmp(name,"androidboot.mode")) {
            strlcpy(bootmode, value, sizeof(bootmode));
        } else if (!strcmp(name,"androidboot.serialno")) {
            strlcpy(serialno, value, sizeof(serialno));
        } else if (!strcmp(name,"androidboot.baseband")) {
            strlcpy(baseband, value, sizeof(baseband));
        } else if (!strcmp(name,"androidboot.carrier")) {
            strlcpy(carrier, value, sizeof(carrier));
        } else if (!strcmp(name,"androidboot.bootloader")) {
            strlcpy(bootloader, value, sizeof(bootloader));
        } else if (!strcmp(name,"androidboot.hardware")) {
            strlcpy(hardware, value, sizeof(hardware));
        }
    } else {
        /* in the emulator, export any kernel option with the
         * ro.kernel. prefix */
        char  buff[32];
        int   len = snprintf( buff, sizeof(buff), "ro.kernel.%s", name );
        if (len &lt; (int)sizeof(buff)) {
            property_set( buff, value );
        }
    }
}
</pre>

<h2 id="toc_1.2">util.c</h2>
<h3 id="toc_1.2.1">open_devnull_stdio</h3>
<pre class="brush:c++">
void open_devnull_stdio(void)
{
    int fd;
    static const char *name = "/dev/__null__";
    if (mknod(name, S_IFCHR | 0600, (1 &lt;&lt; 8) | 3) == 0) {
        fd = open(name, O_RDWR);
        unlink(name);
        if (fd &gt;= 0) {
            dup2(fd, 0);
            dup2(fd, 1);
            dup2(fd, 2);
            if (fd &gt; 2) {
                close(fd);
            }
            return;
        }
    }

    exit(1);
}
</pre>

<h3 id="toc_1.2.2">log_init</h3>
<pre class="brush:c++">
void log_init(void)
{
    static const char *name = "/dev/__kmsg__";
    if (mknod(name, S_IFCHR | 0600, (1 &lt;&lt; 8) | 11) == 0) {
        log_fd = open(name, O_WRONLY);
        fcntl(log_fd, F_SETFD, FD_CLOEXEC);
        unlink(name);
    }
}
</pre>

<h3 id="toc_1.2.3">get_hardware_name</h3>
<pre class="brush:c++">
void get_hardware_name(char *hardware, unsigned int *revision)
{
    char data[1024];
    int fd, n;
    char *x, *hw, *rev;

    /* Hardware string was provided on kernel command line */
    if (hardware[0])
        return;

    fd = open("/proc/cpuinfo", O_RDONLY);
    if (fd &lt; 0) return;

    n = read(fd, data, 1023);
    close(fd);
    if (n &lt; 0) return;

    data[n] = 0;
    hw = strstr(data, "\nHardware");
    rev = strstr(data, "\nRevision");

    if (hw) {
        x = strstr(hw, ": ");
        if (x) {
            x += 2;
            n = 0;
            while (*x &amp;&amp; !isspace(*x)) {
                hardware[n++] = tolower(*x);
                x++;
                if (n == 31) break;
            }
            hardware[n] = 0;
        }
    }

    if (rev) {
        x = strstr(rev, ": ");
        if (x) {
            *revision = strtoul(x + 2, 0, 16);
        }
    }
}
</pre>

<h2 id="toc_1.3">init_parser.c</h2>
<h3 id="toc_1.3.1">struct parse_state</h3>
<pre class="brush:c++">
// 解析init.rc的数据结构，需要注意parse_line为解析文本的方法指针。
// 对于service、action块有不同的处理方法。
struct parse_state
{
    char *ptr;
    char *text;
    int line;
    int nexttoken;
    void *context;
    void (*parse_line)(struct parse_state *state, int nargs, char **args);
    const char *filename;
};
</pre>

<h3 id="toc_1.3.2">init_parse_config_file</h3>
<pre class="brush:c++">
int init_parse_config_file(const char *fn)
{
    char *data;
    data = read_file(fn, 0);
    if (!data) return -1;

    // 解析入口函数
    parse_config(fn, data);
    DUMP();
    return 0;
}
</pre>

<h3 id="toc_1.3.3">parse_config</h3>
<pre class="brush:c++">
static void parse_config(const char *fn, char *s)
{
    struct parse_state state;
    char *args[INIT_PARSER_MAXARGS];
    int nargs;

    nargs = 0;
    state.filename = fn;
    state.line = 1;
    state.ptr = s;
    state.nexttoken = 0;
    // 默认的处理方法为
    state.parse_line = parse_line_no_op;
    for (;;) {
        switch (next_token(&amp;state)) {
        case T_EOF:
            state.parse_line(&amp;state, 0, 0);
            return;
        case T_NEWLINE:
            if (nargs) {
                int kw = lookup_keyword(args[0]);
                if (kw_is(kw, SECTION)) {
                    state.parse_line(&amp;state, 0, 0);
                    // 解析section
                    parse_new_section(&amp;state, kw, nargs, args);
                } else {
                    // 解析line
                    state.parse_line(&amp;state, nargs, args);
                }
                nargs = 0;
            }
            break;
        case T_TEXT:
            if (nargs &lt; INIT_PARSER_MAXARGS) {
                args[nargs++] = state.text;
            }
            break;
        }
    }
}
</pre>

<h3 id="toc_1.3.4">parse_new_section</h3>
<pre class="brush:c++">
void parse_new_section(struct parse_state *state, int kw,
                       int nargs, char **args)
{
    printf("[ %s %s ]\n", args[0],
           nargs &gt; 1 ? args[1] : "");
    switch(kw) {
    case K_service:
        state-&gt;context = parse_service(state, nargs, args);
        if (state-&gt;context) {
            // 解析service
            state-&gt;parse_line = parse_line_service;
            return;
        }
        break;
    case K_on:
        state-&gt;context = parse_action(state, nargs, args);
        if (state-&gt;context) {
            // 解析action
            state-&gt;parse_line = parse_line_action;
            return;
        }
        break;
    }
    state-&gt;parse_line = parse_line_no_op;
}
</pre>

<h3 id="toc_1.3.5">parse_line_service</h3>
<pre class="brush:c++">
static void parse_line_service(struct parse_state *state, int nargs, char **args)
{
    struct service *svc = state-&gt;context;
    struct command *cmd;
    int i, kw, kw_nargs;

    if (nargs == 0) {
        return;
    }

    svc-&gt;ioprio_class = IoSchedClass_NONE;

    kw = lookup_keyword(args[0]);
    switch (kw) {
    case K_capability:
        break;
    case K_class:
        if (nargs != 2) {
            parse_error(state, "class option requires a classname\n");
        } else {
            svc-&gt;classname = args[1];
        }
        break;
    case K_console:
        svc-&gt;flags |= SVC_CONSOLE;
        break;
    case K_disabled:
        svc-&gt;flags |= SVC_DISABLED;
        break;
    case K_ioprio:
        if (nargs != 3) {
            parse_error(state, "ioprio optin usage: ioprio &lt;rt|be|idle&gt; &lt;ioprio 0-7&gt;\n");
        } else {
            svc-&gt;ioprio_pri = strtoul(args[2], 0, 8);

            if (svc-&gt;ioprio_pri &lt; 0 || svc-&gt;ioprio_pri &gt; 7) {
                parse_error(state, "priority value must be range 0 - 7\n");
                break;
            }

            if (!strcmp(args[1], "rt")) {
                svc-&gt;ioprio_class = IoSchedClass_RT;
            } else if (!strcmp(args[1], "be")) {
                svc-&gt;ioprio_class = IoSchedClass_BE;
            } else if (!strcmp(args[1], "idle")) {
                svc-&gt;ioprio_class = IoSchedClass_IDLE;
            } else {
                parse_error(state, "ioprio option usage: ioprio &lt;rt|be|idle&gt; &lt;0-7&gt;\n");
            }
        }
        break;
    case K_group:
        if (nargs &lt; 2) {
            parse_error(state, "group option requires a group id\n");
        } else if (nargs &gt; NR_SVC_SUPP_GIDS + 2) {
            parse_error(state, "group option accepts at most %d supp. groups\n",
                        NR_SVC_SUPP_GIDS);
        } else {
            int n;
            svc-&gt;gid = decode_uid(args[1]);
            for (n = 2; n &lt; nargs; n++) {
                svc-&gt;supp_gids[n-2] = decode_uid(args[n]);
            }
            svc-&gt;nr_supp_gids = n - 2;
        }
        break;
    case K_keycodes:
        if (nargs &lt; 2) {
            parse_error(state, "keycodes option requires atleast one keycode\n");
        } else {
            svc-&gt;keycodes = malloc((nargs - 1) * sizeof(svc-&gt;keycodes[0]));
            if (!svc-&gt;keycodes) {
                parse_error(state, "could not allocate keycodes\n");
            } else {
                svc-&gt;nkeycodes = nargs - 1;
                for (i = 1; i &lt; nargs; i++) {
                    svc-&gt;keycodes[i - 1] = atoi(args[i]);
                }
            }
        }
        break;
    case K_oneshot:
        svc-&gt;flags |= SVC_ONESHOT;
        break;
    case K_onrestart:
        nargs--;
        args++;
        kw = lookup_keyword(args[0]);
        if (!kw_is(kw, COMMAND)) {
            parse_error(state, "invalid command '%s'\n", args[0]);
            break;
        }
        kw_nargs = kw_nargs(kw);
        if (nargs &lt; kw_nargs) {
            parse_error(state, "%s requires %d %s\n", args[0], kw_nargs - 1,
                kw_nargs &gt; 2 ? "arguments" : "argument");
            break;
        }

        cmd = malloc(sizeof(*cmd) + sizeof(char*) * nargs);
        cmd-&gt;func = kw_func(kw);
        cmd-&gt;nargs = nargs;
        memcpy(cmd-&gt;args, args, sizeof(char*) * nargs);
        list_add_tail(&amp;svc-&gt;onrestart.commands, &amp;cmd-&gt;clist);
        break;
    case K_critical:
        svc-&gt;flags |= SVC_CRITICAL;
        break;
    case K_setenv: { /* name value */
        struct svcenvinfo *ei;
        if (nargs &lt; 2) {
            parse_error(state, "setenv option requires name and value arguments\n");
            break;
        }
        ei = calloc(1, sizeof(*ei));
        if (!ei) {
            parse_error(state, "out of memory\n");
            break;
        }
        ei-&gt;name = args[1];
        ei-&gt;value = args[2];
        ei-&gt;next = svc-&gt;envvars;
        svc-&gt;envvars = ei;
        break;
    }
    case K_socket: {/* name type perm [ uid gid ] */
        struct socketinfo *si;
        if (nargs &lt; 4) {
            parse_error(state, "socket option requires name, type, perm arguments\n");
            break;
        }
        if (strcmp(args[2],"dgram") &amp;&amp; strcmp(args[2],"stream")
                &amp;&amp; strcmp(args[2],"seqpacket")) {
            parse_error(state, "socket type must be 'dgram', 'stream' or 'seqpacket'\n");
            break;
        }
        si = calloc(1, sizeof(*si));
        if (!si) {
            parse_error(state, "out of memory\n");
            break;
        }
        si-&gt;name = args[1];
        si-&gt;type = args[2];
        si-&gt;perm = strtoul(args[3], 0, 8);
        if (nargs &gt; 4)
            si-&gt;uid = decode_uid(args[4]);
        if (nargs &gt; 5)
            si-&gt;gid = decode_uid(args[5]);
        si-&gt;next = svc-&gt;sockets;
        svc-&gt;sockets = si;
        break;
    }
    case K_user:
        if (nargs != 2) {
            parse_error(state, "user option requires a user id\n");
        } else {
            svc-&gt;uid = decode_uid(args[1]);
        }
        break;
    default:
        parse_error(state, "invalid option '%s'\n", args[0]);
    }
}
</pre>

<h3 id="toc_1.3.6">parse_line_action</h3>
<pre class="brush:c++">
static void parse_line_action(struct parse_state* state, int nargs, char **args)
{
    struct command *cmd;
    struct action *act = state-&gt;context;
    int (*func)(int nargs, char **args);
    int kw, n;

    if (nargs == 0) {
        return;
    }

    kw = lookup_keyword(args[0]);
    if (!kw_is(kw, COMMAND)) {
        parse_error(state, "invalid command '%s'\n", args[0]);
        return;
    }

    n = kw_nargs(kw);
    if (nargs &lt; n) {
        parse_error(state, "%s requires %d %s\n", args[0], n - 1,
            n &gt; 2 ? "arguments" : "argument");
        return;
    }
    cmd = malloc(sizeof(*cmd) + sizeof(char*) * nargs);
    cmd-&gt;func = kw_func(kw);
    cmd-&gt;nargs = nargs;
    memcpy(cmd-&gt;args, args, sizeof(char*) * nargs);
    list_add_tail(&amp;act-&gt;commands, &amp;cmd-&gt;clist);
}
</pre>

<h2 id="toc_1.4">devices.c</h2>
<h3 id="toc_1.4.1">device_init</h3>
<pre class="brush:c++">
int device_init(void)
{
    suseconds_t t0, t1;
    int fd;

    fd = open_uevent_socket();
    if(fd &lt; 0)
        return -1;

    fcntl(fd, F_SETFD, FD_CLOEXEC);
    fcntl(fd, F_SETFL, O_NONBLOCK);

    t0 = get_usecs();
    coldboot(fd, "/sys/class");
    coldboot(fd, "/sys/block");
    coldboot(fd, "/sys/devices");
    t1 = get_usecs();

    log_event_print("coldboot %ld uS\n", ((long) (t1 - t0)));

    return fd;
}
</pre>

<h3 id="toc_1.4.2">do_coldboot</h3>
<pre class="brush:c++">
static void do_coldboot(int event_fd, DIR *d)
{
    struct dirent *de;
    int dfd, fd;

    dfd = dirfd(d);

    fd = openat(dfd, "uevent", O_WRONLY);
    if(fd &gt;= 0) {
        write(fd, "add\n", 4);
        close(fd);
        handle_device_fd(event_fd);
    }

    while((de = readdir(d))) {
        DIR *d2;

        if(de-&gt;d_type != DT_DIR || de-&gt;d_name[0] == '.')
            continue;

        fd = openat(dfd, de-&gt;d_name, O_RDONLY | O_DIRECTORY);
        if(fd &lt; 0)
            continue;

        d2 = fdopendir(fd);
        if(d2 == 0)
            close(fd);
        else {
            do_coldboot(event_fd, d2);
            closedir(d2);
        }
    }
}
</pre>

<h3 id="toc_1.4.3">coldboot</h3>
<pre class="brush:c++">
static void coldboot(int event_fd, const char *path)
{
    DIR *d = opendir(path);
    if(d) {
        do_coldboot(event_fd, d);
        closedir(d);
    }
}
</pre>

<h2 id="toc_1.5">property_service.c</h2>
<h3 id="toc_1.5.1">property_init</h3>
<pre class="brush:c++">
void property_init(void)
{
    // 初始化时读取/default.prop
    init_property_area();
    load_properties_from_file(PROP_PATH_RAMDISK_DEFAULT);
}
</pre>

<h3 id="toc_1.5.2">start_property_service</h3>
<pre class="brush:c++">
int start_property_service(void)
{
    int fd;

    // 开启服务时读取/system/build.prop、/system/default.prop、/data/local.prop
    load_properties_from_file(PROP_PATH_SYSTEM_BUILD);
    load_properties_from_file(PROP_PATH_SYSTEM_DEFAULT);
    load_properties_from_file(PROP_PATH_LOCAL_OVERRIDE);
    /* Read persistent properties after all default values have been loaded. */
    load_persistent_properties();

    fd = create_socket(PROP_SERVICE_NAME, SOCK_STREAM, 0666, 0, 0);
    if(fd &lt; 0) return -1;
    fcntl(fd, F_SETFD, FD_CLOEXEC);
    fcntl(fd, F_SETFL, O_NONBLOCK);

    listen(fd, 8);
    return fd;
}
</pre>

<h3 id="toc_1.5.3">handle_property_set_fd</h3>
<pre class="brush:c++">
void handle_property_set_fd(int fd)
{
    prop_msg msg;
    int s;
    int r;
    int res;
    struct ucred cr;
    struct sockaddr_un addr;
    socklen_t addr_size = sizeof(addr);
    socklen_t cr_size = sizeof(cr);

    if ((s = accept(fd, (struct sockaddr *) &amp;addr, &amp;addr_size)) &lt; 0) {
        return;
    }

    /* Check socket options here */
    if (getsockopt(s, SOL_SOCKET, SO_PEERCRED, &amp;cr, &amp;cr_size) &lt; 0) {
        close(s);
        ERROR("Unable to recieve socket options\n");
        return;
    }

    r = recv(s, &amp;msg, sizeof(msg), 0);
    close(s);
    if(r != sizeof(prop_msg)) {
        ERROR("sys_prop: mis-match msg size recieved: %d expected: %d\n",
              r, sizeof(prop_msg));
        return;
    }

    switch(msg.cmd) {
    case PROP_MSG_SETPROP:
        msg.name[PROP_NAME_MAX-1] = 0;
        msg.value[PROP_VALUE_MAX-1] = 0;

        if(memcmp(msg.name,"ctl.",4) == 0) {
            if (check_control_perms(msg.value, cr.uid, cr.gid)) {
                handle_control_message((char*) msg.name + 4, (char*) msg.value);
            } else {
                ERROR("sys_prop: Unable to %s service ctl [%s] uid: %d pid:%d\n",
                        msg.name + 4, msg.value, cr.uid, cr.pid);
            }
        } else {
            if (check_perms(msg.name, cr.uid, cr.gid)) {
                property_set((char*) msg.name, (char*) msg.value);
            } else {
                ERROR("sys_prop: permission denied uid:%d  name:%s\n",
                      cr.uid, msg.name);
            }
        }
        break;

    default:
        break;
    }
}
</pre>

<h2 id="toc_1.6">parser.c</h2>
<h3 id="toc_1.6.1">drain_action_queue</h3>
<pre class="brush:c++">
void drain_action_queue(void)
{
    struct listnode *node;
    struct command *cmd;
    struct action *act;
    int ret;

    while ((act = action_remove_queue_head())) {
        INFO("processing action %p (%s)\n", act, act-&gt;name);
        list_for_each(node, &amp;act-&gt;commands) {
            cmd = node_to_item(node, struct command, clist);
            ret = cmd-&gt;func(cmd-&gt;nargs, cmd-&gt;args);
            INFO("command '%s' r=%d\n", cmd-&gt;args[0], ret);
        }
    }
}
</pre>

<h3 id="toc_1.6.2">action_for_each_trigger</h3>
<pre class="brush:c++">
void action_for_each_trigger(const char *trigger,
                             void (*func)(struct action *act))
{
    struct listnode *node;
    struct action *act;
    list_for_each(node, &amp;action_list) {
        act = node_to_item(node, struct action, alist);
        if (!strcmp(act-&gt;name, trigger)) {
            func(act);
        }
    }
}
</pre>

<h3 id="toc_1.6.3">action_remove_queue_head</h3>
<pre class="brush:c++">
struct action *action_remove_queue_head(void)
{
    if (list_empty(&amp;action_queue)) {
        return 0;
    } else {
        struct listnode *node = list_head(&amp;action_queue);
        struct action *act = node_to_item(node, struct action, qlist);
        list_remove(node);
        return act;
    }
}
</pre>
<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

<!--<script type="text/javascript">-->
<!--var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");-->
<!--document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));-->
<!--</script>-->
<!--<script type="text/javascript">-->
<!--try {-->
<!--var pageTracker = _gat._getTracker("UA-15922433-1");-->
<!--pageTracker._trackPageview();-->
<!--} catch(err) {}-->
<!--</script>-->

</body>
</html>
