<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>使用View</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <link rel="Stylesheet" type="text/css" href="../css_style/style_zenki.css">

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>

<!-- wrap the vimwiki html -->

<h1 id="toc_1">View概述</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">View概述</a>
<ul>
<li><a href="#toc_1.1">典型使用View的流程方法</a>
<li><a href="#toc_1.2">自定义View的流程方法</a>
<li><a href="#toc_1.3">与视图绑定的IDs</a>
<ul>
<li><a href="#toc_1.3.1">在资源文件中定义ID</a>
<li><a href="#toc_1.3.2">在onCreate方法中查找视图</a>
</ul>
<li><a href="#toc_1.4">View的位置,大小,边距，可见性</a>
<ul>
<li><a href="#toc_1.4.1">位置，大小,边距</a>
</ul>
<li><a href="#toc_1.5">事件处理和线程</a>
<li><a href="#toc_1.6">绘画</a>
<li><a href="#toc_1.7">焦点处理</a>
<li><a href="#toc_1.8">触摸模式</a>
<li><a href="#toc_1.9">卷轴</a>
<li><a href="#toc_1.10">tag</a>
<li><a href="#toc_1.11">动画</a>
<li><a href="#toc_1.12">处理窗口还原状态</a>
</ul>
</ul>
</div>

<h2 id="toc_1.1">典型使用View的流程方法</h2>
<ul>
<li>
通过改写XML资源文件来设置View属性

<li>
设置焦点,通过哦requestFocus()方法来获得焦点

<li>
设置监听器来响应用户的交互

<li>
通过setVisibility(int)来设置视图可见

</ul>

<h2 id="toc_1.2">自定义View的流程方法</h2>
<table>
<tr>
<th>
流程
</th>
<th>
方法
</th>
<th>
描述
</th>
</tr>
<tr>
<td>
创建对象
</td>
<td>
构造函数, onFinishInflate
</td>
<td>
当视图和子对象从XML文件加载后调用
</td>
</tr>
<tr>
<td>
设置布局
</td>
<td>
onMeasure, onLayout, onSizeChanged
</td>
<td>
设置布局的大小,样式
</td>
</tr>
<tr>
<td>
绘画
</td>
<td>
onDraw, invalidate
</td>
<td>
将内容显示出来,刷新视图
</td>
</tr>
<tr>
<td>
事件处理
</td>
<td>
onKeyDown, onKeyUp, onTrackballEvent, onTouchEvent
</td>
<td>
处理按键和触摸动作
</td>
</tr>
<tr>
<td>
焦点
</td>
<td>
onFocusChanged
</td>
<td>
当视图失去或得到焦点是触发
</td>
</tr>
<tr>
<td>
附着
</td>
<td>
onAttachedWindow, onDetechedFromWindow, onWindowVisibilityChanged
</td>
<td>
当窗口消失或离开窗口的事件响应
</td>
</tr>
</table>

<h2 id="toc_1.3">与视图绑定的IDs</h2>
<ul>
<li>
通常需要将视图与一个ID绑定,使Activity可以获取到该视图的对象

</ul>

<h3 id="toc_1.3.1">在资源文件中定义ID</h3>
<pre class="brush: xml">
&lt;Button id="@+id/my_button"
     android:layout_width="wrap_content"
     android:layout_height="wrap_content"
     android:text="@string/my_button_text"/&gt;
</pre>

<h3 id="toc_1.3.2">在onCreate方法中查找视图</h3>
<pre class="brush: java">
Button myButton = (Button) findViewById(R.id.my_button);
</pre>

<h2 id="toc_1.4">View的位置,大小,边距，可见性</h2>
<ul>
<li>
View的位置以左上角为基准,通过调用getLeft()和getTop()来返回当前位置.
<pre class="brush: text">
getRight = getLeft() + getWidth()
getBottom = getTop() + getHeight()
</pre>

</ul>

<h3 id="toc_1.4.1">位置，大小,边距</h3>
<ul>
<li>
padding是控件的内容相对控件的边缘的边距

<li>
margin是控件边缘相对父空间的边距

<li>
android:gravity属性是对该view内容的限定。比如一个button上面的text。你可以设置该text在view的靠左，靠右等位置。

<li>
android:layout_gravity是用来设置该view相对于父view的位置。比如一个button在linearlayout里，你想把该button放在靠左，靠右等位置就可以通过该属性设置。

<li>
android:visibility标识view是否可见，invisible值为对用户不可见，visible值为对用户可见，gone值为对用户不可见，并且不占据视图的空间。

</ul>

<pre class="brush: java">
getMeasureWidth()
getMeasureHeight()
getWidth()
getHeight()
setPadding(int, int, int, int)
getPaddingLeft()
getPaddingTop()
getPaddingRight()
getPaddingBottom()
</pre>

<h2 id="toc_1.5">事件处理和线程</h2>
<p>
<strong>1.一个事件发生后分配给相应的View,View处理事件并通知listeners</strong>
</p>

<p>
<strong>2.在事件处理中View的边界如果发生变化,会调用requestLayout</strong>
</p>

<p>
<strong>3.在事件处理中如果View的视图发生变化,会调用invalidate</strong>
</p>

<p>
<strong>4.在处理UI事件时应该使用单独的线程</strong>
</p>

<h2 id="toc_1.6">绘画</h2>
<pre class="brush:java">
@Override
protected void onDraw(Canvas canvas) {
    //这里我们直接使用canvas对象处理当前的画布，比如说使用Paint来选择要填充的颜色
    Paint paintBackground = new Paint();
    
    //从Res中找到名为xxx的color颜色定义
    paintBackground.setColor(getResources().getColor(R.color.xxx));  
    //设置当前画布的背景颜色为paintBackground中定义的颜色，以0,0作为为起点，以当前画布的宽度和高度为重点即整块画布来填充。  
    canvas.drawRect(0, 0, getWidth(), getHeight(), paintBackground); 
}
</pre>

<h2 id="toc_1.7">焦点处理</h2>
<ul>
<li>
以下方法处理焦点的控制
<pre class="brush: java">
isFocusable()
setFocusable(boolean)
isFocusableInTouchMode()
setFocusableInTouchMode(boolean)
requestFocus()
</pre>

</ul>

<h2 id="toc_1.8">触摸模式</h2>
<ul>
<li>
以下方法处理触摸模式
<pre class="brush: java">
isFocusableInTouchMode()
setFocusableInTouchMode(boolean)
isInTouchMode()
</pre>

</ul>

<h2 id="toc_1.9">卷轴</h2>
<ul>
<li>
以下方法处理卷轴
<pre class="brush: java">
scrollBy(int, int)
scrollTo(int, int)
awakenScroolBars()
</pre>

</ul>

<h2 id="toc_1.10">tag</h2>
<ul>
<li>
tag用来标识View附带的额外数据
<pre class="brush:java">
void setTag(Object tag)
void setTag(int key, Object tag)
</pre>

</ul>

<h2 id="toc_1.11">动画</h2>
<ul>
<li>
以下方法可以将Animation对象加入到View
<pre class="brush: java">
setAnimation(Animation)
startAnimation(Animation)
</pre>

</ul>

<h2 id="toc_1.12">处理窗口还原状态</h2>
<pre class="brush:java">
@Override
protected Parcelable onSaveInstanceState() {
    Parcelable p = super.onSaveInstanceState();
    Bundle bundle = new Bundle();
    bundle.putInt("x", pX);
    bundle.putInt("y", pY);
    bundle.putParcelable("android123_state", p);
    return bundle;
}

@Override
protected void onRestoreInstanceState(Parcelable state) { 
    Bundle bundle = (Bundle) state;
    dosomething(bundle.getInt("x"), bundle.getInt("y")); //获取刚才存储的x和y信息
    super.onRestoreInstanceState(bundle.getParcelable("android123_state"));
    return;
}
</pre>


<footer>
    <a href="http://zenki2001cn.github.com/Wiki" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="zenki2001cn@163.com" id="back-email">Email</a>
</footer>

</article>
</div>

</body>
</html>
