<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>音频多路输出处理</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
	<link type="text/css" rel="stylesheet" href="css_style/style_zenki.css"/>

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>


<h1 id="toc_1">多路输出处理</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">多路输出处理</a></li>
<ul>
<li><a href="#toc_1.1">开启多线程</a></li>
<ul>
<li><a href="#toc_1.1.1">AudioPolicyManagerBase::handleA2dpConnection</a></li>
</ul>
<li><a href="#toc_1.2">处理线程</a></li>
<ul>
<li><a href="#toc_1.2.1">AudioFlinger::openDuplicateOutput</a></li>
<li><a href="#toc_1.2.2">AudioFlinger::DuplicatingThread::addOutputTrack</a></li>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">开启多线程</h2>
<ul>
<li>
AudioPolicyManagerBase::handleA2dpConnection和AudioPolicyManagerBase::handleA2dpDisconnection用来处理蓝牙连接的情形。
</li>
<li>
当设备连接时，会先调用AudioPolicyService::openOutput打开设备，随后调用AudioPolicyService::openDuplicateOutput进行双线程处理。
</li>
<li>
AudioPolicyManagerBase会做出以下动作：
</li>
<ul>
<li>
首先打开（或创建）蓝牙输出线程A2dpOutput
</li>
<li>
以HardwareOutput和A2dpOutput作为参数，调用openDuplicateOutput，创建 DuplicatingThread
</li>
<li>
把属于STRATEGY_MEDIA类型的Track移到A2dpOutput中
</li>
<li>
把属于STRATEGY_DTMF类型的Track移到A2dpOutput中
</li>
<li>
把属于STRATEGY_SONIFICATION类型的Track移到DuplicateOutput中
</li>
</ul>
</ul>

<h3 id="toc_1.1.1">AudioPolicyManagerBase::handleA2dpConnection</h3>
<pre class="brush:c++">
status_t AudioPolicyManagerBase::handleA2dpConnection(AudioSystem::audio_devices device,
                                                 const char *device_address)
{
    // when an A2DP device is connected, open an A2DP and a duplicated output
    AudioOutputDescriptor *outputDesc = new AudioOutputDescriptor();
    outputDesc-&gt;mDevice = device;
    mA2dpOutput = mpClientInterface-&gt;openOutput(&amp;outputDesc-&gt;mDevice, &amp;outputDesc-&gt;mSamplingRate,
                                            &amp;outputDesc-&gt;mFormat, &amp;outputDesc-&gt;mChannels,
                                            &amp;outputDesc-&gt;mLatency, outputDesc-&gt;mFlags);
    if (mA2dpOutput) {
        // add A2DP output descriptor
        addOutput(mA2dpOutput, outputDesc);

        // set initial stream volume for A2DP device
        applyStreamVolumes(mA2dpOutput, device);
        if (a2dpUsedForSonification()) {
            // 打开双线程
            mDuplicatedOutput = mpClientInterface-&gt;openDuplicateOutput(mA2dpOutput, mHardwareOutput);
        }
        if (mDuplicatedOutput != 0 ||
            ...... 
        } else {
            ...... 
        }
    } else {
        ......
        return NO_INIT;
    }
    
    ......
    return NO_ERROR;
}
</pre>

<h2 id="toc_1.2">处理线程</h2>
<ul>
<li>
AudioFlinger中有一个特殊的线程类：DuplicatingThread，从类结构图可以发现，它是MixerThread的子类。当系统中有两个设备要同时输出时，DuplicatingThread将被创建，通过IAudioFlinger的openDuplicateOutput方法创建DuplicatingThread。
</li>
<ul>
<li>
DuplicatingThread的构造方法会调用DuplicatingThread::addOutputTrack创建第一个OutputTrack对象并加入到成员变量mOutputTracks的容器。
</li>
<li>
之后构造方法会返回DuplicatingThread对象，再调用一次addOutputTrack方法创建第二个OutputTrack对象并加入容器。
</li>
<li>
以上创建的两个OutputTrack对象同时又会被加入到两个MixerThread线程中。
</li>
</ul>
<li>
当DuplicatingThread::threadLoop线程往两个OutputTrack对象写数据的同时，两个<code>MixerThread::threadLoop</code>线程从中获取数据并输出到不同目标中。
</li>
</ul>

<p>
<a href="pic/bt_thread_track.png"><img src="pic/bt_thread_track.png" /></a>
</p>

<h3 id="toc_1.2.1">AudioFlinger::openDuplicateOutput</h3>
<pre class="brush:c++">
int AudioFlinger::openDuplicateOutput(int output1, int output2)
{
    Mutex::Autolock _l(mLock);
    // 从线程队列中查找对应ID的线程对象
    MixerThread *thread1 = checkMixerThread_l(output1);
    MixerThread *thread2 = checkMixerThread_l(output2);

    if (thread1 == NULL || thread2 == NULL) {
        return 0;
    }

    int id = nextUniqueId();
    DuplicatingThread *thread = new DuplicatingThread(this, thread1, id);
    thread-&gt;addOutputTrack(thread2);
    mPlaybackThreads.add(id, thread);
    // 通知i/o设备变更
    thread-&gt;audioConfigChanged_l(AudioSystem::OUTPUT_OPENED);
    return id;
}
</pre>

<h3 id="toc_1.2.2">AudioFlinger::DuplicatingThread::addOutputTrack</h3>
<pre class="brush:c++">
void AudioFlinger::DuplicatingThread::addOutputTrack(MixerThread *thread)
{
    int frameCount = (3 * mFrameCount * mSampleRate) / thread-&gt;sampleRate();
    // 创建OutputTrack
    OutputTrack *outputTrack = new OutputTrack((ThreadBase *)thread,
                                            this, mSampleRate, mFormat,
                                            mChannelCount, frameCount);
    if (outputTrack-&gt;cblk() != NULL) {
        thread-&gt;setStreamVolume(AudioSystem::NUM_STREAM_TYPES, 1.0f);
        // 添加Track到容器中
        mOutputTracks.add(outputTrack);
        updateWaitTime();
    }
}
</pre>
<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

<!--<script type="text/javascript">-->
<!--var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");-->
<!--document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));-->
<!--</script>-->
<!--<script type="text/javascript">-->
<!--try {-->
<!--var pageTracker = _gat._getTracker("UA-15922433-1");-->
<!--pageTracker._trackPageview();-->
<!--} catch(err) {}-->
<!--</script>-->

</body>
</html>
