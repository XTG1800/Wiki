<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>container_of指针转换</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <link rel="Stylesheet" type="text/css" href="../css_style/style_zenki.css">

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>

<!-- wrap the vimwiki html -->

<h1 id="toc_1">container_of指针转换</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">container_of指针转换</a>
<ul>
<li><a href="#toc_1.1">相关文件</a>
<li><a href="#toc_1.2">container_of宏</a>
<li><a href="#toc_1.3">示例说明</a>
</ul>
</ul>
</div>

<h2 id="toc_1.1">相关文件</h2>
<pre class="brush:c">
#include &lt;linux/kernel.h&gt;
</pre>

<h2 id="toc_1.2">container_of宏</h2>
<ul>
<li>
通常C语言通过在struct中包含另一个struct来实现继承。如何根据父类对象指针获取子类的对象呢？Linux Kernel中使用<code>container_of</code>宏定义。
<pre class="brush:c">
/**
 * container_of - cast a member of a structure out to the containing structure
 * @ptr:	the pointer to the member.
 * @type:	the type of the container struct this is embedded in.
 * @member:	the name of the member within the struct.
 *
 */
#define container_of(ptr, type, member) ({			\
	const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);	\
	(type *)( (char *)__mptr - offsetof(type,member) );})
</pre>

</ul>

<h2 id="toc_1.3">示例说明</h2>
<ul>
<li>
该示例中，struct scull_dev包含struct cdev对象，并且对象名是m_cdev。

<ul>
<li>
container_of宏接收的第一个参数是指向m_cdev成员的指针。

<li>
第二个参数是需要返回的对象类型。

<li>
第三个参数是一个成员变量名，由于container_of是宏定义，它可以将该变量名和第二个参数组合，返回其地址。

</ul>
<li>
container_of最终将m_cdev的指针转换，得到了继承子类struct scull_dev对象的指针。
<pre class="brush:c">
# scull_dev结构描述
struct scull_dev { 
    struct cdev m_cdev;
    // ...... 
};

# 指针转换方法
void convert() {
    struct scull_dev *dev; 
    dev = container_of(inode-&gt;i_cdev, struct scull_dev, m_cdev);
}
</pre>

</ul>


<footer>
    <a href="http://zenki2001cn.github.com/Wiki" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="zenki2001cn@163.com" id="back-email">Email</a>
</footer>

</article>
</div>

</body>
</html>
