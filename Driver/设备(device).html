<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>设备(device)</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <link rel="Stylesheet" type="text/css" href="../css_style/style_zenki.css">

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>

<!-- wrap the vimwiki html -->

<h1 id="toc_1">设备(device)</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">设备(device)</a>
<ul>
<li><a href="#toc_1.1">设备相关的数据结构</a>
<ul>
<li><a href="#toc_1.1.1">struct device</a>
<li><a href="#toc_1.1.2">struct device_type</a>
<li><a href="#toc_1.1.3">struct device_private</a>
</ul>
<li><a href="#toc_1.2">设备属性</a>
<ul>
<li><a href="#toc_1.2.1">struct device_attribute</a>
<li><a href="#toc_1.2.2">DEVICE_ATTR辅助宏</a>
<li><a href="#toc_1.2.3">创建设备属性</a>
</ul>
<li><a href="#toc_1.3">设备的注册和移除</a>
<ul>
<li><a href="#toc_1.3.1">示例代码</a>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">设备相关的数据结构</h2>
<h3 id="toc_1.1.1">struct device</h3>
<ul>
<li>
设备类型包含以下几个重要的成员：

<ul>
<li>
parent：该设备所附属的设备，通常是某种总线或主控制器。

<li>
kobj：驱动模型中代表当前设备的kobject，它的大致规则是device-&gt;kobj-&gt;parent等同于device-&gt;parent-&gt;kobj。

<li>
bus：设备所在的总线。

<li>
driver：管理这个设备的驱动。

<li>
release：该设备最后一个引用被移除时调用的方法。
<pre class="brush:c">
struct device {
	struct device		    *parent;

	struct device_private	*p;

	struct kobject          kobj;
	const  char		        *init_name; /* initial name of the device */
	struct device_type	    *type;

	struct mutex		    mutex;	

	struct bus_type	        *bus;		/* type of bus device is on */
	struct device_driver    *driver;	/* which driver has allocated this device */
	void		            *platform_data;	/* Platform specific data, device core doesn't touch it */
	struct dev_pm_info	    power;

#ifdef CONFIG_NUMA
	int		                numa_node;	/* NUMA node this device is close to */
#endif
	u64		                *dma_mask;	/* dma mask (if dma'able device) */
	u64		                coherent_dma_mask;

	struct device_dma_parameters    *dma_parms;

	struct list_head	    dma_pools;	/* dma pools (if dma'ble) */

	struct dma_coherent_mem	*dma_mem;   /* internal for coherent mem override */
	struct dev_archdata	archdata;       /* arch specific additions */
	dev_t			        devt;	    /* dev_t, creates the sysfs "dev" */

	spinlock_t		        devres_lock;
	struct list_head	    devres_head;

	struct klist_node	    knode_class;
	struct class		    *class;
	const struct attribute_group    **groups;	/* optional groups */

	void	(*release)(struct device *dev);
};
</pre>

</ul>
</ul>

<h3 id="toc_1.1.2">struct device_type</h3>
<ul>
<li>
<code>struct device_type</code>用来给不同的设备分类，并描述这些设备特定的信息。该类型的作用与bus_type相似。
<pre class="brush:c">
struct device_type {
	const char *name;
	const struct attribute_group **groups;
	int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
	char *(*devnode)(struct device *dev, mode_t *mode);
	void (*release)(struct device *dev);

	const struct dev_pm_ops *pm;
};
</pre>

</ul>

<h3 id="toc_1.1.3">struct device_private</h3>
<ul>
<li>
device_private结构用来表示底层驱动模型的层次结构，因此将它从struct device中分离出来。
<pre class="brush:c">
struct device_private {
	struct klist klist_children;
	struct klist_node knode_parent;
	struct klist_node knode_driver;
	struct klist_node knode_bus;
	void *driver_data;
	struct device *device;
};
</pre>

</ul>

<h2 id="toc_1.2">设备属性</h2>
<ul>
<li>
设备同样具有它的属性，由struct device_attribute来描述。

</ul>

<h3 id="toc_1.2.1">struct device_attribute</h3>
<pre class="brush:c">
struct device_attribute {
	struct attribute	attr;
	ssize_t (*show)(struct device *dev, struct device_attribute *attr,
			        char *buf);
	ssize_t (*store)(struct device *dev, struct device_attribute *attr,
			        const char *buf, size_t count);
};
</pre>

<h3 id="toc_1.2.2">DEVICE_ATTR辅助宏</h3>
<ul>
<li>
内核同样提供了一个宏来帮助创建设备属性结构，它使用了_ATTR宏，可参见其<a href="如何创建sysfs.html">如何创建sysfs</a>中的定义。
<pre class="brush:c">
#define DEVICE_ATTR(_name, _mode, _show, _store) \
struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store)
</pre>

</ul>

<h3 id="toc_1.2.3">创建设备属性</h3>
<ul>
<li>
<code>device_create_file</code>用来创建一个对应设备属性的文件。

<li>
<code>device_remove_file</code>用来移除一个对应设备属性的文件。

</ul>

<h2 id="toc_1.3">设备的注册和移除</h2>
<ul>
<li>
<code>device_register</code>方法用来注册一个设备，通常需要给总线指定一个名称。该方法首先初始化device结构，然后再将该设备添加到驱动模型中。
<pre class="brush:c">
int device_register(struct device *dev)
{
	device_initialize(dev);
	return device_add(dev);
}
</pre>

</ul>

<ul>
<li>
<code>device_unregister</code>方法用来移除一个设备。该方法首先从驱动模型中移除设备，然后将该设备的引用减一。
<pre class="brush:c">
void device_unregister(struct device *dev)
{
	device_del(dev);
	put_device(dev);
}
</pre>

</ul>

<h3 id="toc_1.3.1">示例代码</h3>
<pre class="brush:c">
// 声明一个device实例
struct device ldd_bus = {
 .init_name = "ldd0",
 .release = ldd_bus_release
}; 

// 注册一个设备
int register_device() {
    int ret = device_register(&amp;ldd_bus);
    return ret;
}

// 移除一个设备
void unregister_device() {
    device_unregister(&amp;ldd_bus);
}
</pre>


<footer>
    <a href="http://zenki2001cn.github.com/Wiki" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="zenki2001cn@163.com" id="back-email">Email</a>
</footer>

</article>
</div>

</body>
</html>
