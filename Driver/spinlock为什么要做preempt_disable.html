<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>spinlock为什么要做preempt_disable</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
	<link type="text/css" rel="stylesheet" href="css_style/style_zenki.css"/>

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>


<h1 id="toc_1">spinlock为什么要做preempt_disable</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">spinlock为什么要做preempt_disable</a></li>
<ul>
<li><a href="#toc_1.1">spinlock的现有实现</a></li>
<ul>
<li><a href="#toc_1.1.1">UP上定义的宏和函数</a></li>
<li><a href="#toc_1.1.2">SMP上定义的函数：</a></li>
</ul>
<li><a href="#toc_1.2">什么是Priority inversion？</a></li>
<li><a href="#toc_1.3">什么是Priority ceiling？</a></li>
<li><a href="#toc_1.4">Linux内核是怎么解决优先级反转的问题的？</a></li>
<li><a href="#toc_1.5">对于spinlock问什么说它会发生由优先级反转而带来的死锁？</a></li>
</ul>
</ul>
</div>

<h2 id="toc_1.1">spinlock的现有实现</h2>
<ul>
<li>
在spinlock.h头文件中定义：
</li>
</ul>

<pre class="brush:c">
static inline void spin_lock(spinlock_t *lock)
{
    raw_spin_lock(&amp;lock-&gt;rlock);
}
</pre>

<h3 id="toc_1.1.1">UP上定义的宏和函数</h3>

<pre class="brush:c">
#define __LOCK(lock) \
    do { preempt_disable(); __acquire(lock); (void)(lock); } while (0)

#define _raw_spin_lock(lock)  __LOCK(lock)

#define raw_spin_lock(lock)  _raw_spin_lock(lock)
</pre>

<h3 id="toc_1.1.2">SMP上定义的函数：</h3>
<ul>
<li>
无论在UP还是SMP上，spin_lock()调用中都会调用preempt_disable()？这里主要是为了防止发生死锁，或者说采用了priority ceiling的方法来防止priority inversion。
</li>
</ul>

<pre class="brush:c">
void __lockfunc _raw_spin_lock(raw_spinlock_t *lock)     __acquires(lock);

// 在spinlock.c文件中：
BUILD_LOCK_OPS(spin, raw_spinlock);

// 如果采用inline函数定义：
#ifdef CONFIG_INLINE_SPIN_LOCK
#define _raw_spin_lock(lock) __raw_spin_lock(lock)
#endif

static inline void __raw_spin_lock(raw_spinlock_t *lock)
{
    preempt_disable();
    spin_acquire(&amp;lock-&gt;dep_map, 0, 0, _RET_IP_);
    LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);
}
</pre>

<h2 id="toc_1.2">什么是Priority inversion？</h2>
<pre class="brush:text">
    是指“优先级反转”，也就是优先级高的任务反而较晚完成的错误现象；比如，假设有进程A，B，C；
优先级A&gt;B&gt;C;A，C进程都需要临界区数据；而B不需要；
    如果某个条件下，A进程得到机会执行，但C却持有它需要的锁，所以A虽然得到CPU但是却只能等待；
CPU上又回放回C；接着B试图执行，它可以将C挤出去，因为它的优先级高于C，而且它也不需要C持有的锁；
B执行结束后，C又回到CPU上继续执行，直到它结束并且放开锁，A才有可能得到锁以便完成任务。那么
最终结果就是，B最先完成，接着是C，最后是A。这个结果就与他们原来定义的优先级不同了，优先级最高
的任务反而最后完成。
    如果这里禁止抢占，那么调度就不需要考虑优先级，仅仅依赖于是否可以获得锁。当C持有锁的时候，
A会等待；而B不会被调度进来，因为优先级判断已经失效了。只能等C执行结束，才有机会调度A或者B。
这看起来就是spin_lock想要的效果。但是这种情况里，就没有什么优先级的概念了，系统的实时性——也就是
按照优先级调度的能力就无法得到保障了。
</pre>

<h2 id="toc_1.3">什么是Priority ceiling？</h2>
<pre class="brush:text">
    这是解决Priority inversion问题的一个方法，即将持有锁的任务提高到当时系统中的最高优先级，
这样的话，上面例子中的A与持有锁的C将具有同样的优先级，或者C的优先级将大于A的优先级，那么A就
无法将C从CPU上挤出去。从而保证锁的有效性。但是这仍然无法解决实时性的问题。
</pre>

<h2 id="toc_1.4">Linux内核是怎么解决优先级反转的问题的？</h2>
<pre class="brush:text">
    Linux内核中采用了priority ceiling的方法；就是这里的preempt_disable()。当系统禁止抢占时，
则系统中仅有一个优先级，于是上例中的C就取得了当时系统中的最高优先级；而A的优先级看上去也与C保持
了一致。
</pre>

<h2 id="toc_1.5">对于spinlock问什么说它会发生由优先级反转而带来的死锁？</h2>
<pre class="brush:text">
    因为spinlock比较特殊，不像其他锁机制，任务在遇到block情况是会进入睡眠状态而让出CPU使用权。
spinlock则会一直占有CPU做nop，这样导致CPU空转。在该任务用完时间片之后，才会让出CPU。比如上面
例子的任务A,它可能一直占有CPU而“忙等”，这就造成了死锁的可能。
</pre>
<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

<!--<script type="text/javascript">-->
<!--var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");-->
<!--document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));-->
<!--</script>-->
<!--<script type="text/javascript">-->
<!--try {-->
<!--var pageTracker = _gat._getTracker("UA-15922433-1");-->
<!--pageTracker._trackPageview();-->
<!--} catch(err) {}-->
<!--</script>-->

</body>
</html>
