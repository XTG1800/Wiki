<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>总线(bus)</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <link rel="Stylesheet" type="text/css" href="../css_style/style_zenki.css">

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>

<!-- wrap the vimwiki html -->

<h1 id="toc_1">总线</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">总线</a>
<ul>
<li><a href="#toc_1.1">总线相关的数据结构</a>
<ul>
<li><a href="#toc_1.1.1">struct bus_type</a>
<li><a href="#toc_1.1.2">sturct dev_pm_ops</a>
<li><a href="#toc_1.1.3">struct bus_type_private</a>
</ul>
<li><a href="#toc_1.2">总线属性</a>
<ul>
<li><a href="#toc_1.2.1">struct bus_attribute</a>
<li><a href="#toc_1.2.2">BUS_ATTR辅助宏</a>
<li><a href="#toc_1.2.3">创建总线属性</a>
</ul>
<li><a href="#toc_1.3">总线的注册和移除</a>
<ul>
<li><a href="#toc_1.3.1">示例代码</a>
</ul>
<li><a href="#toc_1.4">列举设备和驱动</a>
</ul>
</ul>
</div>

<h2 id="toc_1.1">总线相关的数据结构</h2>
<h3 id="toc_1.1.1">struct bus_type</h3>
<ul>
<li>
总线类型包含了总线属性(bus_attribute)、设备属性(device_attribute)、驱动属性(driver_attribute)。

<li>
总线类型还提供了一套处理设备操作的方法：

<ul>
<li>
match：任何时候，当一个新的设备或驱动被添加给这个总线，并且该设备可被该驱动处理，则返回非零值。

<li>
uevent：uevent事件处理。

<li>
probe：加载驱动时被调用。

<li>
remove：移除驱动时被调用。

<li>
shutdown：系统关闭时被调用。

<li>
suspend：系统休眠时被调用。

<li>
resume：系统唤醒时被调用。

</ul>
</ul>

<pre class="brush:c">
struct bus_type {
	const char		        *name;
	struct bus_attribute	*bus_attrs;
	struct device_attribute	*dev_attrs;
	struct driver_attribute	*drv_attrs;

	int (*match)(struct device *dev, struct device_driver *drv);
	int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
	int (*probe)(struct device *dev);
	int (*remove)(struct device *dev);
	void (*shutdown)(struct device *dev);

	int (*suspend)(struct device *dev, pm_message_t state);
	int (*resume)(struct device *dev);

	const struct dev_pm_ops *pm;

	struct bus_type_private *p;
};
</pre>

<h3 id="toc_1.1.2">sturct dev_pm_ops</h3>
<ul>
<li>
sturct dev_pm_ops结构包含了关于电源管理的一套回调函数。
<pre class="brush:c">
struct dev_pm_ops {
	int (*prepare)(struct device *dev);
	void (*complete)(struct device *dev);
	int (*suspend)(struct device *dev);
	int (*resume)(struct device *dev);
	int (*freeze)(struct device *dev);
	int (*thaw)(struct device *dev);
	int (*poweroff)(struct device *dev);
	int (*restore)(struct device *dev);
	int (*suspend_noirq)(struct device *dev);
	int (*resume_noirq)(struct device *dev);
	int (*freeze_noirq)(struct device *dev);
	int (*thaw_noirq)(struct device *dev);
	int (*poweroff_noirq)(struct device *dev);
	int (*restore_noirq)(struct device *dev);
	int (*runtime_suspend)(struct device *dev);
	int (*runtime_resume)(struct device *dev);
	int (*runtime_idle)(struct device *dev);
};
</pre>

</ul>

<h3 id="toc_1.1.3">struct bus_type_private</h3>
<ul>
<li>
最近的内核将一些底层驱动模型数据结构独立出来，生成了struct bus_type_private，其中包含了一组kset的列表。

<ul>
<li>
drivers_kset表示总线相关的驱动列表。

<li>
devices_kset表示接入到该总线的所有设备列表。
<pre class="brush:c">
struct bus_type_private {
	struct kset subsys;
	struct kset *drivers_kset;
	struct kset *devices_kset;
	struct klist klist_devices;
	struct klist klist_drivers;
	struct blocking_notifier_head bus_notifier;
	unsigned int drivers_autoprobe:1;
	struct bus_type *bus;
};
</pre>

</ul>
</ul>

<h2 id="toc_1.2">总线属性</h2>
<ul>
<li>
总线属于驱动模型的一层，同样具有它的属性，由struct bus_attribute来描述。

</ul>

<h3 id="toc_1.2.1">struct bus_attribute</h3>
<pre class="brush:c">
struct bus_attribute {
	struct attribute	attr;
	ssize_t (*show)(struct bus_type *bus, char *buf);
	ssize_t (*store)(struct bus_type *bus, const char *buf, size_t count);
};
</pre>

<h3 id="toc_1.2.2">BUS_ATTR辅助宏</h3>
<ul>
<li>
内核同样提供了一个宏来帮助创建总线属性结构，它使用了_ATTR宏，可参见其<a href="如何创建sysfs.html">如何创建sysfs</a>中的定义。
<pre class="brush:c">
#define BUS_ATTR(_name, _mode, _show, _store)	\
struct bus_attribute bus_attr_##_name = __ATTR(_name, _mode, _show, _store)
</pre>

</ul>

<h3 id="toc_1.2.3">创建总线属性</h3>
<ul>
<li>
<code>bus_create_file</code>用来创建一个对应总线属性的文件。

<li>
<code>bus_remove_file</code>用来移除一个对应总线属性的文件。

</ul>

<h2 id="toc_1.3">总线的注册和移除</h2>
<ul>
<li>
<code>bus_register</code>方法用来注册一个虚拟总线，通常需要给总线指定一个名称。

<li>
<code>bus_unregister</code>方法用来移除一个虚拟总线。

</ul>

<h3 id="toc_1.3.1">示例代码</h3>
<pre class="brush:c">
// 声明一个bus_type实例
struct bus_type ldd_bus_type = { 
    .name = "ldd", 
    .match = ldd_match,
};

// 注册一个总线的示例
int register_bus() {
    int ret = bus_register(&amp;ldd_bus_type);
    return ret;
}

// 移除一个总线的示例
void unregister_bus() {
    bus_unregister(&amp;ldd_bus_type);
}
</pre>

<h2 id="toc_1.4">列举设备和驱动</h2>
<ul>
<li>
内核提供了两个方法<code>bus_for_each_drv</code>和<code>bus_for_each_dev</code>来枚举一个虚拟总线上的所有驱动和设备。

</ul>


<footer>
    <a href="http://zenki2001cn.github.com/Wiki" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="zenki2001cn@163.com" id="back-email">Email</a>
</footer>

</article>
</div>

</body>
</html>
