<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>进程的描述</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <link rel="Stylesheet" type="text/css" href="../css_style/style_zenki.css">

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>

<!-- wrap the vimwiki html -->

<h1 id="toc_1">进程的描述</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">进程的描述</a>
<ul>
<li><a href="#toc_1.1">什么是进程</a>
<li><a href="#toc_1.2">Linux如何描述进程</a>
<ul>
<li><a href="#toc_1.2.1">struct task_struct</a>
<li><a href="#toc_1.2.2">struct thread_info</a>
<li><a href="#toc_1.2.3">current宏定义</a>
</ul>
<li><a href="#toc_1.3">进程的状态</a>
<li><a href="#toc_1.4">如何组织进程</a>
<ul>
<li><a href="#toc_1.4.1">等待队列的数据结构</a>
<li><a href="#toc_1.4.2">等待队列的操作</a>
</ul>
<li><a href="#toc_1.5">进程资源限制</a>
<ul>
<li><a href="#toc_1.5.1">资源限制的数据结构</a>
<li><a href="#toc_1.5.2">资源限制的类型</a>
</ul>
<li><a href="#toc_1.6">Linux进程思维导图</a>
</ul>
</ul>
</div>

<h2 id="toc_1.1">什么是进程</h2>
<ul>
<li>
进程是程序执行时的一个实例，可以把它看作充分描述程序已经执行到何种程度的数据结构的汇集。

<li>
从内核观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的实体。

</ul>

<h2 id="toc_1.2">Linux如何描述进程</h2>

<h3 id="toc_1.2.1">struct task_struct</h3>
<ul>
<li>
Linux中描述进程的数据结构定义为task_struct，它包含了所有与进程相关的资源信息。

</ul>

<pre class="brush:c">
struct task_struct {
	volatile long state;	/* -1 unrunnable, 0 runnable, &gt;0 stopped */
	void *stack;
	
	struct list_head tasks;
	struct mm_struct *mm, *active_mm;
	
	struct task_struct *parent;         /* recipient of SIGCHLD, wait4() reports */
	struct list_head children;	        /* list of my children */
	struct list_head sibling;	        /* linkage in my parent's children list */
	struct task_struct *group_leader;	/* threadgroup leader */

    int exit_state;
	int exit_code, exit_signal;
	
    struct fs_struct *fs;
    /* open file information */
	struct files_struct *files;
    /* namespaces */
	struct nsproxy *nsproxy;
    /* signal handlers */
	struct signal_struct *signal;
	struct sighand_struct *sighand;
	
    ......
}
</pre>

<h3 id="toc_1.2.2">struct thread_info</h3>
<ul>
<li>
thread_info结构表示线程描述符，用来保存进程相关信息，包括进程描述符指针。

</ul>

<pre class="brush:c">
struct thread_info {
	struct pcb_struct	pcb;		/* palcode state */

	struct task_struct	*task;		/* main task structure */
	unsigned int		flags;		/* low level flags */
	unsigned int		ieee_state;	/* see fpu.h */

	struct exec_domain	*exec_domain;	/* execution domain */
	mm_segment_t		addr_limit;	    /* thread address space */
	unsigned		    cpu;		    /* current CPU */
	int			        preempt_count;  /* 0 =&gt; preemptable, &lt;0 =&gt; BUG */

	int bpt_nsaved;
	unsigned long bpt_addr[2];		    /* breakpoint handling  */
	unsigned int bpt_insn[2];

	struct restart_block	restart_block;
};

/*
 * Macros/functions for gaining access to the thread information structure.
 */
#define INIT_THREAD_INFO(tsk)			    \
{						                    \
	.task		= &amp;tsk,			            \
	.exec_domain	= &amp;default_exec_domain,	\
	.addr_limit	= KERNEL_DS,		        \
	.preempt_count	= INIT_PREEMPT_COUNT,	\
	.restart_block = {			            \
		.fn = do_no_restart_syscall,	    \
	},					                    \
}
</pre>

<h3 id="toc_1.2.3">current宏定义</h3>
<ul>
<li>
current宏定义用来获取当前进程描述符指针。

</ul>

<pre class="brush:c">
#define get_current()	(current_thread_info()-&gt;task)
#define current		    get_current()
</pre>

<h2 id="toc_1.3">进程的状态</h2>
<ul>
<li>
进程描述符中的state字段描述了进程当前所处的状态，这些状态是互斥的。可能的状态如下：

</ul>

<table>
<tr>
<th>
状态标识
</th>
<th>
描述
</th>
<th>
备注
</th>
</tr>
<tr>
<td>
TASK_RUNNING
</td>
<td>
进程要么在CPU上执行，要么准备执行
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
TASK_INTERRUPTIBLE
</td>
<td>
进程被挂起，直到某个条件为真被唤醒（如产生硬件中断、释放系统资源或传递一个信号）
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
TASK_UNINTERRUPTIBLE
</td>
<td>
进程被挂起，并且不能被信号唤醒
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
TASK_STOPPED
</td>
<td>
进程的执行被暂停
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
TASK_TRACED
</td>
<td>
进程的执行被debugger程序暂停
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
EXIT_ZOMBIE
</td>
<td>
进程的执行被终止，但是父进程还没有回收死亡进程的信息
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
EXIT_DEAD
</td>
<td>
死亡进程的信息被父进程回收，并且系统删除该进程
</td>
<td>
&nbsp;
</td>
</tr>
</table>

<h2 id="toc_1.4">如何组织进程</h2>
<ul>
<li>
Linux以链表的形式将不同状态的进程组织在一起。如运行队列链表包含了所有状态为TASK_RUNNING的进程。

</ul>

<h3 id="toc_1.4.1">等待队列的数据结构</h3>
<ul>
<li>
等待队列实现了在事件上的条件等待：希望等待特定事件的进程把自己放在合适的等待队列，并放弃控制权。

<li>
等待队列表示一组睡眠进程，当某一条件变为真时，由内核唤醒它们。

<li>
等待队列由双向链表实现，每个队列包含一个等待队列头，其中task_list成员指向wait_queue_t结构的链表。

</ul>

<pre class="brush:c">
struct __wait_queue_head {
	spinlock_t lock;
	struct list_head task_list;
};
typedef struct __wait_queue_head wait_queue_head_t;
</pre>

<ul>
<li>
等待队列的元素类型为wait_queu_t，其每个元素代表一个睡眠进程，task_list指向等待相同事件的进程链表。

</ul>

<pre class="brush:c">
struct __wait_queue {
	unsigned int flags;
#define WQ_FLAG_EXCLUSIVE	0x01
	void *private;
	wait_queue_func_t func;
	struct list_head task_list;
};
typedef struct __wait_queue wait_queue_t;
</pre>

<h3 id="toc_1.4.2">等待队列的操作</h3>
<ul>
<li>
定义等待队列和等待队列头

</ul>

<pre class="brush:c">
#define __WAITQUEUE_INITIALIZER(name, tsk) {		\
	.private	= tsk,						        \
	.func		= default_wake_function,			\
	.task_list	= { NULL, NULL } }

#define DECLARE_WAITQUEUE(name, tsk)					\
	wait_queue_t name = __WAITQUEUE_INITIALIZER(name, tsk)

#define __WAIT_QUEUE_HEAD_INITIALIZER(name) {			\
	.lock		= __SPIN_LOCK_UNLOCKED(name.lock),		\
	.task_list	= { &amp;(name).task_list, &amp;(name).task_list } }

#define DECLARE_WAIT_QUEUE_HEAD(name)                   \
	wait_queue_head_t name = __WAIT_QUEUE_HEAD_INITIALIZER(name)
</pre>

<ul>
<li>
操作等待队列的方法列表

</ul>

<table>
<tr>
<th>
方法名
</th>
<th>
描述
</th>
<th>
备注
</th>
</tr>
<tr>
<td>
sleep_on
</td>
<td>
将进程状态设置为TASK_UNINTERRUPTIBLE，并将它插入到特定等待队列
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
sleep_on_timeout
</td>
<td>
与sleep_on相似，但可以定义一个时间间隔，超时后由内核唤醒
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
interruptible_sleep_on
</td>
<td>
将进程状态设置为TASK_INTERRUPTIBLE，并将它插入到特定等待队列
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
interruptible_sleep_on_timeout
</td>
<td>
与interruptible_sleep_on相似，但可以定义一个时间间隔，超时后由内核唤醒
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
prepare_to_wait
</td>
<td>
设置进程为非互斥标志，并根据参数标识进程的状态
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
prepare_to_wait_exclusive
</td>
<td>
设置进程为互斥标志，并根据参数标识进程的状态
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
finish_wait
</td>
<td>
进程从prepare_to_wait或prepare_to_wait_exclusive唤醒后调用
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
wait_event
</td>
<td>
将进程状态设置为TASK_UNINTERRUPTIBLE，以条件变量为参数将进程挂起，并等待条件变为真
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
wait_event_interruptible
</td>
<td>
将进程状态设置为TASK_INTERRUPTIBLE，以条件变量为参数将进程挂起，并等待条件变为真
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
wake_up
</td>
<td>
唤醒TASK_UNINTERRUPTIBLE和TASK_INTERRUPTIBLE状态的进程
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
wake_up_interruptible
</td>
<td>
只唤醒TASK_INTERRUPTIBLE状态的进程
</td>
<td>
&nbsp;
</td>
</tr>
</table>

<h2 id="toc_1.5">进程资源限制</h2>
<ul>
<li>
每个进程都有一组相关的资源限制，限制指定了进程能使用的系统资源数量。这些限制避免用户过分使用系统资源（CPU、磁盘空间等）。

</ul>

<h3 id="toc_1.5.1">资源限制的数据结构</h3>
<ul>
<li>
资源限制存放在current-&gt;signal-&gt;rlim字段，即进程的信号描述符的一个字段。

<li>
rlim_cur字段表示当前资源限制的值，rlim_max表示最大值，可通过getrlimit()和setrlimit()系统调用调整资源最大值。

</ul>

<pre class="brush:c">
struct rlimit {
	unsigned long	rlim_cur;
	unsigned long	rlim_max;
};
</pre>

<h3 id="toc_1.5.2">资源限制的类型</h3>

<table>
<tr>
<th>
标识
</th>
<th>
描述
</th>
<th>
备注
</th>
</tr>
<tr>
<td>
RLIMIT_AS
</td>
<td>
进程地址空间的最大数
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
RLIMIT_CORE
</td>
<td>
内核信息转储文件的大小
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
RLIMIT_CPU
</td>
<td>
进程使用CPU的最长时间
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
RLIMIT_DATA
</td>
<td>
堆大小的最大值
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
RLIMIT_FSIZE
</td>
<td>
文件大小的最大值
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
RLIMIT_LOCKS
</td>
<td>
文件锁的最大值
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
RLIMIT_MEMLOCK
</td>
<td>
非交换内存的最大值
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
RLIMIT_MSGQUEUE
</td>
<td>
POSIX消息队列中的最大值
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
RLIMIT_NOFILE
</td>
<td>
打开文件描述符的最大数
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
RLIMIT_NPROC
</td>
<td>
用户能拥有的进程最大数
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
RLIMIT_RSS
</td>
<td>
进程所拥有的页框最大数
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
RLIMIT_SIGPENDING
</td>
<td>
进程挂起信号的最大数
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
RLIMIT_STACK
</td>
<td>
栈大小的最大数
</td>
<td>
&nbsp;
</td>
</tr>
</table>

<h2 id="toc_1.6">Linux进程思维导图</h2>
<p>
<img src="http:pic/Linux进程.png" />
</p>


<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

</body>
</html>
