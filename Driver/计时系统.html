<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>计时系统</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <link rel="Stylesheet" type="text/css" href="../css_style/style_zenki.css">

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>

<!-- wrap the vimwiki html -->

<h1 id="toc_1">计时系统</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">计时系统</a>
<ul>
<li><a href="#toc_1.1">相关文件</a>
<li><a href="#toc_1.2">时钟和定时器</a>
<li><a href="#toc_1.3">Linux计时体系</a>
<ul>
<li><a href="#toc_1.3.1">jiffies变量</a>
<li><a href="#toc_1.3.2">xtime变量</a>
<li><a href="#toc_1.3.3">获取当前时间</a>
<li><a href="#toc_1.3.4">单处理器的计时体系</a>
<li><a href="#toc_1.3.5">多处理器的计时体系</a>
</ul>
<li><a href="#toc_1.4">计时系统的功能</a>
<ul>
<li><a href="#toc_1.4.1">更新时间和日期</a>
<li><a href="#toc_1.4.2">更新系统统计数</a>
<li><a href="#toc_1.4.3">记录系统负载</a>
<li><a href="#toc_1.4.4">监管内核代码</a>
</ul>
<li><a href="#toc_1.5">软定时器和延迟函数</a>
<ul>
<li><a href="#toc_1.5.1">动态定时器对象链表</a>
<li><a href="#toc_1.5.2">保存动态定时器对象</a>
<li><a href="#toc_1.5.3">动态定时器处理</a>
<li><a href="#toc_1.5.4">延迟函数</a>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">相关文件</h2>
<pre class="brush:c">
#include &lt;linux/jiffies.h&gt;
#include &lt;linux/time.h&gt;
#include &lt;linux/delay.h&gt;
</pre>

<h2 id="toc_1.2">时钟和定时器</h2>
<ul>
<li>
80x86体系上的几种定时器如下：

</ul>

<table>
<tr>
<th>
类型
</th>
<th>
说明
</th>
<th>
备注
</th>
</tr>
<tr>
<td>
实时时钟(RTC)
</td>
<td>
独立于CPU和其他芯片的实时时钟，Linux通过RTC来获取时间和日期
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
时间戳计数器(TSC)
</td>
<td>
根据外部震荡器的时钟信号累加一个计数器，并利用64位的时间戳计数器来实现计数
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
可编程间隔定时器(PIT)
</td>
<td>
该定时器以大约1000HZ的频率向IRQ0发出时钟中断，即每1ms产生一次时钟中断
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
CPU本地定时器
</td>
<td>
16位的CPU本地定时器，并且只和自身的CPU相关联
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
高精度事件定时器(HPET)
</td>
<td>
更高精度的硬定时器，频率至少为10MHZ
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
电源管理定时器(ACPI)
</td>
<td>
频率大约为3.58MHZ定时器，内核通过某个I/O端口读取计数器的当前值
</td>
<td>
&nbsp;
</td>
</tr>
</table>

<h2 id="toc_1.3">Linux计时体系</h2>
<ul>
<li>
内核会周期性的执行以下动作：

<ul>
<li>
更新自系统启动以来所经过的时间。

<li>
更新时间和日期。

<li>
确定当前进程在每个CPU上已运行了多长时间，如果超过了分配给它的时间，则抢占它。

<li>
更新资源使用计数。

<li>
检查每个软定时器的时间间隔是否已到。

</ul>
</ul>

<h3 id="toc_1.3.1">jiffies变量</h3>
<ul>
<li>
jiffies变量是一个计数器，用来记录自系统启动以来产生的节拍总数。

<li>
在80x86体系中，该变量被声明成一个32为整型，因此大约间隔50天后会回绕到0。内核通过time_after、time_after_eq、time_before、time_before_eq四个宏来处理变量的溢出。

</ul>

<pre class="brush:c">
// 宏定义
#define time_after(a,b)		        \
	(typecheck(unsigned long, a) &amp;&amp; \
	 typecheck(unsigned long, b) &amp;&amp; \
	 ((long)(b) - (long)(a) &lt; 0))
#define time_before(a,b)	time_after(b,a)

#define time_after_eq(a,b)	        \
	(typecheck(unsigned long, a) &amp;&amp; \
	 typecheck(unsigned long, b) &amp;&amp; \
	 ((long)(a) - (long)(b) &gt;= 0))
#define time_before_eq(a,b)	time_after_eq(b,a)

// 获取流逝的时间
unsigned long j, stamp_1, stamp_half, stamp_n;

j = jiffies;                    // 当前jiffies
stamp_1 = j + HZ;               // 1秒后的jiffies
stamp_half = j + HZ/2;          // 0.5秒后的jiffies
stamp_n = j + n * HZ / 1000;    // n毫秒后的jiffies
</pre>

<h3 id="toc_1.3.2">xtime变量</h3>
<ul>
<li>
xtime变量存放当前时间和日期，它是一个timespec类型的数据结构。

<li>
xtime变量通常是每个节拍更新一次，大约每秒更新1000次。

<li>
xtime_lock防止同时访问所造成的竞争条件，它同时也保护jiffies变量。

</ul>

<pre class="brush:c">
struct timespec {
	__kernel_time_t	tv_sec;			/* seconds */
	long		    tv_nsec;		/* nanoseconds */
};

extern struct timespec xtime;
extern seqlock_t xtime_lock;

// timespec类型与jiffies的转换
unsigned long timespec_to_jiffies(struct timespec *value);
void jiffies_to_timespec(unsigned long jiffies, struct timespec *value);
unsigned long timeval_to_jiffies(struct timeval *value);
void jiffies_to_timeval(unsigned long jiffies, struct timeval *value);
</pre>

<h3 id="toc_1.3.3">获取当前时间</h3>
<pre class="brush:c">
#include &lt;linux/time.h&gt;
unsigned long mktime(unsigned int year, unsigned int mon,
                     unsigned int day, unsigned int hour,
                     unsigned int min, unsigned int sec);
void do_gettimeofday(struct timeval *tv);
struct timespec current_kernel_time(void);
</pre>

<h3 id="toc_1.3.4">单处理器的计时体系</h3>
<ul>
<li>
单处理器系统上，所有与定时有关的活动都是由IRQ0的可编程定时器产生的中断触发的。

<li>
time_init初始化计时系统

</ul>

<pre class="brush:c">
/*
 * This is called directly from init code; we must delay timer setup in the
 * HPET case as we can't make the decision to turn on HPET this early in the
 * boot process.
 *
 * The chosen time_init function will usually be hpet_time_init, above, but
 * in the case of virtual hardware, an alternative function may be substituted.
 */
void __init time_init(void)
{
    pre_time_init_hook();
    tsc_init();
    late_time_init = choose_time_init();
}
</pre>

<ul>
<li>
timer_interrupt处理时钟中断服务。

</ul>

<pre class="brush:c">
/*
 * Default timer interrupt handler for PIT/HPET
 */
static irqreturn_t timer_interrupt(int irq, void *dev_id)
{
	/* Keep nmi watchdog up to date */
	inc_irq_stat(irq0_irqs);

	/* Optimized out for !IO_APIC and x86_64 */
	if (timer_ack) {
		/*
		 * Subtle, when I/O APICs are used we have to ack timer IRQ
		 * manually to deassert NMI lines for the watchdog if run
		 * on an 82489DX-based system.
		 */
		raw_spin_lock(&amp;i8259A_lock);
		outb(0x0c, PIC_MASTER_OCW3);
		/* Ack the IRQ; AEOI will end it automatically. */
		inb(PIC_MASTER_POLL);
		raw_spin_unlock(&amp;i8259A_lock);
	}

	global_clock_event-&gt;event_handler(global_clock_event);

	/* MCA bus quirk: Acknowledge irq0 by setting bit 7 in port 0x61 */
	if (MCA_bus)
		outb_p(inb_p(0x61)| 0x80, 0x61);

	return IRQ_HANDLED;
}
</pre>

<h3 id="toc_1.3.5">多处理器的计时体系</h3>
<ul>
<li>
多处理器系统可以依赖两种不同的时钟中断源：

<ul>
<li>
可编程间隔定时器或高精度事件定时器

<li>
CPU本地定时器

</ul>
<li>
time_init初始化计时系统(同单处理系统)

<li>
apic_intr_init初始化本地定时器

</ul>

<pre class="brush:c">
static void __init apic_intr_init(void)
{
    smp_intr_init();

    alloc_intr_gate(THERMAL_APIC_VECTOR, thermal_interrupt);
    alloc_intr_gate(THRESHOLD_APIC_VECTOR, threshold_interrupt);

    /* self generated IPI for local APIC timer */
    alloc_intr_gate(LOCAL_TIMER_VECTOR, apic_timer_interrupt);

    /* IPI vectors for APIC spurious and error interrupts */
    alloc_intr_gate(SPURIOUS_APIC_VECTOR, spurious_interrupt);
    alloc_intr_gate(ERROR_APIC_VECTOR, error_interrupt);
}
</pre>

<h2 id="toc_1.4">计时系统的功能</h2>
<h3 id="toc_1.4.1">更新时间和日期</h3>
<ul>
<li>
用户程序从xtime变量中获得当前时间和日期。内核必须周期性的更新该变量，才能使它的值保持相当的精确。

<li>
update_times更新xtime变量。

</ul>

<pre class="brush:c">
static inline void update_times(unsigned long ticks)
{
    update_wall_time();
    calc_load(ticks);
}
</pre>

<h3 id="toc_1.4.2">更新系统统计数</h3>
<ul>
<li>
通过update_process_times检查运行进程的CPU资源限制

</ul>

<pre class="brush:c">
void update_process_times(int user_tick)
{
	struct task_struct *p = current;
	int cpu = smp_processor_id();

	account_process_tick(p, user_tick);
	run_local_timers();
	rcu_check_callbacks(cpu, user_tick);
	printk_tick();
	perf_event_do_pending();
	scheduler_tick();
	run_posix_cpu_timers(p);
}
</pre>

<h3 id="toc_1.4.3">记录系统负载</h3>
<ul>
<li>
通过calc_load记录系统进行了多少CPU活动

</ul>

<pre class="brush:c">
static inline void calc_load(unsigned long ticks)
{
    unsigned long active_tasks; /* fixed-point */
    static int count = LOAD_FREQ;

    count -= ticks;
    if (unlikely(count &lt; 0)) {
        active_tasks = count_active_tasks();
        do {
            CALC_LOAD(avenrun[0], EXP_1, active_tasks);
            CALC_LOAD(avenrun[1], EXP_5, active_tasks);
            CALC_LOAD(avenrun[2], EXP_15, active_tasks);
            count += LOAD_FREQ;
        } while (count &lt; 0);
    }
}
</pre>

<h3 id="toc_1.4.4">监管内核代码</h3>
<ul>
<li>
通过profile_tic为代码监管器采集数据

</ul>

<pre class="brush:c">
void profile_tick(int type)
{
        struct pt_regs *regs = get_irq_regs();

        if (type == CPU_PROFILING &amp;&amp; timer_hook)
                timer_hook(regs);
        if (!user_mode(regs) &amp;&amp; prof_cpu_mask != NULL &amp;&amp;
            cpumask_test_cpu(smp_processor_id(), prof_cpu_mask))
                profile_hit(type, (void *)profile_pc(regs));
}
</pre>

<h2 id="toc_1.5">软定时器和延迟函数</h2>
<ul>
<li>
Linux包含两种类型的定时器：动态定时器和间隔定时器。第一种类型由内核使用，第二种由进程在用户态创建。

<li>
对定时器的检查总是由可延迟函数进行，因此内核不确保定时器函数正好在定时器到期时执行，而只能保证在适当的时间执行它们。

</ul>

<h3 id="toc_1.5.1">动态定时器对象链表</h3>
<ul>
<li>
timer_list结构用来保存定时器对象数据

</ul>

<pre class="brush:c">
struct timer_list {
    /*
     * All fields that change during normal runtime grouped to the
     * same cacheline
     */
    struct list_head entry;         // 定时器链表
    unsigned long expires;          // 到期时间
    struct tvec_base *base;

    void (*function)(unsigned long);// 定时器函数
    unsigned long data;             // 附加数据

    int slack;

#ifdef CONFIG_TIMER_STATS
    int start_pid;
    void *start_site;
    char start_comm[16];
#endif
#ifdef CONFIG_LOCKDEP
    struct lockdep_map lockdep_map;
#endif
};
</pre>

<ul>
<li>
通过宏init_timer来初始化timer_list对象

</ul>

<pre class="brush:c">
#define init_timer(timer)                       \
do {                                            \
    static struct lock_class_key __key;         \
    init_timer_key((timer), #timer, &amp;__key);    \
} while (0)
</pre>

<ul>
<li>
通过add_timer来添加定时器对象

</ul>

<pre class="brush:c">
void add_timer(struct timer_list *timer)
{
    BUG_ON(timer_pending(timer));
    mod_timer(timer, timer-&gt;expires);
}
EXPORT_SYMBOL(add_timer);
</pre>

<ul>
<li>
通过mod_timer修改定时器对象

</ul>

<pre class="brush:c">
int mod_timer(struct timer_list *timer, unsigned long expires)
{
    expires = apply_slack(timer, expires);

    /*
     * This is a common optimization triggered by the
     * networking code - if the timer is re-modified
     * to be the same thing then just return:
     */
    if (timer_pending(timer) &amp;&amp; timer-&gt;expires == expires)
        return 1;

    return __mod_timer(timer, expires, false, TIMER_NOT_PINNED);
}
EXPORT_SYMBOL(mod_timer);
</pre>

<ul>
<li>
通过del_timer删除已定义的定时器对象

</ul>

<pre class="brush:c">
int del_timer(struct timer_list *timer)
{
    struct tvec_base *base;
    unsigned long flags;
    int ret = 0;

    timer_stats_timer_clear_start_info(timer);
    if (timer_pending(timer)) {
        base = lock_timer_base(timer, &amp;flags);
        if (timer_pending(timer)) {
            detach_timer(timer, 1);
            if (timer-&gt;expires == base-&gt;next_timer &amp;&amp;
                !tbase_get_deferrable(timer-&gt;base))
                base-&gt;next_timer = base-&gt;timer_jiffies;
            ret = 1;
        }
        spin_unlock_irqrestore(&amp;base-&gt;lock, flags);
    }

    return ret;
}
EXPORT_SYMBOL(del_timer);
</pre>

<h3 id="toc_1.5.2">保存动态定时器对象</h3>
<ul>
<li>
tvec_t_base_s结构的每CPU变量类型用来保存定时器对象链表。在多处理器系统中活动的动态定时器集合被分配到各个不同的CPU中。

</ul>

<pre class="brush:c">
struct tvec_base {
    spinlock_t lock;
    struct timer_list *running_timer;
    unsigned long timer_jiffies;
    unsigned long next_timer;
    struct tvec_root tv1;
    struct tvec tv2;
    struct tvec tv3;
    struct tvec tv4;
    struct tvec tv5;
}
</pre>

<h3 id="toc_1.5.3">动态定时器处理</h3>
<ul>
<li>
通过run_timer_softirq方法检测并触发动态定时器，该方法是与TIMER_SOFTIRQ软中断请求相关的可延迟函数。

</ul>

<pre class="brush:c">
static void run_timer_softirq(struct softirq_action *h)
{
    struct tvec_base *base = __this_cpu_read(tvec_bases);

    hrtimer_run_pending();

    if (time_after_eq(jiffies, base-&gt;timer_jiffies))
        __run_timers(base);
}
</pre>

<ul>
<li>
__run_timers遍历动态定时器链表，并执行定时器对象的方法:

<ul>
<li>
首先要禁用本地中断

<li>
第一个循环遍历保存定时器对象的链表，检测定时器是否到期

<li>
第二个循环遍历定时器对象集合，并依次执行定时器方法

<li>
将到期定时器对象置空。

<li>
启用本地中断

</ul>
</ul>

<pre class="brush:c">
static inline void __run_timers(struct tvec_base *base)
{
	struct timer_list *timer;

	spin_lock_irq(&amp;base-&gt;lock);
	while (time_after_eq(jiffies, base-&gt;timer_jiffies)) {
		struct list_head work_list;
		struct list_head *head = &amp;work_list;
		int index = base-&gt;timer_jiffies &amp; TVR_MASK;

		/*
		 * Cascade timers:
		 */
		if (!index &amp;&amp;
			(!cascade(base, &amp;base-&gt;tv2, INDEX(0))) &amp;&amp;
				(!cascade(base, &amp;base-&gt;tv3, INDEX(1))) &amp;&amp;
					!cascade(base, &amp;base-&gt;tv4, INDEX(2)))
			cascade(base, &amp;base-&gt;tv5, INDEX(3));
			
		++base-&gt;timer_jiffies;
		list_replace_init(base-&gt;tv1.vec + index, &amp;work_list);
		while (!list_empty(head)) {
			void (*fn)(unsigned long);
			unsigned long data;

			timer = list_first_entry(head, struct timer_list,entry);
			fn = timer-&gt;function;
			data = timer-&gt;data;

			timer_stats_account_timer(timer);

			set_running_timer(base, timer);
			detach_timer(timer, 1);

			spin_unlock_irq(&amp;base-&gt;lock);
			call_timer_fn(timer, fn, data);
			spin_lock_irq(&amp;base-&gt;lock);
		}
	}
	set_running_timer(base, NULL);
	spin_unlock_irq(&amp;base-&gt;lock);
}
</pre>

<h3 id="toc_1.5.4">延迟函数</h3>
<ul>
<li>
当内核需要一个较短的时间间隔，比如几毫秒，就无需使用定时器。内核会将间隔的时间转换为loops数，并执行一个紧凑的loops次循环来达到延迟的目的。

</ul>
<table>
<tr>
<th>
方法名
</th>
<th>
说明
</th>
<th>
备注
</th>
</tr>
<tr>
<td>
udelay
</td>
<td>
微秒级的延迟，参数为延迟时间
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
ndelay
</td>
<td>
纳秒级的延迟，参数为延迟时间
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
msleep
</td>
<td>
微秒级的延迟，参数为延迟时间
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
ssleep
</td>
<td>
秒级的延迟，参数为延迟时间
</td>
<td>
&nbsp;
</td>
</tr>
</table>


<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

</body>
</html>
