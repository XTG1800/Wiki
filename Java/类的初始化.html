<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>类的初始化</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <link rel="Stylesheet" type="text/css" href="../css_style/style_zenki.css">

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>

<!-- wrap the vimwiki html -->

<h1 id="toc_1">类的初始化</h1>

<h2 id="toc_1.1">类的生命周期</h2>
<p>
<img src="http:pic/class_init.jpg" />
</p>

<h2 id="toc_1.2">类初始化</h2>
<pre class="brush:text">
类"初始化"阶段，它是一个类或接口被首次使用的前阶段中的最后一项工作，本阶段负责为类变量赋予正确的初始值。

Java编译器把所有的类变量初始化语句和类型的静态初始化器通通收集到&lt;clinit&gt;方法内，该方法只能被Jvm调用，专门承担初始化工作。
除接口以外，初始化一个类之前必须保证其直接超类已被初始化，并且该初始化过程是由Jvm保证线程安全的。另外，
并非所有的类都会拥有一个&lt;clinit&gt;()方法，在以下条件中该类不会拥有&lt;clinit&gt;()方法：
</pre>

<ul>
<li>
该类既没有声明任何类变量，也没有静态初始化语句；

<li>
该类声明了类变量，但没有明确使用类变量初始化语句或静态初始化语句初始化；

<li>
该类仅包含静态 final 变量的类变量初始化语句，并且类变量初始化语句是编译时常量表达式。

</ul>

<h2 id="toc_1.3">对象初始化</h2>
<pre class="brush:text">
在类被装载、连接和初始化，这个类就随时都可能使用了。对象实例化和初始化是就是对象生命的起始阶段的活动，
在这里我们主要讨论对象的初始化工作的相关特点。

Java编译器在编译每个类时都会为该类至少生成一个实例初始化方法--即"&lt;init&gt;()"方法。此方法与源代码中的每个构造方法相对应，
如果类没有明确地声明任何构造方法，编译器则为该类生成一个默认的无参构造方法，这个默认的构造器仅仅调用父类的无参构造器，
与此同时也会生成一个与默认构造方法对应的"&lt;init&gt;()"方法。

通常来说，&lt;init&gt;()方法内包括的代码内容大概为：调用另一个&lt;init&gt;()方法；对实例变量初始化；与其对应的构造方法内的代码。
如果构造方法是明确地从调用同一个类中的另一个构造方法开始，那它对应的&lt;init&gt;()方法体内包括的内容为：一个对本类的&lt;init&gt;()方法的调用；
对应用构造方法内的所有字节码。
如果构造方法不是通过调用自身类的其它构造方法开始，并且该对象不是Object对象，那&lt;init&gt;()法内则包括的内容为：一个对父类&lt;init&gt;()
方法的调用；对实例变量初始化方法的字节码；最后是对应构造子的方法体字节码。

如果这个类是Object，那么它的&lt;init&gt;()方法则不包括对父类&lt;init&gt;()方法的调用。
</pre>

<h2 id="toc_1.4">类的初始化时机</h2>
<pre class="brush:text">
本文到目前为止，我们已经大概有了解到了类生命周期中都经历了哪些阶段，但这个类的生命周期的开始阶段——
类装载又是在什么时候被触发呢？类又是何时被初始化的呢？让我们带着这三个疑问继续去寻找答案。

Java虚拟机规范为类的初始化时机做了严格定义："initialize on first active use"——"在首次主动使用时初始化"。
这个规则直接影响着类装载、连接和初始化类的机制——因为在类型被初始化之前它必须已经被连接，然而在连接之前又必须保证它已经被装载了。

在与初始化时机相关的类装载时机问题上，Java 虚拟机规范并没有对其做严格的定义，这就使得JVM在实现上可以根据自己的特点提供采用不同的装载策略。
我们可以思考一下Jboss AOP框架的实现原理，它就是在对你的class文件装载环节做了手脚——插入了AOP的相关拦截字节码，
这使得它可以对程序员做到完全透明化，哪怕你用new操作符创建出的对象实例也一样能被AOP框架拦截--与之相对应的 Spring AOP，
你必须通过他的BeanFactory获得被AOP代理过的受管对象，当然Jboss AOP的缺点也很明显——他是和JBOSS服务器绑定很紧密的，
你不能很轻松的移植到其它服务器上。

类的初始化时机就是在"在首次主动使用时"。那么，哪些情形下才符合首次主动使用的要求呢？
</pre>

<h3 id="toc_1.4.1">首次主动使用的情形</h3>
<ul>
<li>
<code>创建某个类的新实例时</code>：new、反射、克隆或反序列化

<li>
<code>调用某个类的静态方法时</code>

<li>
<code>使用某个类或接口的静态字段或对该字段赋值时（final字段除外）</code>

<li>
<code>调用Java的某些反射方法时</code>

<li>
<code>初始化某个类的子类时</code>

<li>
<code>在虚拟机启动时某个含有main()方法的那个启动类</code>

</ul>
<blockquote>
除了以上几种情形以外，所有其它使用JAVA类型的方式都是被动使用的，他们不会导致类的初始化。
</blockquote>

<h2 id="toc_1.5">类的初始化顺序</h2>
<pre class="brush:text">
类的初始化顺序依次是(静态变量、静态初始化块) &gt; (变量、初始化块) &gt; 构造器
</pre>

<h3 id="toc_1.5.1">单个类的初始化</h3>
<ul>
<li>
静态变量

<li>
静态初始化块

<li>
变量

<li>
初始化块

<li>
构造器

</ul>

<h3 id="toc_1.5.2">继承类的初始化</h3>
<ul>
<li>
父类--静态变量

<li>
父类--静态初始化块

<li>
子类--静态变量

<li>
子类--静态初始化块

<li>
父类--变量

<li>
父类--初始化块

<li>
父类--构造器

<li>
子类--变量

<li>
子类--初始化块

<li>
子类--构造器

</ul>


<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

</body>
</html>
