<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>内置命令</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
	<link type="text/css" rel="stylesheet" href="css_style/style_zenki.css"/>

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>


<h1 id="toc_1">内置命令</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">内置命令</a></li>
<ul>
<li><a href="#toc_1.1">内置命令</a></li>
<ul>
<li><a href="#toc_1.1.1">echo</a></li>
<li><a href="#toc_1.1.2">printf</a></li>
<li><a href="#toc_1.1.3">read</a></li>
<li><a href="#toc_1.1.4">pushd</a></li>
<li><a href="#toc_1.1.5">popd</a></li>
<li><a href="#toc_1.1.6">dirs</a></li>
<li><a href="#toc_1.1.7">let</a></li>
<li><a href="#toc_1.1.8">eval</a></li>
<li><a href="#toc_1.1.9">set</a></li>
<li><a href="#toc_1.1.10">unset</a></li>
<li><a href="#toc_1.1.11">export</a></li>
<li><a href="#toc_1.1.12">getopts</a></li>
<li><a href="#toc_1.1.13">source和.(点命令)</a></li>
<li><a href="#toc_1.1.14">exit</a></li>
<li><a href="#toc_1.1.15">exec</a></li>
<li><a href="#toc_1.1.16">caller</a></li>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">内置命令</h2>
<h3 id="toc_1.1.1">echo</h3>
<dl>
<dt>描述 </dt>
<dd>打印(到stdout)一个表达式或变量。</dd>
<dt>示例 </dt>
</dl>
<pre class="brush:bash">
if echo "$VAR" | grep -q txt        #if [[ $VAR = *txt* ]]
then
    echo "$VAR contains the substring sequence \"txt\""
fi
</pre>

<h3 id="toc_1.1.2">printf</h3>
<dl>
<dt>描述 </dt>
<dd>printf命令，格式化输出，是echo命令的增强。它是C语言printf()库函数的一个有限的变形。</dd>
<dt>示例 </dt>
</dl>
<pre class="brush:bash">
PI=3.14159265358979

printf "Pi to 2 decimal places = %1.2f" $PI
printf "Pi to 9 decimal places = %1.9f" $PI
</pre>

<h3 id="toc_1.1.3">read</h3>
<dl>
<dt>描述 </dt>
<dd>从stdin中读取一个变量的值，也就是与键盘交互取得变量的值。使用-a参数可以取得数组。</dd>
<dt>示例 </dt>
</dl>
<pre class="brush:bash">
# 从标准输入流中读取
read var1       # 注意在 var1 前面没有'$',因为变量正在被设置.
echo "var1 = $var1"

# 从文件逐行读取
while read line
do
    echo "$line"
done &lt; data-file
</pre>

<h3 id="toc_1.1.4">pushd</h3>
<dl>
<dt>描述 </dt>
<dd>把路径dir-name压入目录栈，同时修改当前目录到dir-name。</dd>
</dl>

<h3 id="toc_1.1.5">popd</h3>
<dl>
<dt>描述 </dt>
<dd>将目录栈中最上边的目录弹出,同时修改当前目录到弹出来的那个目录。</dd>
</dl>

<h3 id="toc_1.1.6">dirs</h3>
<dl>
<dt>描述 </dt>
<dd>列出所有目录栈的内容(与$DIRSTACK 便两相比较)。一个成功的pushd或者popd将会自动的调用dirs命令。</dd>
</dl>

<h3 id="toc_1.1.7">let</h3>
<dl>
<dt>描述 </dt>
<dd>let命令将执行变量的算术操作。在许多情况下，它被看作是复杂的expr版本的一个简化版。</dd>
<dt>示例 </dt>
</dl>
<pre class="brush:bash">
et a=11                 # 与'a=11'相同
let a=a+5               # 等价于let "a = a + 5"
                        # (双引号和空格是这句话更具可读性.)
echo "11 + 5 = $a"
</pre>

<h3 id="toc_1.1.8">eval</h3>
<dl>
<dt>描述 </dt>
<dd>将表达式中的参数，或者表达式列表，组合起来，并且评估它们。包含在表达式中的任何变量都将被扩展。结果将会被转化到命令中，这对于从命令行或者脚本中产生代码是很有用的。</dd>
<dt>示例 </dt>
</dl>
<pre class="brush:bash">
y="eval ls -l"          # 与y=`ls -l`很相似
echo $y
</pre>

<h3 id="toc_1.1.9">set</h3>
<dl>
<dt>描述 </dt>
<dd>set命令用来修改内部脚本变量的值。一个作用就是触发选项标志位来帮助决定脚本的行为。另一个应用就是以一个命令的结果(set <code>command</code>)来重新设置脚本的位置参数，脚本将会从命令的输出中重新分析出位置参数。</dd>
<dt>示例 </dt>
</dl>
<pre class="brush:bash">
set `uname -a`          # 把`uname -a`的命令输出设置

# $1, $2, $3, 等等，这些位置参数将被重新初始化为`uname -a`的结果
echo "Field #1 of 'uname -a' = $1"
echo "Field #2 of 'uname -a' = $2"
echo "Field #3 of 'uname -a' = $3"
</pre>

<h3 id="toc_1.1.10">unset</h3>
<dl>
<dt>描述 </dt>
<dd>unset命令用来删除一个shell变量，效果就是把这个变量设为null。注意:这个命令对位置参数无效。</dd>
<dt>示例 </dt>
</dl>
<pre class="brush:bash">
variable=hello          # 初始化
echo "variable = $variable"

unset variable          # Unset
                        # 与variable= 的效果相同
echo "(unset) variable = $variable"     # $variable设为null
</pre>

<h3 id="toc_1.1.11">export</h3>
<dl>
<dt>描述 </dt>
<dd>export命令将会使得被export的变量在运行的脚本(或shell)的所有的子进程中都可用。不幸的是，没有办法将变量export到父进程(就是调用这个脚本或shell的进程)中。</dd>
</dl>

<h3 id="toc_1.1.12">getopts</h3>
<dl>
<dt>描述 </dt>
<dd>可以说这是分析传递到脚本的命令行参数的最强力工具。这个命令与getopt外部命令,和C语言中的库函数getopt的作用是相同的。它允许传递和连接多个选项[2]到脚本中，并能分配多个参数到脚本中。</dd>
<dt>功能说明 </dt>
</dl>
<pre class="brush:text">
    getopts结构使用两个隐含变量:$OPTIND是参数指针(选项索引)和$OPTARG(选项参数)(可选的)，可以在选项后边附加一个参数。
在声明标签中，选项名后边的冒号用来提示这个选项名已经分配了一个参数。getopts结构通常都组成一组放在一个while循环中，
循环过程中每次处理一个选项和参数，然后增加隐含变量$OPTIND的值，再进行下一次的处理。
    注意: 
    1.通过命令行传递到脚本中的参数前边必须加上一个减号(-)。这是一个前缀，这样getopts命令将会认为这个参数是一个选项。
事实上，getopts不会处理不带"-"前缀的参数，如果第一个参数就没有"-",那么将结束选项的处理。
    2.使用getopts的while循环模版还是与标准的while循环模版有些不同，没有标准while循环中的[]判断条件。
    3.getopts结构将会取代getopt外部命令。
</pre>
<dl>
<dt>示例 </dt>
</dl>
<pre class="brush:bash">
while getopts ":abcde:fg" Option
# Initial declaration.
# 开始的声明.
# a, b, c, d, e, f, 和 g 被认为是选项(标志).
# e选项后边的:提示,这个选项带一个参数.
do
    case $Option in
    a)          # Do something with variable 'a'.
    a)          # 对选项'a'作些操作.
    b)          # 对选项'b'作些操作.
    ...
    e)          # Do something with 'e', and also with $OPTARG,
    e)          # 对选项'e'作些操作, 同时处理一下$OPTARG,
                # which is the associated argument passed with option 'e'.
                # 这个变量里边将保存传递给选项"e"的参数.
    ...
    g)          # 对选项'g'作些操作.
    esac
done
shift $(($OPTIND - 1))      # 将参数指针向下移动.
</pre>

<h3 id="toc_1.1.13">source和.(点命令)</h3>
<dl>
<dt>描述 </dt>
<dd>这个命令在命令行上执行的时候，将会执行一个脚本。在一个文件内一个source file-name将会加载file-name文件。source一个文件(或点命令)将会在脚本中引入代码，并附加到脚本中(与C 语言中的#include指令的效果相同)。最终的结果就像是在使用"sourced"行上插入了相应文件的内容。这在多个脚本需要引用相同的数据，或函数库时非常有用。</dd>
</dl>

<h3 id="toc_1.1.14">exit</h3>
<dl>
<dt>描述 </dt>
<dd>绝对的停止一个脚本的运行。exit命令可以随便找一个整数变量作为退出脚本返回shell时的退出码，使用exit 0对于退出一个简单脚本来说是种好习惯，表明成功运行。注意: 如果不带参数的使用exit来退出，那么退出码将是脚本中最后一个命令的退出码，等价于exit $?。</dd>
</dl>

<h3 id="toc_1.1.15">exec</h3>
<dl>
<dt>描述 </dt>
<dd>这个shell内建命令将使用一个特定的命令来取代当前进程。一般的当shell遇到一个命令，它会fork off一个子进程来真正的运行命令。使用exec内建命令，shell就不会fork了，并且命令的执行将会替换掉当前shell。因此，当我们在脚本中使用它时，当命令实行完毕，它就会强制退出脚本。</dd>
<dt>示例 </dt>
</dl>
<pre class="brush:bash">
exec echo "Exiting \"$0\"." # 脚本将在此退出.

# 下边的部分将执行不到.
echo "This echo will never echo."
</pre>

<h3 id="toc_1.1.16">caller</h3>
<dl>
<dt>描述 </dt>
<dd>将caller命令放到函数中，将会在stdout上打印出函数调用者的信息。</dd>
<dt>示例 </dt>
</dl>
<pre class="brush:bash">
function1()
{
    # 在function1()内部
    caller 0
}
</pre>
<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

<!--<script type="text/javascript">-->
<!--var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");-->
<!--document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));-->
<!--</script>-->
<!--<script type="text/javascript">-->
<!--try {-->
<!--var pageTracker = _gat._getTracker("UA-15922433-1");-->
<!--pageTracker._trackPageview();-->
<!--} catch(err) {}-->
<!--</script>-->

</body>
</html>
