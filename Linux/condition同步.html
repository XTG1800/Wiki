<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>condition同步</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
	<link type="text/css" rel="stylesheet" href="css_style/style_zenki.css"/>

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>


<h1 id="toc_1">Condition同步</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">Condition同步</a></li>
<ul>
<li><a href="#toc_1.1">什么时候mutex不够，还需要condition?</a></li>
<ul>
<li><a href="#toc_1.1.1">add()版本一</a></li>
<li><a href="#toc_1.1.2">print()版本一</a></li>
</ul>
<li><a href="#toc_1.2">解决办法</a></li>
<ul>
<li><a href="#toc_1.2.1">PTHREAD_COND_INITIALIZER</a></li>
<li><a href="#toc_1.2.2">add()版本二</a></li>
<li><a href="#toc_1.2.3">print()版本二</a></li>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">什么时候mutex不够，还需要condition?</h2>
<ul>
<li>
什么时候mutex不够，还需要condition variable?假设有共享的资源sum，与之相关联的mutex是lock_s。假设每个线程对sum的操作很简单的，与sum的状态无关比如只是sum++。那么只用mutex足够了。程序员只要确保每个线程操作前，取得lock，然后sum++，再unlock即可。
</li>
<li>
线程的处理代码如下：
</li>
</ul>

<h3 id="toc_1.1.1">add()版本一</h3>
<pre class="brush:c">
// 线程t0,t1,t2
void add()
{
    pthread_mutex_lock(lock_s);
    sum++;
    pthread_mutex_unlock(lock_s);
}
</pre>

<ul>
<li>
如果操作比较复杂，假设线程t0，t1，t2的操作是sum++，而线程t3则是在sum到达100的时候，打印出一条信息，并对sum清零。这种情况下， 如果只用mutex， 则t3需要一个循环，每个循环里先取得lock_s，然后检查sum的状态，如果sum&gt;=100，则打印并清零，然后unlock。如果sum&lt;100，则unlock，并sleep()本线程合适的一段时间。
</li>
<li>
这种办法有两个问题：
</li>
<ul>
<li>
sum在大多数情况下不会到达100，那么对t3的代码来说，大多数情况下，走的是else分支，只是lock和unlock，然后sleep()。这浪费了CPU处理时间。
</li>
<li>
为了节省CPU处理时间，t3会在探测到sum没到达100的时候sleep()一段时间。这样却又带来另外一个问题，亦即t3响应速度下降。可能在sum到达200的时候，t3才会醒过来。
</li>
<li>
这样，程序员在设置sleep()时间的时候陷入两难境地，设置得太短了节省不了资源，太长了又降低响应速度。真是难办啊!
</li>
</ul>
</ul>

<h3 id="toc_1.1.2">print()版本一</h3>
<pre class="brush:c">
// 线程t3
void print()
{
    while (1) {
        pthread_mutex_lock(lock_s);
        
        if(sum &gt; 100) {
            printf(“sum reach 100!”);
            pthread_mutex_unlock(lock_s);
        } else {
            pthread_mutex_unlock(lock_s);
            my_thread_sleep(100);
            return OK;
        }
    }
}
</pre>

<h2 id="toc_1.2">解决办法</h2>
<ul>
<li>
首先定义一个condition variable。t0，t1，t2的代码只要后面加等待条件变量的方法。
</li>
<li>
这里需要注意两点:
</li>
<ul>
<li>
在thread_cond_wait()之前，必须先lock相关联的mutex， 因为假如目标条件未满足，pthread_cond_wait()实际上会<code>先unlock该mutex</code>， <code>然后block</code>，在<code>目标条件满足后</code>再<code>重新lock该mutex</code>， 然后返回。
</li>
<li>
为什么是while(sum&lt;100)，而不是if(sum&lt;100) ?这是因为在pthread_cond_signal()和pthread_cond_wait()返回之间，有时间差，假设在这个时间差内，还有另外一个线程t4又把sum减少到100以下了，那么t3在pthread_cond_wait()返回之后，显然应该再检查一遍sum的大小。这就是用while的用意。
</li>
</ul>
</ul>

<h3 id="toc_1.2.1">PTHREAD_COND_INITIALIZER</h3>
<pre class="brush:c">
pthread_cond_t cond_sum_ready = PTHREAD_COND_INITIALIZER;
</pre>

<h3 id="toc_1.2.2">add()版本二</h3>
<pre class="brush:c">
// 线程t0,t1,t2
void add()
{
    pthread_mutex_lock(lock_s);
    sum++;
    pthread_mutex_unlock(lock_s);
    
    if(sum &gt;= 100) {
        pthread_cond_signal(&amp;cond_sum_ready);   // 通知条件变量
    }
}
</pre>

<h3 id="toc_1.2.3">print()版本二</h3>
<pre class="brush:c">
// 线程t3
void print()
{
    pthread_mutex_lock(lock_s);
    while(sum &lt; 100) {
        pthread_cond_wait(&amp;cond_sum_ready, &amp;lock_s); // 条件变量被唤醒
    }
    
    printf(“sum is over 100!”);
    sum=0;
    pthread_mutex_unlock(lock_s);
    return OK;
}
</pre>
<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

<!--<script type="text/javascript">-->
<!--var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");-->
<!--document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));-->
<!--</script>-->
<!--<script type="text/javascript">-->
<!--try {-->
<!--var pageTracker = _gat._getTracker("UA-15922433-1");-->
<!--pageTracker._trackPageview();-->
<!--} catch(err) {}-->
<!--</script>-->

</body>
</html>
