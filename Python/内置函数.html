<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>内置函数</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <link rel="Stylesheet" type="text/css" href="../css_style/style_zenki.css">

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>

<!-- wrap the vimwiki html -->

<h1 id="toc_1">内置函数</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">内置函数</a>
<ul>
<li><a href="#toc_1.1">type和types（判断对象类型）</a>
<li><a href="#toc_1.2">global、globals（全局变量引用）和locals（局部变量引用）</a>
<li><a href="#toc_1.3">str（字符串转换）</a>
<li><a href="#toc_1.4">dir（获取对象方法列表）</a>
<li><a href="#toc_1.5">callable（判断方法是否可执行）</a>
<li><a href="#toc_1.6">isinstance（判断一个对象是否是类的实例）</a>
<li><a href="#toc_1.7">eval（执行字符串代码）</a>
<li><a href="#toc_1.8">enumerate（为list对象成员编号）</a>
<li><a href="#toc_1.9">getattr（获取对象的方法引用）</a>
<li><a href="#toc_1.10">lambda（匿名函数）</a>
<li><a href="#toc_1.11">__<em>import</em>__（动态导入模块）</a>
<li><a href="#toc_1.12">map（列表数据的批量处理）</a>
<li><a href="#toc_1.13">filter（列表数据过滤处理）</a>
<li><a href="#toc_1.14">reduce（列表数据递减处理）</a>
<li><a href="#toc_1.15">print（格式化打印输出）</a>
<li><a href="#toc_1.16">zip（数据扁平处理）</a>
<li><a href="#toc_1.17">repr（返回对象的字符串表示）</a>
<li><a href="#toc_1.18">with as（优雅的异常处理机制）</a>
<li><a href="#toc_1.19">property（将函数变成可访问的属性）</a>
</ul>
</ul>
</div>

<h2 id="toc_1.1">type和types（判断对象类型）</h2>
<ul>
<li>
type是内置方法，返回参数指定成员对象的类型。

<li>
types是一个类，该类包含了所有对象类型的定义。

</ul>

<pre class="brush:python">
&gt;&gt;&gt; type(1)           
&lt;type 'int'&gt;

&gt;&gt;&gt; li = []
&gt;&gt;&gt; type(li)          
&lt;type 'list'&gt;

&gt;&gt;&gt; import odbchelper
&gt;&gt;&gt; type(odbchelper)  
&lt;type 'module'&gt;

&gt;&gt;&gt; import types      
&gt;&gt;&gt; type(odbchelper) == types.ModuleType
True
</pre>

<h2 id="toc_1.2">global、globals（全局变量引用）和locals（局部变量引用）</h2>
<ul>
<li>
当一行代码要使用变量x的值时，Python会到所有可用的名字空间去查找变量，按照如下顺序：

<ul>
<li>
局部名字空间――特指当前函数或类的方法。如果函数定义了一个局部变量x，或一个参数x，Python将使用它，然后停止搜索。

<li>
全局名字空间――特指当前的模块。如果模块定义了一个名为x的变量，函数或类，Python将使用它然后停止搜索。

<li>
内置名字空间――对每个模块都是全局的。作为最后的尝试，Python将假设x是内置函数或变量。

</ul>
<li>
在Python中，函数内部的变量引用都被认为是局部变量，global修饰符用来引用全局变量。

<ul>
<li>
globals是内部方法，返回所有的全局变量定义，<code>该方法返回的值可以被修改</code>。

<li>
locals是内部方法，返回所有的局部变量定义，<code>该方法返回的值是只读的</code>。

</ul>
<li>
global用来修改一个变量名，使之成为全局变量。通过global修饰的外部变量，才能在函数内部被修改。

</ul>

<pre class="brush:python">
# 通过global修饰的变量引用，才能在函数内部修改。
G_VAR = 10

def show_global:
    global G_VAR

    G_VAR = 20
    print G_VAR

# 获取全局变量引用的方法
'''
globals(...)
    globals() -&gt; dictionary
    Return the dictionary containing the current scope's global variables.
'''

# 获取局部变量引用的方法
'''
locals(...)
    locals() -&gt; dictionary
    Update and return a dictionary containing the current scope's local variables.
'''
</pre>

<h2 id="toc_1.3">str（字符串转换）</h2>
<ul>
<li>
str将所有对象转换成一个字符串类型。

</ul>

<pre class="brush:python">
&gt;&gt;&gt; str(1)          
'1'
&gt;&gt;&gt; horsemen = ['war', 'pestilence', 'famine']
&gt;&gt;&gt; str(horsemen)   
"['war', 'pestilence', 'famine']"
&gt;&gt;&gt; str(odbchelper) 
"&lt;module 'odbchelper' from 'c:\\docbook\\dip\\py\\odbchelper.py'&gt;"
&gt;&gt;&gt; str(None)       
'None'
</pre>

<h2 id="toc_1.4">dir（获取对象方法列表）</h2>
<ul>
<li>
接收一个对象作为参数，返回该对象类型的方法列表。

</ul>

<pre class="brush:python">
# 列举list对象的成员
&gt;&gt;&gt; li = []
&gt;&gt;&gt; dir(li)           
['append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']

# 列举dict对象的成员
&gt;&gt;&gt; d = {}
&gt;&gt;&gt; dir(d)            
['clear', 'copy', 'get', 'has_key', 'items', 'keys', 'setdefault', 'update', 'values']

# 列举odbchelper对象的成员
&gt;&gt;&gt; import odbchelper
&gt;&gt;&gt; dir(odbchelper)   
['__builtins__', '__doc__', '__file__', '__name__', 'buildConnectionString']
</pre>

<h2 id="toc_1.5">callable（判断方法是否可执行）</h2>
<pre class="brush:python">
# 列举string的两个成员，一个是字符串，一个是函数
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.punctuation           
'!"#$%&amp;\'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~'
&gt;&gt;&gt; string.join                  
&lt;function join at 00C55A7C&gt;

# 使用callable来测试这两个成员是否可调用
&gt;&gt;&gt; callable(string.punctuation) 
False
&gt;&gt;&gt; callable(string.join)        
True
&gt;&gt;&gt; print string.join.__doc__    
join(list [,sep]) -&gt; string
</pre>

<h2 id="toc_1.6">isinstance（判断一个对象是否是类的实例）</h2>
<pre class="brush:python">
&gt;&gt;&gt; import types
&gt;&gt;&gt; str = 'hello'
&gt;&gt;&gt; isinstance(str, types.StringType)
True
</pre>

<h2 id="toc_1.7">eval（执行字符串代码）</h2>
<ul>
<li>
eval接收string类型的对象作为参数，并执行该对象包含的代码，返回执行结果

</ul>

<pre class="brush:python">
# 示例一
&gt;&gt;&gt; a = 345
&gt;&gt;&gt; b = 556
&gt;&gt;&gt; sum = 'a+b'

&gt;&gt;&gt; eval(sum)
&gt;&gt;&gt; 901

# 示例二
&gt;&gt;&gt; openFile = 'open("~/hello.txt", "r")'
&gt;&gt;&gt; file = eval(openFile)
&lt;open file '~/hello.txt', mode 'r' at 0x98577b0&gt;

&gt;&gt;&gt; file.read()
helloworld
</pre>

<h2 id="toc_1.8">enumerate（为list对象成员编号）</h2>
<ul>
<li>
enumerate为一个list对象排序，返回每个成员对应的序号。

</ul>

<pre class="brush:python">
&gt;&gt;&gt; l = ['orange', 'apple', 'black', 'white']
&gt;&gt;&gt; e = enumerate(l)
&gt;&gt;&gt; for i in e:
&gt;&gt;&gt;     print i
&gt;&gt;&gt;     
(0, 'orange')
(1, 'apple')
(2, 'black')
(3, 'white')
</pre>

<h2 id="toc_1.9">getattr（获取对象的方法引用）</h2>
<ul>
<li>
在运行时获取一个对象的方法的引用。

</ul>

<pre class="brush:python">
&gt;&gt;&gt; li = ["Larry", "Curly"]
# 获取list的pop方法引用
&gt;&gt;&gt; getattr(li, "pop")           
&lt;built-in method pop of list object at 010DF884&gt;
# 直接调用该方法的引用
&gt;&gt;&gt; getattr(li, "append")("Moe") 
&gt;&gt;&gt; li
["Larry", "Curly", "Moe"]
</pre>

<h2 id="toc_1.10">lambda（匿名函数）</h2>
<ul>
<li>
匿名函数的语法：lambda {param}:{statement}

</ul>

<pre class="brush:python">
&gt;&gt;&gt; g = lambda x: x*2 
&gt;&gt;&gt; g(3)
6

&gt;&gt;&gt; (lambda x: x*2)(3)
6
</pre>

<h2 id="toc_1.11">__<em>import</em>__（动态导入模块）</h2>
<ul>
<li>
内建_<em>import</em>_函数与import语句实现的功能相同，用来导入一个模块。但它是一个真正的函数，并接受一个字符串作为参数。

</ul>

<pre class="brush:python">
# 将模块名的字符串作为参数传入__import__方法
&gt;&gt;&gt; sys = __import__('sys')
&gt;&gt;&gt; os = __import__('os')
&gt;&gt;&gt; re = __import__('re')
&gt;&gt;&gt; unittest = __import__('unittest')

# 导入动态链接库
&gt;&gt;&gt; cdll = __import__('pychartdir27')
&gt;&gt;&gt; cdll.callMethod
&gt;&gt;&gt; &lt;function pychartdir27.callMethod&gt;

&gt;&gt;&gt; cdll.id
&gt;&gt;&gt; 'pychartdir27'

&gt;&gt;&gt; cdll.applyMethod
&gt;&gt;&gt; &lt;function pychartdir27.applyMethod&gt;

# 查看返回的变量
&gt;&gt;&gt; sys
&gt;&gt;&gt; &lt;module 'sys' (built-in)&gt;
&gt;&gt;&gt; os
&gt;&gt;&gt; &lt;module 'os' from '/usr/local/lib/python2.2/os.pyc'&gt;
</pre>

<h2 id="toc_1.12">map（列表数据的批量处理）</h2>
<ul>
<li>
将一组参数列表传入到给定的函数中，并依次调用该函数，最后将函数的执行结果传入到列表中并返回。

</ul>

<pre class="brush:python">
# 将模块名作为参数列表传入映射给__import__方法
&gt;&gt;&gt; moduleNames = ['sys', 'os', 're', 'unittest']
&gt;&gt;&gt; modules = map(__import__, moduleNames)

# 返回一组模块对象的列表
&gt;&gt;&gt; modules
[&lt;module 'sys' (built-in)&gt;,
&lt;module 'os' from 'c:\Python22\lib\os.pyc'&gt;,
&lt;module 're' from 'c:\Python22\lib\re.pyc'&gt;,
&lt;module 'unittest' from 'c:\Python22\lib\unittest.pyc'&gt;]

# 通过列表元素调用sys模块的方法
&gt;&gt;&gt; modules[0].version
'2.2.2 (#37, Nov 26 2002, 10:24:37) [MSC 32 bit (Intel)]'
</pre>

<h2 id="toc_1.13">filter（列表数据过滤处理）</h2>
<ul>
<li>
将一组参数列表传入给定的函数中，该函数返回bool类型。如果函数调用结果为真，则该结果会出现在结果的列表中，结果为假，则被过滤掉。调用的过程同map一样。

</ul>

<pre class="brush:python">
# 定义一个取模的lambda方法，并应用于一组列表[1, 2, 3, 4, 5]
&gt;&gt;&gt; filter(lambda x : x % 2 == 0, [1, 2, 3, 4, 5])
[2, 4]

# 该方法同样可用映射List的方式实现
&gt;&gt;&gt; list_a = [1, 2, 3, 4, 5]
&gt;&gt;&gt; [x for x in list_a if x % 2 == 0]
[2, 4]
</pre>

<h2 id="toc_1.14">reduce（列表数据递减处理）</h2>
<ul>
<li>
将一组参数列表的前两个数作为参数传给指定的函数，并将结果置为列表顶端，同时删除前两个数，依次执行这个过程，返回最终的数。

<li>
第三个参数作为一个初始值，代替列表中的第一个数。

</ul>

<pre class="brush:python">
# 本例中[1, 2, 3, 4]列表中的数会连续相加，求解过程为：1 + 2 + 3 + 4 = 10
&gt;&gt;&gt; reduce(lambda x, y : x + y,[1, 2, 3, 4])
10

# 10为初始值，作为列表的第一个数，求解过程为：10 + 1 + 2 + 3 + 4 = 20
&gt;&gt;&gt; reduce(lambda x, y : x + y, [1, 2, 3, 4], 10)
20
</pre>

<h2 id="toc_1.15">print（格式化打印输出）</h2>

<pre class="brush:python">
# 向标准输出打印
&gt;&gt;&gt; print "%s %s" % ("hello", "world")
hello world

# 向错误输出打印
&gt;&gt;&gt; print &gt;&gt;sys.stderr, "%s %s" % ("hello", "world")
hello world

# 格式化
print("%+10x" % 10)     # +a
print("%04d" % 5)       # 0005
print("%6.3f" % 2.3)    # 2.300

# 动态格式化参数，*号由4代替
print("%.*f" % (4, 1.2))    # 1.2000
</pre>

<h2 id="toc_1.16">zip（数据扁平处理）</h2>
<pre class="brush:python">
# 打包和解包列表
&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = ['a', 'b', 'c']
&gt;&gt;&gt; z = zip(a, b)
&gt;&gt;&gt; z
[(1, 'a'), (2, 'b'), (3, 'c')]
&gt;&gt;&gt; zip(*z)
[(1, 2, 3), ('a', 'b', 'c')]

# 合并相邻列表项，每2个合并一组
&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; zip(*([iter(a)] * 2))
[(1, 2), (3, 4), (5, 6)]

# 生成滑动窗口
&gt;&gt;&gt; from itertools import islice
&gt;&gt;&gt; def n_grams(a, n):
...     z = (islice(a, i, None) for i in range(n))
...     return zip(*z)
...
&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; n_grams(a, 2)
[(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]
&gt;&gt;&gt; n_grams(a, 3)
[(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]
&gt;&gt;&gt; n_grams(a, 4)
[(1, 2, 3, 4), (2, 3, 4, 5), (3, 4, 5, 6)]

# 反转字典
&gt;&gt;&gt; m = {'a': 1, 'b': 2, 'c': 3, 'd': 4}
&gt;&gt;&gt; m.items()
[('a', 1), ('c', 3), ('b', 2), ('d', 4)]
&gt;&gt;&gt; zip(m.values(), m.keys())
[(1, 'a'), (3, 'c'), (2, 'b'), (4, 'd')]
&gt;&gt;&gt; mi = dict(zip(m.values(), m.keys()))
&gt;&gt;&gt; mi
{1: 'a', 2: 'b', 3: 'c', 4: 'd'}
</pre>

<h2 id="toc_1.17">repr（返回对象的字符串表示）</h2>
<ul>
<li>
返回对象的字符串表示。
<pre class="brush:python">
&gt;&gt;&gt; a = 'hello'
&gt;&gt;&gt; repr(a)
&gt;&gt;&gt; "'hello'"

&gt;&gt;&gt; b = 1
&gt;&gt;&gt; repr(b)
&gt;&gt;&gt; '1'
</pre>

</ul>

<h2 id="toc_1.18">with as（优雅的异常处理机制）</h2>
<pre class="brush:python">
class Sample:
    # 定义_enter_方法用于初始化
    def __enter__(self):
        print "In __enter__()"
        return "Foo"
 
    # 定义_exit_方法用于释放资源
    def __exit__(self, type, value, trace):
        print "In __exit__()"
 
def get_sample():
    return Sample()
 
with get_sample() as sample:
    print "sample:", sample
</pre>

<h2 id="toc_1.19">property（将函数变成可访问的属性）</h2>
<ul>
<li>
birth是可读写属性，而age就是一个只读属性，因为age可以根据birth和当前时间计算出来。
<pre class="brush:python">
# 实现方式一
class Student(object):
    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2014 - self._birth
        
# 实现方式二
class Student(object):
    @property
    def birth(self):
        return self._birth

    def set_birth(self, value):
        self._birth = value
        
    def get_birth(self):
        return self._birth

    self._birth = property(get_birth, set_birth)
</pre>

</ul>


<footer>
    <a href="http://zenki2001cn.github.com/Wiki" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="zenki2001cn@163.com" id="back-email">Email</a>
</footer>

</article>
</div>

</body>
</html>
