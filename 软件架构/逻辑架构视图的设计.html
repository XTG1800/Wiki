<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>逻辑架构视图的设计</title>
    <!--格式化代码的特效脚本-->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCSharp.js"></script>
    <script type="text/javascript" src="scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="scripts/shBrushDelphi.js"></script>
    <script type="text/javascript" src="scripts/shBrushDiff.js"></script>
    <script type="text/javascript" src="scripts/shBrushGroovy.js"></script>
    <script type="text/javascript" src="scripts/shBrushJava.js"></script>
    <script type="text/javascript" src="scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/shBrushPhp.js"></script>
    <script type="text/javascript" src="scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="scripts/shBrushPlain.js"></script>
    <script type="text/javascript" src="scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="scripts/shBrushVb.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/shCoreZenki.css"/>
    <link type="text/css" rel="stylesheet" href="styles/shThemeZenki.css"/>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
	<link type="text/css" rel="stylesheet" href="css_style/style_zenki.css"/>

</head>

<body>
<div id="wrapper">
<header>

<div id="logo">
</div>

<nav>
    <ul>
        <!--<li class="first"><a href="diary/diary.html">日记</a></li>-->
     </ul>
</nav>
</header>

<article>


<h1 id="toc_1">逻辑架构视图的设计</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">逻辑架构视图的设计</a></li>
<ul>
<li><a href="#toc_1.1">概要</a></li>
<li><a href="#toc_1.2">三种实践策略</a></li>
<ul>
<li><a href="#toc_1.2.1">分层</a></li>
<li><a href="#toc_1.2.2">分区</a></li>
<ul>
<li><a href="#toc_1.2.2.1">广度优先和深度优先</a></li>
<li><a href="#toc_1.2.2.2">分区设计</a></li>
<li><a href="#toc_1.2.2.3">参考图</a></li>
</ul>
<li><a href="#toc_1.2.3">机制</a></li>
<ul>
<li><a href="#toc_1.2.3.1">什么是机制</a></li>
<li><a href="#toc_1.2.3.2">提取机制的示例</a></li>
</ul>
</ul>
<li><a href="#toc_1.3">总结</a></li>
<ul>
<li><a href="#toc_1.3.1">关注点分离</a></li>
<li><a href="#toc_1.3.2">分层的维度</a></li>
<li><a href="#toc_1.3.3">三种策略的设计原则</a></li>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">概要</h2>
<ul>
<li>
首先是3种必用手段;
</li>
<li>
随后,纠正“我的接口我做主”这种错误认识,代之以“协作决定接口”的正确理解;
</li>
<li>
而且,本章将解析逻辑架构设计的整体思维套路,解决一线架构师郁闷已久的“多视图方法只讲做什么、不讲怎么做”的问题;
</li>
<li>
最后,总结逻辑架构设计的10条经验要点。
</li>
</ul>

<h2 id="toc_1.2">三种实践策略</h2>
<ul>
<li>
分层的细化。
</li>
<li>
分区的引入。
</li>
<li>
机制的提取。
</li>
</ul>

<h3 id="toc_1.2.1">分层</h3>
<pre class="brush:text">
1.  分层是最常用的架构模式,而笔者进一步认为:在架构设计初期,100%的系统都可以用分层架构,就算随着设计的深入而采用了其他架构模式也未必和分层架构矛盾。
2.  于是,架构师在划分子系统时常受到初期分层方式的影响——实际上,很多一线架构师最熟知、最自然的划分子系统的方式就是:分层的细化。
</pre>

<p>
<a href="pic/layer.png"><img src="pic/layer.png" /></a>
</p>

<h3 id="toc_1.2.2">分区</h3>
<h4 id="toc_1.2.2.1">广度优先和深度优先</h4>
<pre class="brush:text">
    广度优先极端情况下意味着对每一个功能进行定义,然后对每个功能进行设计,接着对每个功能进行编码,最后才对所有功能一起进行测试。而深度优先极端情况下
意味着对每个功能完整地进行定义、设计、编码和测试,而只有当这个功能完成了之后,你才能做下一个功能。当然,两个极端都是不好的,但深度优先要好得多。
对于大部分团队来说,应该做一个高级的广度设计,然后马上转到深度优先的底层设计和实现上去。
</pre>

<h4 id="toc_1.2.2.2">分区设计</h4>
<pre class="brush:text">
    为了支持迭代开发,逻辑架构设计中必须(注意是必须)引入分区。分区是一种单元,它位于某个层的内部,其粒度比层要小。一旦架构师针对每个层进行了分区设计,
“深度优先”式的迭代开发就非常自然。
</pre>

<h4 id="toc_1.2.2.3">参考图</h4>
<p>
<a href="pic/partition.png"><img src="pic/partition.png" /></a>
</p>

<h3 id="toc_1.2.3">机制</h3>
<p>
<em>机制才是设计的灵魂所在......否则我们就将不得不面对一群无法相互协作的对象,它们相互推搡着做自己的事情而毫不关心其他对象。</em>
</p>

<h4 id="toc_1.2.3.1">什么是机制</h4>
<ul>
<li>
基于接口(和抽象类)的协作是机制,基于具体类的协作则算不上机制。
</li>
</ul>

<pre class="brush:text">
定义：软件系统中的机制,是指预先定义好的、能够完成预期目标的、基于抽象角色的协作方式。机制不仅包含了协作关系,同时也包含了协作流程。
</pre>

<h4 id="toc_1.2.3.2">提取机制的示例</h4>
<p>
<a href="pic/jizhi.png"><img src="pic/jizhi.png" /></a>
</p>

<h2 id="toc_1.3">总结</h2>
<h3 id="toc_1.3.1">关注点分离</h3>
<pre class="brush:text">
《软件架构设计》：
    首先,可以通过职责划分来分离关注点。 面向对象设计的关键所在, 就是职责的识别和分配。 每个功能的完成,都是通过一系列职责组成的“协作链条”完成的;
当不同职责被合理分离之后, 为了实现新的功能只须构造新的“协作链条” ,而需求变更也往往只会影响到少数职责的定义和实现......
    其次,可以利用软件系统各部分的通用性不同进行关注点分离。不同的通用程度意味着变化的可能性不同,将通用性不同的部分分离有利于通用部分的重用,也便于对专用部分修改......
    另外,还可以先考虑大粒度的子系统,而暂时忽略子系统是如何通过更小粒度的模块和类组......
</pre>

<h3 id="toc_1.3.2">分层的维度</h3>
<ul>
<li>
首先,分层和机制位于不同的维度:<code>职责维</code>及<code>通用维</code>。
</li>
<li>
另外,是否引入分区,设计所“覆盖”的Scope是完全相同的。原因是层的粒度较大,而层内部引入的分区的粒度更小,便于组合出一个个功能(支持迭代开发)。这是第三维:<code>粒度</code>。
</li>
</ul>

<p>
<a href="pic/3维度.png"><img src="pic/3维度.png" /></a>
</p>

<h3 id="toc_1.3.3">三种策略的设计原则</h3>
<ul>
<li>
职责不同的单元划归不同子系统。
</li>
<li>
通用性不同的单元划归不同子系统。
</li>
<li>
需要不同开发技能的单元划归不同子系统。
</li>
<li>
兼顾工作量的相对均衡,进一步切分太大的子系统。
</li>
</ul>

<p>
<a href="pic/4大原则.png"><img src="pic/4大原则.png" /></a>
</p>
<footer>
    <a href="index.html" id="back-home">首页</a>
    <a href="index.html" id="back-about">关于</a>
    <a href="http://www.163.com/" id="back-email">Email</a>
</footer>

</article>
</div>

<!--<script type="text/javascript">-->
<!--var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");-->
<!--document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));-->
<!--</script>-->
<!--<script type="text/javascript">-->
<!--try {-->
<!--var pageTracker = _gat._getTracker("UA-15922433-1");-->
<!--pageTracker._trackPageview();-->
<!--} catch(err) {}-->
<!--</script>-->

</body>
</html>
